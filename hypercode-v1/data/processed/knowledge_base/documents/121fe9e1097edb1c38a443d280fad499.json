{
  "file_name": "serialize.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\venv_new\\Lib\\site-packages\\pip\\_vendor\\cachecontrol\\serialize.py",
  "file_size": 5163,
  "created": "2025-12-01T01:58:31.789564",
  "modified": "2025-12-01T01:58:31.790105",
  "file_type": "code",
  "content_hash": "10331aad89207954e35a6a16098170f7",
  "content_type": "text",
  "content": "# SPDX-FileCopyrightText: 2015 Eric Larson\n#\n# SPDX-License-Identifier: Apache-2.0\nfrom __future__ import annotations\n\nimport io\nfrom typing import IO, TYPE_CHECKING, Any, Mapping, cast\n\nfrom pip._vendor import msgpack\nfrom pip._vendor.requests.structures import CaseInsensitiveDict\nfrom pip._vendor.urllib3 import HTTPResponse\n\nif TYPE_CHECKING:\n    from pip._vendor.requests import PreparedRequest\n\n\nclass Serializer:\n    serde_version = \"4\"\n\n    def dumps(\n        self,\n        request: PreparedRequest,\n        response: HTTPResponse,\n        body: bytes | None = None,\n    ) -> bytes:\n        response_headers: CaseInsensitiveDict[str] = CaseInsensitiveDict(\n            response.headers\n        )\n\n        if body is None:\n            # When a body isn't passed in, we'll read the response. We\n            # also update the response with a new file handler to be\n            # sure it acts as though it was never read.\n            body = response.read(decode_content=False)\n            response._fp = io.BytesIO(body)  # type: ignore[assignment]\n            response.length_remaining = len(body)\n\n        data = {\n            \"response\": {\n                \"body\": body,  # Empty bytestring if body is stored separately\n                \"headers\": {str(k): str(v) for k, v in response.headers.items()},\n                \"status\": response.status,\n                \"version\": response.version,\n                \"reason\": str(response.reason),\n                \"decode_content\": response.decode_content,\n            }\n        }\n\n        # Construct our vary headers\n        data[\"vary\"] = {}\n        if \"vary\" in response_headers:\n            varied_headers = response_headers[\"vary\"].split(\",\")\n            for header in varied_headers:\n                header = str(header).strip()\n                header_value = request.headers.get(header, None)\n                if header_value is not None:\n                    header_value = str(header_value)\n                data[\"vary\"][header] = header_value\n\n        return b\",\".join([f\"cc={self.serde_version}\".encode(), self.serialize(data)])\n\n    def serialize(self, data: dict[str, Any]) -> bytes:\n        return cast(bytes, msgpack.dumps(data, use_bin_type=True))\n\n    def loads(\n        self,\n        request: PreparedRequest,\n        data: bytes,\n        body_file: IO[bytes] | None = None,\n    ) -> HTTPResponse | None:\n        # Short circuit if we've been given an empty set of data\n        if not data:\n            return None\n\n        # Previous versions of this library supported other serialization\n        # formats, but these have all been removed.\n        if not data.startswith(f\"cc={self.serde_version},\".encode()):\n            return None\n\n        data = data[5:]\n        return self._loads_v4(request, data, body_file)\n\n    def prepare_response(\n        self,\n        request: PreparedRequest,\n        cached: Mapping[str, Any],\n        body_file: IO[bytes] | None = None,\n    ) -> HTTPResponse | None:\n        \"\"\"Verify our vary headers match and construct a real urllib3\n        HTTPResponse object.\n        \"\"\"\n        # Special case the '*' Vary value as it means we cannot actually\n        # determine if the cached response is suitable for this request.\n        # This case is also handled in the controller code when creating\n        # a cache entry, but is left here for backwards compatibility.\n        if \"*\" in cached.get(\"vary\", {}):\n            return None\n\n        # Ensure that the Vary headers for the cached response match our\n        # request\n        for header, value in cached.get(\"vary\", {}).items():\n            if request.headers.get(header, None) != value:\n                return None\n\n        body_raw = cached[\"response\"].pop(\"body\")\n\n        headers: CaseInsensitiveDict[str] = CaseInsensitiveDict(\n            data=cached[\"response\"][\"headers\"]\n        )\n        if headers.get(\"transfer-encoding\", \"\") == \"chunked\":\n            headers.pop(\"transfer-encoding\")\n\n        cached[\"response\"][\"headers\"] = headers\n\n        try:\n            body: IO[bytes]\n            if body_file is None:\n                body = io.BytesIO(body_raw)\n            else:\n                body = body_file\n        except TypeError:\n            # This can happen if cachecontrol serialized to v1 format (pickle)\n            # using Python 2. A Python 2 str(byte string) will be unpickled as\n            # a Python 3 str (unicode string), which will cause the above to\n            # fail with:\n            #\n            #     TypeError: 'str' does not support the buffer interface\n            body = io.BytesIO(body_raw.encode(\"utf8\"))\n\n        # Discard any `strict` parameter serialized by older version of cachecontrol.\n        cached[\"response\"].pop(\"strict\", None)\n\n        return HTTPResponse(body=body, preload_content=False, **cached[\"response\"])\n\n    def _loads_v4(\n        self,\n        request: PreparedRequest,\n        data: bytes,\n        body_file: IO[bytes] | None = None,\n    ) -> HTTPResponse | None:\n        try:\n            cached = msgpack.loads(data, raw=False)\n        except ValueError:\n            return None\n\n        return self.prepare_response(request, cached, body_file)\n",
  "metadata": {},
  "relative_path": "venv_new\\Lib\\site-packages\\pip\\_vendor\\cachecontrol\\serialize.py",
  "id": "121fe9e1097edb1c38a443d280fad499"
}