{
  "file_name": "codec.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\venv_new\\Lib\\site-packages\\pip\\_vendor\\idna\\codec.py",
  "file_size": 3422,
  "created": "2025-12-01T01:58:32.079837",
  "modified": "2025-12-01T01:58:32.091988",
  "file_type": "code",
  "content_hash": "abcf05aec6db6b1dcef409433f57fcd2",
  "content_type": "text",
  "content": "import codecs\nimport re\nfrom typing import Any, Optional, Tuple\n\nfrom .core import IDNAError, alabel, decode, encode, ulabel\n\n_unicode_dots_re = re.compile(\"[\\u002e\\u3002\\uff0e\\uff61]\")\n\n\nclass Codec(codecs.Codec):\n    def encode(self, data: str, errors: str = \"strict\") -> Tuple[bytes, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n\n        if not data:\n            return b\"\", 0\n\n        return encode(data), len(data)\n\n    def decode(self, data: bytes, errors: str = \"strict\") -> Tuple[str, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n\n        if not data:\n            return \"\", 0\n\n        return decode(data), len(data)\n\n\nclass IncrementalEncoder(codecs.BufferedIncrementalEncoder):\n    def _buffer_encode(self, data: str, errors: str, final: bool) -> Tuple[bytes, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n\n        if not data:\n            return b\"\", 0\n\n        labels = _unicode_dots_re.split(data)\n        trailing_dot = b\"\"\n        if labels:\n            if not labels[-1]:\n                trailing_dot = b\".\"\n                del labels[-1]\n            elif not final:\n                # Keep potentially unfinished label until the next call\n                del labels[-1]\n                if labels:\n                    trailing_dot = b\".\"\n\n        result = []\n        size = 0\n        for label in labels:\n            result.append(alabel(label))\n            if size:\n                size += 1\n            size += len(label)\n\n        # Join with U+002E\n        result_bytes = b\".\".join(result) + trailing_dot\n        size += len(trailing_dot)\n        return result_bytes, size\n\n\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def _buffer_decode(self, data: Any, errors: str, final: bool) -> Tuple[str, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n\n        if not data:\n            return (\"\", 0)\n\n        if not isinstance(data, str):\n            data = str(data, \"ascii\")\n\n        labels = _unicode_dots_re.split(data)\n        trailing_dot = \"\"\n        if labels:\n            if not labels[-1]:\n                trailing_dot = \".\"\n                del labels[-1]\n            elif not final:\n                # Keep potentially unfinished label until the next call\n                del labels[-1]\n                if labels:\n                    trailing_dot = \".\"\n\n        result = []\n        size = 0\n        for label in labels:\n            result.append(ulabel(label))\n            if size:\n                size += 1\n            size += len(label)\n\n        result_str = \".\".join(result) + trailing_dot\n        size += len(trailing_dot)\n        return (result_str, size)\n\n\nclass StreamWriter(Codec, codecs.StreamWriter):\n    pass\n\n\nclass StreamReader(Codec, codecs.StreamReader):\n    pass\n\n\ndef search_function(name: str) -> Optional[codecs.CodecInfo]:\n    if name != \"idna2008\":\n        return None\n    return codecs.CodecInfo(\n        name=name,\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader,\n    )\n\n\ncodecs.register(search_function)\n",
  "metadata": {},
  "relative_path": "venv_new\\Lib\\site-packages\\pip\\_vendor\\idna\\codec.py",
  "id": "7836fddf0e6754455f87d0750c21d187"
}