{
  "file_name": "duelcode_validator.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\src\\duelcode_validator.py",
  "file_size": 12502,
  "created": "2025-11-23T12:01:48.274043",
  "modified": "2025-11-23T12:01:48.274043",
  "file_type": "code",
  "content_hash": "bc8701164fe73965f5bd531f5230cc40",
  "content_type": "text",
  "content": "\"\"\"\nEnhanced DuelCode Documentation Validator\n\nThis script provides comprehensive validation for DuelCode documentation format,\nensuring consistency and quality across all DuelCode tutorials.\n\"\"\"\n\nimport re\nimport sys\nfrom dataclasses import dataclass\nfrom enum import Enum, auto\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple\n\n\nclass Severity(Enum):\n    ERROR = auto()\n    WARNING = auto()\n    INFO = auto()\n\n\n@dataclass\nclass ValidationResult:\n    message: str\n    severity: Severity\n    line: Optional[int] = None\n    col: Optional[int] = None\n\n\nclass DuelCodeValidator:\n    \"\"\"Validates DuelCode documentation files against the required format.\"\"\"\n\n    # Supported programming languages for code blocks\n    SUPPORTED_LANGUAGES = {\n        \"python\",\n        \"javascript\",\n        \"typescript\",\n        \"java\",\n        \"c\",\n        \"cpp\",\n        \"csharp\",\n        \"go\",\n        \"rust\",\n        \"ruby\",\n        \"php\",\n        \"swift\",\n        \"kotlin\",\n        \"dart\",\n    }\n\n    def __init__(self, file_path: str):\n        self.file_path = Path(file_path)\n        self.content = self.file_path.read_text(encoding=\"utf-8\")\n        self.lines = self.content.split(\"\\n\")\n        self.results: List[ValidationResult] = []\n        self._line_cache: Dict[str, List[Tuple[int, str]]] = {}\n\n    def _add_result(\n        self, message: str, severity: Severity, line: Optional[int] = None\n    ) -> None:\n        \"\"\"Add a validation result with proper line number.\"\"\"\n        col = None\n        if line is not None and 0 <= line < len(self.lines):\n            col = (\n                len(self.lines[line]) - len(self.lines[line].lstrip()) + 1\n                if self.lines[line].strip()\n                else 1\n            )\n        self.results.append(ValidationResult(message, severity, line, col))\n\n    def _find_lines(self, pattern: str) -> List[Tuple[int, str]]:\n        \"\"\"Find all lines matching the pattern with their line numbers.\"\"\"\n        if pattern not in self._line_cache:\n            self._line_cache[pattern] = [\n                (i, line)\n                for i, line in enumerate(self.lines)\n                if re.search(pattern, line)\n            ]\n        return self._line_cache[pattern]\n\n    def validate(self) -> bool:\n        \"\"\"Run all validation checks.\"\"\"\n        self.validate_structure()\n        self.validate_headings()\n        self.validate_code_blocks()\n        self.validate_checklists()\n        self.validate_visual_elements()\n        self.validate_links()\n\n        # Return True if there are no errors (warnings are allowed)\n        return not any(r.severity == Severity.ERROR for r in self.results)\n\n    def validate_structure(self) -> None:\n        \"\"\"Validate the overall document structure.\"\"\"\n        # Check for required top-level sections\n        required_sections = [\n            (r\"^# .+\", \"Document title (H1)\"),\n            (r\"^## üéØ Learning Objective\", \"Learning Objectives section\"),\n            (r\"^## üìã Before You Start\", \"Before You Start checklist\"),\n            (r\"^## Part \\d+:\", \"At least one Part section\"),\n        ]\n\n        for pattern, name in required_sections:\n            if not self._find_lines(pattern):\n                self._add_result(f\"Missing required section: {name}\", Severity.ERROR)\n\n        # Check for proper section order\n        section_order = [\n            (r\"^# \", \"Document title\"),\n            (r\"^## üéØ\", \"Learning Objectives\"),\n            (r\"^## üìã\", \"Before You Start\"),\n            (r\"^## Part 1:\", \"First Part section\"),\n        ]\n\n        last_index = -1\n        for pattern, name in section_order:\n            matches = self._find_lines(pattern)\n            if not matches:\n                continue\n            current_index = matches[0][0]\n            if current_index <= last_index:\n                self._add_result(\n                    f\"Section out of order: {name} appears after a section that should come later\",\n                    Severity.ERROR,\n                    current_index,\n                )\n            last_index = current_index\n\n    def validate_headings(self) -> None:\n        \"\"\"Validate heading hierarchy and formatting.\"\"\"\n        headings = []\n        for i, line in enumerate(self.lines):\n            if match := re.match(r\"^(#{1,6})\\s+(.+)$\", line):\n                level = len(match.group(1))\n                text = match.group(2).strip()\n                headings.append((i, level, text))\n\n                # Check for proper heading capitalization (first word and proper nouns)\n                if not text[0].isupper():\n                    self._add_result(\n                        \"Headings should start with a capital letter\",\n                        Severity.WARNING,\n                        i,\n                    )\n\n                # Check for proper heading formatting (no trailing punctuation)\n                if text.endswith((\".\", \":\", \";\", \",\")):\n                    self._add_result(\n                        \"Headings should not end with punctuation\", Severity.WARNING, i\n                    )\n\n        # Check heading hierarchy\n        prev_level = 0\n        for i, (line_num, level, text) in enumerate(headings):\n            if i == 0 and level != 1:\n                self._add_result(\n                    \"First heading should be a level 1 heading (#)\",\n                    Severity.ERROR,\n                    line_num,\n                )\n\n            if level > prev_level + 1:\n                self._add_result(\n                    f\"Heading level jumps from {prev_level} to {level}\",\n                    Severity.ERROR,\n                    line_num,\n                )\n\n            prev_level = level\n\n    def validate_code_blocks(self) -> None:\n        \"\"\"Validate code blocks for proper formatting and language specification.\"\"\"\n        in_code_block = False\n        current_lang = None\n        code_block_start = 0\n\n        for i, line in enumerate(self.lines):\n            # Check for code block start\n            if line.startswith(\"```\"):\n                if not in_code_block:\n                    in_code_block = True\n                    code_block_start = i\n                    # Get language if specified\n                    lang = line[3:].strip()\n                    if lang and not any(\n                        lang.lower() == l.lower() for l in self.SUPPORTED_LANGUAGES\n                    ):\n                        self._add_result(\n                            f\"Unsupported code language: {lang}\", Severity.WARNING, i\n                        )\n                    current_lang = lang.lower() if lang else None\n                else:\n                    # Check for empty code blocks\n                    if i - code_block_start <= 1:  # Only the opening line\n                        self._add_result(\n                            \"Empty code block\", Severity.WARNING, code_block_start\n                        )\n                    in_code_block = False\n\n            # Inside code block checks\n            elif in_code_block and current_lang == \"python\":\n                # Example: Check for Python-specific issues\n                if \"    \" in line and \"\\t\" in line:\n                    self._add_result(\n                        \"Inconsistent indentation (mixing tabs and spaces)\",\n                        Severity.ERROR,\n                        i,\n                    )\n\n    def validate_checklists(self) -> None:\n        \"\"\"Validate checklist items in the document.\"\"\"\n        in_checklist = False\n        checklist_items = []\n\n        for i, line in enumerate(self.lines):\n            # Detect checklist section\n            if line.strip() == \"## üìã Before You Start\":\n                in_checklist = True\n                continue\n            if in_checklist and line.startswith(\"## \"):\n                in_checklist = False\n                break\n\n            if in_checklist and line.strip().startswith(\"- [ ]\"):\n                item = line.strip()[5:].strip()\n                if not item.endswith(\".\"):\n                    self._add_result(\n                        \"Checklist items should end with a period\", Severity.WARNING, i\n                    )\n                if not item[0].isupper():\n                    self._add_result(\n                        \"Checklist items should start with a capital letter\",\n                        Severity.WARNING,\n                        i,\n                    )\n                checklist_items.append((i, item))\n\n        if len(checklist_items) < 3:\n            self._add_result(\n                \"Checklist should have at least 3 items\",\n                Severity.WARNING,\n                0,  # Will be adjusted to the checklist section\n            )\n\n    def validate_visual_elements(self) -> None:\n        \"\"\"Validate visual elements like diagrams, images, etc.\"\"\"\n        # Check for visual representation sections\n        visual_sections = self._find_lines(r\"^### üìä Visual Representation\")\n\n        for line_num, _ in visual_sections:\n            # Check if there's content after the visual representation heading\n            has_content = False\n            for i in range(line_num + 1, min(line_num + 5, len(self.lines))):\n                if self.lines[i].strip() and not self.lines[i].startswith(\"```\"):\n                    has_content = True\n                    break\n\n            if not has_content:\n                self._add_result(\n                    \"Visual Representation section is empty\", Severity.WARNING, line_num\n                )\n\n    def validate_links(self) -> None:\n        \"\"\"Validate internal and external links.\"\"\"\n        # Check for broken markdown links\n        for i, line in enumerate(self.lines):\n            # Check for markdown links [text](url)\n            for match in re.finditer(r\"\\[(?P<text>[^\\]]+)\\]\\((?P<url>[^)]+)\\)\", line):\n                url = match.group(\"url\")\n                # Skip anchor links for now\n                if url.startswith(\"#\"):\n                    continue\n\n                # Check for empty link text\n                if not match.group(\"text\").strip():\n                    self._add_result(\"Link text cannot be empty\", Severity.ERROR, i)\n\n                # Check for URLs with spaces\n                if \" \" in url:\n                    self._add_result(f\"URL contains spaces: {url}\", Severity.ERROR, i)\n\n\ndef print_validation_results(validator: DuelCodeValidator) -> None:\n    \"\"\"Print validation results in a user-friendly format.\"\"\"\n    if not validator.results:\n        print(\"‚úÖ No issues found!\")\n        return\n\n    # Group results by severity\n    by_severity: Dict[Severity, List[ValidationResult]] = {\n        Severity.ERROR: [],\n        Severity.WARNING: [],\n        Severity.INFO: [],\n    }\n\n    for result in validator.results:\n        by_severity[result.severity].append(result)\n\n    # Print errors first, then warnings, then info\n    for severity, results in by_severity.items():\n        if not results:\n            continue\n\n        print(f\"\\n{severity.name}S ({(len(results))}):\")\n        print(\"=\" * (len(severity.name) + 10))\n\n        for result in results:\n            location = (\n                f\"line {result.line}\" if result.line is not None else \"unknown location\"\n            )\n            if result.col is not None:\n                location += f\":{result.col}\"\n            print(f\"‚Ä¢ {result.message} (at {location})\")\n\n\ndef main() -> None:\n    \"\"\"Main entry point for the validator.\"\"\"\n    if len(sys.argv) != 2:\n        print(\"Usage: python duelcode_validator.py <markdown_file>\")\n        sys.exit(1)\n\n    file_path = sys.argv[1]\n    if not Path(file_path).exists():\n        print(f\"Error: File '{file_path}' not found\")\n        sys.exit(1)\n\n    validator = DuelCodeValidator(file_path)\n    is_valid = validator.validate()\n\n    print(f\"Validating: {file_path}\")\n    print(\"-\" * 50)\n\n    print_validation_results(validator)\n\n    if not is_valid:\n        print(\"\\n‚ùå Validation failed with errors\")\n        sys.exit(1)\n    elif any(r.severity == Severity.WARNING for r in validator.results):\n        print(\"\\n‚ö†Ô∏è  Validation passed with warnings\")\n    else:\n        print(\"\\n‚úÖ Validation passed successfully!\")\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "metadata": {},
  "relative_path": "src\\duelcode_validator.py",
  "id": "efa8fcf12ac23ae7e0f773beaba1182e"
}