{
  "file_name": "db.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\hypercode\\new files to check\\backend\\research\\db.py",
  "file_size": 2515,
  "created": "2025-11-30T20:22:52.751831",
  "modified": "2025-11-30T20:22:52.753964",
  "file_type": "code",
  "content_hash": "b99bb8eac9015515bb1a684bc9053d52",
  "content_type": "text",
  "content": "\"\"\"\nDatabase configuration for the HyperCode research module.\n\nThis module defines a SQLAlchemy engine and session factory\nused throughout the research layer.  The database URL is read\nfrom the ``RESEARCH_DATABASE_URL`` environment variable.  If\nunset, a local SQLite database will be used as a sensible\ndefault so that the schema can be inspected without additional\nconfiguration.\n\nExample usage:\n\n    from hypercode.backend.research import Base, SessionLocal\n    from hypercode.backend.research.models import Study\n\n    # create all tables\n    Base.metadata.create_all(bind=engine)\n\n    # open a session and use the ORM\n    db = SessionLocal()\n    try:\n        study = Study(slug=\"example\", title=\"Example Study\")\n        db.add(study)\n        db.commit()\n    finally:\n        db.close()\n\n\"\"\"\n\nimport os\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import declarative_base, sessionmaker\n\n\ndef _get_database_url() -> str:\n    \"\"\"Return the database URL to connect to.\n\n    Checks the ``RESEARCH_DATABASE_URL`` environment variable first.  If\n    it isn't defined then falls back to a local SQLite file so that\n    development and testing can proceed without a PostgreSQL server.\n    \"\"\"\n\n    url = os.getenv(\"RESEARCH_DATABASE_URL\")\n    if url:\n        return url\n    # fallback to a local SQLite database in the project root\n    # note: relative paths in SQLite URLs are resolved relative to the\n    # current working directory.  A persistent file makes it easier to\n    # inspect the database from outside of the application.\n    return \"sqlite:///hypercode_research.db\"\n\n\n# Create the SQLAlchemy engine.  ``future=True`` enables SQLAlchemy 2.0\n# style usage (optional, but recommended).  We disable\n# ``check_same_thread`` on SQLite to allow connections to be shared\n# across threads when using the fallback database.\nDATABASE_URL = _get_database_url()\nif DATABASE_URL.startswith(\"sqlite\"):\n    engine = create_engine(\n        DATABASE_URL, connect_args={\"check_same_thread\": False}, future=True\n    )\nelse:\n    engine = create_engine(DATABASE_URL, future=True)\n\n\n# sessionmaker returns a factory which will produce new Session objects\n# configured with our engine.  These sessions are not automatically\n# committed or flushed; callers must commit when appropriate.\nSessionLocal = sessionmaker(\n    autocommit=False,\n    autoflush=False,\n    bind=engine,\n)\n\n\n# Base class for declarative models.\nBase = declarative_base()\n",
  "metadata": {},
  "relative_path": "hypercode\\new files to check\\backend\\research\\db.py",
  "id": "7e40a58e57dd7a37c27c1d860a050a26"
}