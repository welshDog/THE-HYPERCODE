{
  "file_name": "__init__.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\venv_new\\Lib\\site-packages\\pip\\_vendor\\pkg_resources\\__init__.py",
  "file_size": 124463,
  "created": "2025-12-01T01:58:32.351455",
  "modified": "2025-12-01T01:58:32.358972",
  "file_type": "code",
  "content_hash": "78685324c0fa6754b0d9fef573660997",
  "content_type": "text",
  "content": "# TODO: Add Generic type annotations to initialized collections.\n# For now we'd simply use implicit Any/Unknown which would add redundant annotations\n# mypy: disable-error-code=\"var-annotated\"\n\"\"\"\nPackage resource API\n--------------------\n\nA resource is a logical file contained within a package, or a logical\nsubdirectory thereof.  The package resource API expects resource names\nto have their path parts separated with ``/``, *not* whatever the local\npath separator is.  Do not use os.path operations to manipulate resource\nnames being passed into the API.\n\nThe package resource API is designed to work with normal filesystem packages,\n.egg files, and unpacked .egg files.  It can also work in a limited way with\n.zip files and with custom PEP 302 loaders that support the ``get_data()``\nmethod.\n\nThis module is deprecated. Users are directed to :mod:`importlib.resources`,\n:mod:`importlib.metadata` and :pypi:`packaging` instead.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\n\nif sys.version_info < (3, 8):  # noqa: UP036 # Check for unsupported versions\n    raise RuntimeError(\"Python 3.8 or later is required\")\n\nimport os\nimport io\nimport time\nimport re\nimport types\nfrom typing import (\n    Any,\n    Literal,\n    Dict,\n    Iterator,\n    Mapping,\n    MutableSequence,\n    NamedTuple,\n    NoReturn,\n    Tuple,\n    Union,\n    TYPE_CHECKING,\n    Protocol,\n    Callable,\n    Iterable,\n    TypeVar,\n    overload,\n)\nimport zipfile\nimport zipimport\nimport warnings\nimport stat\nimport functools\nimport pkgutil\nimport operator\nimport platform\nimport collections\nimport plistlib\nimport email.parser\nimport errno\nimport tempfile\nimport textwrap\nimport inspect\nimport ntpath\nimport posixpath\nimport importlib\nimport importlib.abc\nimport importlib.machinery\nfrom pkgutil import get_importer\n\nimport _imp\n\n# capture these to bypass sandboxing\nfrom os import utime\nfrom os import open as os_open\nfrom os.path import isdir, split\n\ntry:\n    from os import mkdir, rename, unlink\n\n    WRITE_SUPPORT = True\nexcept ImportError:\n    # no write support, probably under GAE\n    WRITE_SUPPORT = False\n\nfrom pip._internal.utils._jaraco_text import (\n    yield_lines,\n    drop_comment,\n    join_continuation,\n)\nfrom pip._vendor.packaging import markers as _packaging_markers\nfrom pip._vendor.packaging import requirements as _packaging_requirements\nfrom pip._vendor.packaging import utils as _packaging_utils\nfrom pip._vendor.packaging import version as _packaging_version\nfrom pip._vendor.platformdirs import user_cache_dir as _user_cache_dir\n\nif TYPE_CHECKING:\n    from _typeshed import BytesPath, StrPath, StrOrBytesPath\n    from pip._vendor.typing_extensions import Self\n\n\n# Patch: Remove deprecation warning from vendored pkg_resources.\n# Setting PYTHONWARNINGS=error to verify builds produce no warnings\n# causes immediate exceptions.\n# See https://github.com/pypa/pip/issues/12243\n\n\n_T = TypeVar(\"_T\")\n_DistributionT = TypeVar(\"_DistributionT\", bound=\"Distribution\")\n# Type aliases\n_NestedStr = Union[str, Iterable[Union[str, Iterable[\"_NestedStr\"]]]]\n_InstallerTypeT = Callable[[\"Requirement\"], \"_DistributionT\"]\n_InstallerType = Callable[[\"Requirement\"], Union[\"Distribution\", None]]\n_PkgReqType = Union[str, \"Requirement\"]\n_EPDistType = Union[\"Distribution\", _PkgReqType]\n_MetadataType = Union[\"IResourceProvider\", None]\n_ResolvedEntryPoint = Any  # Can be any attribute in the module\n_ResourceStream = Any  # TODO / Incomplete: A readable file-like object\n# Any object works, but let's indicate we expect something like a module (optionally has __loader__ or __file__)\n_ModuleLike = Union[object, types.ModuleType]\n# Any: Should be _ModuleLike but we end up with issues where _ModuleLike doesn't have _ZipLoaderModule's __loader__\n_ProviderFactoryType = Callable[[Any], \"IResourceProvider\"]\n_DistFinderType = Callable[[_T, str, bool], Iterable[\"Distribution\"]]\n_NSHandlerType = Callable[[_T, str, str, types.ModuleType], Union[str, None]]\n_AdapterT = TypeVar(\n    \"_AdapterT\", _DistFinderType[Any], _ProviderFactoryType, _NSHandlerType[Any]\n)\n\n\n# Use _typeshed.importlib.LoaderProtocol once available https://github.com/python/typeshed/pull/11890\nclass _LoaderProtocol(Protocol):\n    def load_module(self, fullname: str, /) -> types.ModuleType: ...\n\n\nclass _ZipLoaderModule(Protocol):\n    __loader__: zipimport.zipimporter\n\n\n_PEP440_FALLBACK = re.compile(r\"^v?(?P<safe>(?:[0-9]+!)?[0-9]+(?:\\.[0-9]+)*)\", re.I)\n\n\nclass PEP440Warning(RuntimeWarning):\n    \"\"\"\n    Used when there is an issue with a version or specifier not complying with\n    PEP 440.\n    \"\"\"\n\n\nparse_version = _packaging_version.Version\n\n\n_state_vars: dict[str, str] = {}\n\n\ndef _declare_state(vartype: str, varname: str, initial_value: _T) -> _T:\n    _state_vars[varname] = vartype\n    return initial_value\n\n\ndef __getstate__() -> dict[str, Any]:\n    state = {}\n    g = globals()\n    for k, v in _state_vars.items():\n        state[k] = g['_sget_' + v](g[k])\n    return state\n\n\ndef __setstate__(state: dict[str, Any]) -> dict[str, Any]:\n    g = globals()\n    for k, v in state.items():\n        g['_sset_' + _state_vars[k]](k, g[k], v)\n    return state\n\n\ndef _sget_dict(val):\n    return val.copy()\n\n\ndef _sset_dict(key, ob, state):\n    ob.clear()\n    ob.update(state)\n\n\ndef _sget_object(val):\n    return val.__getstate__()\n\n\ndef _sset_object(key, ob, state):\n    ob.__setstate__(state)\n\n\n_sget_none = _sset_none = lambda *args: None\n\n\ndef get_supported_platform():\n    \"\"\"Return this platform's maximum compatible version.\n\n    distutils.util.get_platform() normally reports the minimum version\n    of macOS that would be required to *use* extensions produced by\n    distutils.  But what we want when checking compatibility is to know the\n    version of macOS that we are *running*.  To allow usage of packages that\n    explicitly require a newer version of macOS, we must also know the\n    current version of the OS.\n\n    If this condition occurs for any other platform with a version in its\n    platform strings, this function should be extended accordingly.\n    \"\"\"\n    plat = get_build_platform()\n    m = macosVersionString.match(plat)\n    if m is not None and sys.platform == \"darwin\":\n        try:\n            plat = 'macosx-%s-%s' % ('.'.join(_macos_vers()[:2]), m.group(3))\n        except ValueError:\n            # not macOS\n            pass\n    return plat\n\n\n__all__ = [\n    # Basic resource access and distribution/entry point discovery\n    'require',\n    'run_script',\n    'get_provider',\n    'get_distribution',\n    'load_entry_point',\n    'get_entry_map',\n    'get_entry_info',\n    'iter_entry_points',\n    'resource_string',\n    'resource_stream',\n    'resource_filename',\n    'resource_listdir',\n    'resource_exists',\n    'resource_isdir',\n    # Environmental control\n    'declare_namespace',\n    'working_set',\n    'add_activation_listener',\n    'find_distributions',\n    'set_extraction_path',\n    'cleanup_resources',\n    'get_default_cache',\n    # Primary implementation classes\n    'Environment',\n    'WorkingSet',\n    'ResourceManager',\n    'Distribution',\n    'Requirement',\n    'EntryPoint',\n    # Exceptions\n    'ResolutionError',\n    'VersionConflict',\n    'DistributionNotFound',\n    'UnknownExtra',\n    'ExtractionError',\n    # Warnings\n    'PEP440Warning',\n    # Parsing functions and string utilities\n    'parse_requirements',\n    'parse_version',\n    'safe_name',\n    'safe_version',\n    'get_platform',\n    'compatible_platforms',\n    'yield_lines',\n    'split_sections',\n    'safe_extra',\n    'to_filename',\n    'invalid_marker',\n    'evaluate_marker',\n    # filesystem utilities\n    'ensure_directory',\n    'normalize_path',\n    # Distribution \"precedence\" constants\n    'EGG_DIST',\n    'BINARY_DIST',\n    'SOURCE_DIST',\n    'CHECKOUT_DIST',\n    'DEVELOP_DIST',\n    # \"Provider\" interfaces, implementations, and registration/lookup APIs\n    'IMetadataProvider',\n    'IResourceProvider',\n    'FileMetadata',\n    'PathMetadata',\n    'EggMetadata',\n    'EmptyProvider',\n    'empty_provider',\n    'NullProvider',\n    'EggProvider',\n    'DefaultProvider',\n    'ZipProvider',\n    'register_finder',\n    'register_namespace_handler',\n    'register_loader_type',\n    'fixup_namespace_packages',\n    'get_importer',\n    # Warnings\n    'PkgResourcesDeprecationWarning',\n    # Deprecated/backward compatibility only\n    'run_main',\n    'AvailableDistributions',\n]\n\n\nclass ResolutionError(Exception):\n    \"\"\"Abstract base for dependency resolution errors\"\"\"\n\n    def __repr__(self):\n        return self.__class__.__name__ + repr(self.args)\n\n\nclass VersionConflict(ResolutionError):\n    \"\"\"\n    An already-installed version conflicts with the requested version.\n\n    Should be initialized with the installed Distribution and the requested\n    Requirement.\n    \"\"\"\n\n    _template = \"{self.dist} is installed but {self.req} is required\"\n\n    @property\n    def dist(self) -> Distribution:\n        return self.args[0]\n\n    @property\n    def req(self) -> Requirement:\n        return self.args[1]\n\n    def report(self):\n        return self._template.format(**locals())\n\n    def with_context(self, required_by: set[Distribution | str]):\n        \"\"\"\n        If required_by is non-empty, return a version of self that is a\n        ContextualVersionConflict.\n        \"\"\"\n        if not required_by:\n            return self\n        args = self.args + (required_by,)\n        return ContextualVersionConflict(*args)\n\n\nclass ContextualVersionConflict(VersionConflict):\n    \"\"\"\n    A VersionConflict that accepts a third parameter, the set of the\n    requirements that required the installed Distribution.\n    \"\"\"\n\n    _template = VersionConflict._template + ' by {self.required_by}'\n\n    @property\n    def required_by(self) -> set[str]:\n        return self.args[2]\n\n\nclass DistributionNotFound(ResolutionError):\n    \"\"\"A requested distribution was not found\"\"\"\n\n    _template = (\n        \"The '{self.req}' distribution was not found \"\n        \"and is required by {self.requirers_str}\"\n    )\n\n    @property\n    def req(self) -> Requirement:\n        return self.args[0]\n\n    @property\n    def requirers(self) -> set[str] | None:\n        return self.args[1]\n\n    @property\n    def requirers_str(self):\n        if not self.requirers:\n            return 'the application'\n        return ', '.join(self.requirers)\n\n    def report(self):\n        return self._template.format(**locals())\n\n    def __str__(self):\n        return self.report()\n\n\nclass UnknownExtra(ResolutionError):\n    \"\"\"Distribution doesn't have an \"extra feature\" of the given name\"\"\"\n\n\n_provider_factories: dict[type[_ModuleLike], _ProviderFactoryType] = {}\n\nPY_MAJOR = '{}.{}'.format(*sys.version_info)\nEGG_DIST = 3\nBINARY_DIST = 2\nSOURCE_DIST = 1\nCHECKOUT_DIST = 0\nDEVELOP_DIST = -1\n\n\ndef register_loader_type(\n    loader_type: type[_ModuleLike], provider_factory: _ProviderFactoryType\n):\n    \"\"\"Register `provider_factory` to make providers for `loader_type`\n\n    `loader_type` is the type or class of a PEP 302 ``module.__loader__``,\n    and `provider_factory` is a function that, passed a *module* object,\n    returns an ``IResourceProvider`` for that module.\n    \"\"\"\n    _provider_factories[loader_type] = provider_factory\n\n\n@overload\ndef get_provider(moduleOrReq: str) -> IResourceProvider: ...\n@overload\ndef get_provider(moduleOrReq: Requirement) -> Distribution: ...\ndef get_provider(moduleOrReq: str | Requirement) -> IResourceProvider | Distribution:\n    \"\"\"Return an IResourceProvider for the named module or requirement\"\"\"\n    if isinstance(moduleOrReq, Requirement):\n        return working_set.find(moduleOrReq) or require(str(moduleOrReq))[0]\n    try:\n        module = sys.modules[moduleOrReq]\n    except KeyError:\n        __import__(moduleOrReq)\n        module = sys.modules[moduleOrReq]\n    loader = getattr(module, '__loader__', None)\n    return _find_adapter(_provider_factories, loader)(module)\n\n\n@functools.lru_cache(maxsize=None)\ndef _macos_vers():\n    version = platform.mac_ver()[0]\n    # fallback for MacPorts\n    if version == '':\n        plist = '/System/Library/CoreServices/SystemVersion.plist'\n        if os.path.exists(plist):\n            with open(plist, 'rb') as fh:\n                plist_content = plistlib.load(fh)\n            if 'ProductVersion' in plist_content:\n                version = plist_content['ProductVersion']\n    return version.split('.')\n\n\ndef _macos_arch(machine):\n    return {'PowerPC': 'ppc', 'Power_Macintosh': 'ppc'}.get(machine, machine)\n\n\ndef get_build_platform():\n    \"\"\"Return this platform's string for platform-specific distributions\n\n    XXX Currently this is the same as ``distutils.util.get_platform()``, but it\n    needs some hacks for Linux and macOS.\n    \"\"\"\n    from sysconfig import get_platform\n\n    plat = get_platform()\n    if sys.platform == \"darwin\" and not plat.startswith('macosx-'):\n        try:\n            version = _macos_vers()\n            machine = os.uname()[4].replace(\" \", \"_\")\n            return \"macosx-%d.%d-%s\" % (\n                int(version[0]),\n                int(version[1]),\n                _macos_arch(machine),\n            )\n        except ValueError:\n            # if someone is running a non-Mac darwin system, this will fall\n            # through to the default implementation\n            pass\n    return plat\n\n\nmacosVersionString = re.compile(r\"macosx-(\\d+)\\.(\\d+)-(.*)\")\ndarwinVersionString = re.compile(r\"darwin-(\\d+)\\.(\\d+)\\.(\\d+)-(.*)\")\n# XXX backward compat\nget_platform = get_build_platform\n\n\ndef compatible_platforms(provided: str | None, required: str | None):\n    \"\"\"Can code for the `provided` platform run on the `required` platform?\n\n    Returns true if either platform is ``None``, or the platforms are equal.\n\n    XXX Needs compatibility checks for Linux and other unixy OSes.\n    \"\"\"\n    if provided is None or required is None or provided == required:\n        # easy case\n        return True\n\n    # macOS special cases\n    reqMac = macosVersionString.match(required)\n    if reqMac:\n        provMac = macosVersionString.match(provided)\n\n        # is this a Mac package?\n        if not provMac:\n            # this is backwards compatibility for packages built before\n            # setuptools 0.6. All packages built after this point will\n            # use the new macOS designation.\n            provDarwin = darwinVersionString.match(provided)\n            if provDarwin:\n                dversion = int(provDarwin.group(1))\n                macosversion = \"%s.%s\" % (reqMac.group(1), reqMac.group(2))\n                if (\n                    dversion == 7\n                    and macosversion >= \"10.3\"\n                    or dversion == 8\n                    and macosversion >= \"10.4\"\n                ):\n                    return True\n            # egg isn't macOS or legacy darwin\n            return False\n\n        # are they the same major version and machine type?\n        if provMac.group(1) != reqMac.group(1) or provMac.group(3) != reqMac.group(3):\n            return False\n\n        # is the required OS major update >= the provided one?\n        if int(provMac.group(2)) > int(reqMac.group(2)):\n            return False\n\n        return True\n\n    # XXX Linux and other platforms' special cases should go here\n    return False\n\n\n@overload\ndef get_distribution(dist: _DistributionT) -> _DistributionT: ...\n@overload\ndef get_distribution(dist: _PkgReqType) -> Distribution: ...\ndef get_distribution(dist: Distribution | _PkgReqType) -> Distribution:\n    \"\"\"Return a current distribution object for a Requirement or string\"\"\"\n    if isinstance(dist, str):\n        dist = Requirement.parse(dist)\n    if isinstance(dist, Requirement):\n        # Bad type narrowing, dist has to be a Requirement here, so get_provider has to return Distribution\n        dist = get_provider(dist)  # type: ignore[assignment]\n    if not isinstance(dist, Distribution):\n        raise TypeError(\"Expected str, Requirement, or Distribution\", dist)\n    return dist\n\n\ndef load_entry_point(dist: _EPDistType, group: str, name: str) -> _ResolvedEntryPoint:\n    \"\"\"Return `name` entry point of `group` for `dist` or raise ImportError\"\"\"\n    return get_distribution(dist).load_entry_point(group, name)\n\n\n@overload\ndef get_entry_map(\n    dist: _EPDistType, group: None = None\n) -> dict[str, dict[str, EntryPoint]]: ...\n@overload\ndef get_entry_map(dist: _EPDistType, group: str) -> dict[str, EntryPoint]: ...\ndef get_entry_map(dist: _EPDistType, group: str | None = None):\n    \"\"\"Return the entry point map for `group`, or the full entry map\"\"\"\n    return get_distribution(dist).get_entry_map(group)\n\n\ndef get_entry_info(dist: _EPDistType, group: str, name: str):\n    \"\"\"Return the EntryPoint object for `group`+`name`, or ``None``\"\"\"\n    return get_distribution(dist).get_entry_info(group, name)\n\n\nclass IMetadataProvider(Protocol):\n    def has_metadata(self, name: str) -> bool:\n        \"\"\"Does the package's distribution contain the named metadata?\"\"\"\n\n    def get_metadata(self, name: str) -> str:\n        \"\"\"The named metadata resource as a string\"\"\"\n\n    def get_metadata_lines(self, name: str) -> Iterator[str]:\n        \"\"\"Yield named metadata resource as list of non-blank non-comment lines\n\n        Leading and trailing whitespace is stripped from each line, and lines\n        with ``#`` as the first non-blank character are omitted.\"\"\"\n\n    def metadata_isdir(self, name: str) -> bool:\n        \"\"\"Is the named metadata a directory?  (like ``os.path.isdir()``)\"\"\"\n\n    def metadata_listdir(self, name: str) -> list[str]:\n        \"\"\"List of metadata names in the directory (like ``os.listdir()``)\"\"\"\n\n    def run_script(self, script_name: str, namespace: dict[str, Any]) -> None:\n        \"\"\"Execute the named script in the supplied namespace dictionary\"\"\"\n\n\nclass IResourceProvider(IMetadataProvider, Protocol):\n    \"\"\"An object that provides access to package resources\"\"\"\n\n    def get_resource_filename(\n        self, manager: ResourceManager, resource_name: str\n    ) -> str:\n        \"\"\"Return a true filesystem path for `resource_name`\n\n        `manager` must be a ``ResourceManager``\"\"\"\n\n    def get_resource_stream(\n        self, manager: ResourceManager, resource_name: str\n    ) -> _ResourceStream:\n        \"\"\"Return a readable file-like object for `resource_name`\n\n        `manager` must be a ``ResourceManager``\"\"\"\n\n    def get_resource_string(\n        self, manager: ResourceManager, resource_name: str\n    ) -> bytes:\n        \"\"\"Return the contents of `resource_name` as :obj:`bytes`\n\n        `manager` must be a ``ResourceManager``\"\"\"\n\n    def has_resource(self, resource_name: str) -> bool:\n        \"\"\"Does the package contain the named resource?\"\"\"\n\n    def resource_isdir(self, resource_name: str) -> bool:\n        \"\"\"Is the named resource a directory?  (like ``os.path.isdir()``)\"\"\"\n\n    def resource_listdir(self, resource_name: str) -> list[str]:\n        \"\"\"List of resource names in the directory (like ``os.listdir()``)\"\"\"\n\n\nclass WorkingSet:\n    \"\"\"A collection of active distributions on sys.path (or a similar list)\"\"\"\n\n    def __init__(self, entries: Iterable[str] | None = None):\n        \"\"\"Create working set from list of path entries (default=sys.path)\"\"\"\n        self.entries: list[str] = []\n        self.entry_keys = {}\n        self.by_key = {}\n        self.normalized_to_canonical_keys = {}\n        self.callbacks = []\n\n        if entries is None:\n            entries = sys.path\n\n        for entry in entries:\n            self.add_entry(entry)\n\n    @classmethod\n    def _build_master(cls):\n        \"\"\"\n        Prepare the master working set.\n        \"\"\"\n        ws = cls()\n        try:\n            from __main__ import __requires__\n        except ImportError:\n            # The main program does not list any requirements\n            return ws\n\n        # ensure the requirements are met\n        try:\n            ws.require(__requires__)\n        except VersionConflict:\n            return cls._build_from_requirements(__requires__)\n\n        return ws\n\n    @classmethod\n    def _build_from_requirements(cls, req_spec):\n        \"\"\"\n        Build a working set from a requirement spec. Rewrites sys.path.\n        \"\"\"\n        # try it without defaults already on sys.path\n        # by starting with an empty path\n        ws = cls([])\n        reqs = parse_requirements(req_spec)\n        dists = ws.resolve(reqs, Environment())\n        for dist in dists:\n            ws.add(dist)\n\n        # add any missing entries from sys.path\n        for entry in sys.path:\n            if entry not in ws.entries:\n                ws.add_entry(entry)\n\n        # then copy back to sys.path\n        sys.path[:] = ws.entries\n        return ws\n\n    def add_entry(self, entry: str):\n        \"\"\"Add a path item to ``.entries``, finding any distributions on it\n\n        ``find_distributions(entry, True)`` is used to find distributions\n        corresponding to the path entry, and they are added.  `entry` is\n        always appended to ``.entries``, even if it is already present.\n        (This is because ``sys.path`` can contain the same value more than\n        once, and the ``.entries`` of the ``sys.path`` WorkingSet should always\n        equal ``sys.path``.)\n        \"\"\"\n        self.entry_keys.setdefault(entry, [])\n        self.entries.append(entry)\n        for dist in find_distributions(entry, True):\n            self.add(dist, entry, False)\n\n    def __contains__(self, dist: Distribution) -> bool:\n        \"\"\"True if `dist` is the active distribution for its project\"\"\"\n        return self.by_key.get(dist.key) == dist\n\n    def find(self, req: Requirement) -> Distribution | None:\n        \"\"\"Find a distribution matching requirement `req`\n\n        If there is an active distribution for the requested project, this\n        returns it as long as it meets the version requirement specified by\n        `req`.  But, if there is an active distribution for the project and it\n        does *not* meet the `req` requirement, ``VersionConflict`` is raised.\n        If there is no active distribution for the requested project, ``None``\n        is returned.\n        \"\"\"\n        dist = self.by_key.get(req.key)\n\n        if dist is None:\n            canonical_key = self.normalized_to_canonical_keys.get(req.key)\n\n            if canonical_key is not None:\n                req.key = canonical_key\n                dist = self.by_key.get(canonical_key)\n\n        if dist is not None and dist not in req:\n            # XXX add more info\n            raise VersionConflict(dist, req)\n        return dist\n\n    def iter_entry_points(self, group: str, name: str | None = None):\n        \"\"\"Yield entry point objects from `group` matching `name`\n\n        If `name` is None, yields all entry points in `group` from all\n        distributions in the working set, otherwise only ones matching\n        both `group` and `name` are yielded (in distribution order).\n        \"\"\"\n        return (\n            entry\n            for dist in self\n            for entry in dist.get_entry_map(group).values()\n            if name is None or name == entry.name\n        )\n\n    def run_script(self, requires: str, script_name: str):\n        \"\"\"Locate distribution for `requires` and run `script_name` script\"\"\"\n        ns = sys._getframe(1).f_globals\n        name = ns['__name__']\n        ns.clear()\n        ns['__name__'] = name\n        self.require(requires)[0].run_script(script_name, ns)\n\n    def __iter__(self) -> Iterator[Distribution]:\n        \"\"\"Yield distributions for non-duplicate projects in the working set\n\n        The yield order is the order in which the items' path entries were\n        added to the working set.\n        \"\"\"\n        seen = set()\n        for item in self.entries:\n            if item not in self.entry_keys:\n                # workaround a cache issue\n                continue\n\n            for key in self.entry_keys[item]:\n                if key not in seen:\n                    seen.add(key)\n                    yield self.by_key[key]\n\n    def add(\n        self,\n        dist: Distribution,\n        entry: str | None = None,\n        insert: bool = True,\n        replace: bool = False,\n    ):\n        \"\"\"Add `dist` to working set, associated with `entry`\n\n        If `entry` is unspecified, it defaults to the ``.location`` of `dist`.\n        On exit from this routine, `entry` is added to the end of the working\n        set's ``.entries`` (if it wasn't already present).\n\n        `dist` is only added to the working set if it's for a project that\n        doesn't already have a distribution in the set, unless `replace=True`.\n        If it's added, any callbacks registered with the ``subscribe()`` method\n        will be called.\n        \"\"\"\n        if insert:\n            dist.insert_on(self.entries, entry, replace=replace)\n\n        if entry is None:\n            entry = dist.location\n        keys = self.entry_keys.setdefault(entry, [])\n        keys2 = self.entry_keys.setdefault(dist.location, [])\n        if not replace and dist.key in self.by_key:\n            # ignore hidden distros\n            return\n\n        self.by_key[dist.key] = dist\n        normalized_name = _packaging_utils.canonicalize_name(dist.key)\n        self.normalized_to_canonical_keys[normalized_name] = dist.key\n        if dist.key not in keys:\n            keys.append(dist.key)\n        if dist.key not in keys2:\n            keys2.append(dist.key)\n        self._added_new(dist)\n\n    @overload\n    def resolve(\n        self,\n        requirements: Iterable[Requirement],\n        env: Environment | None,\n        installer: _InstallerTypeT[_DistributionT],\n        replace_conflicting: bool = False,\n        extras: tuple[str, ...] | None = None,\n    ) -> list[_DistributionT]: ...\n    @overload\n    def resolve(\n        self,\n        requirements: Iterable[Requirement],\n        env: Environment | None = None,\n        *,\n        installer: _InstallerTypeT[_DistributionT],\n        replace_conflicting: bool = False,\n        extras: tuple[str, ...] | None = None,\n    ) -> list[_DistributionT]: ...\n    @overload\n    def resolve(\n        self,\n        requirements: Iterable[Requirement],\n        env: Environment | None = None,\n        installer: _InstallerType | None = None,\n        replace_conflicting: bool = False,\n        extras: tuple[str, ...] | None = None,\n    ) -> list[Distribution]: ...\n    def resolve(\n        self,\n        requirements: Iterable[Requirement],\n        env: Environment | None = None,\n        installer: _InstallerType | None | _InstallerTypeT[_DistributionT] = None,\n        replace_conflicting: bool = False,\n        extras: tuple[str, ...] | None = None,\n    ) -> list[Distribution] | list[_DistributionT]:\n        \"\"\"List all distributions needed to (recursively) meet `requirements`\n\n        `requirements` must be a sequence of ``Requirement`` objects.  `env`,\n        if supplied, should be an ``Environment`` instance.  If\n        not supplied, it defaults to all distributions available within any\n        entry or distribution in the working set.  `installer`, if supplied,\n        will be invoked with each requirement that cannot be met by an\n        already-installed distribution; it should return a ``Distribution`` or\n        ``None``.\n\n        Unless `replace_conflicting=True`, raises a VersionConflict exception\n        if\n        any requirements are found on the path that have the correct name but\n        the wrong version.  Otherwise, if an `installer` is supplied it will be\n        invoked to obtain the correct version of the requirement and activate\n        it.\n\n        `extras` is a list of the extras to be used with these requirements.\n        This is important because extra requirements may look like `my_req;\n        extra = \"my_extra\"`, which would otherwise be interpreted as a purely\n        optional requirement.  Instead, we want to be able to assert that these\n        requirements are truly required.\n        \"\"\"\n\n        # set up the stack\n        requirements = list(requirements)[::-1]\n        # set of processed requirements\n        processed = set()\n        # key -> dist\n        best = {}\n        to_activate = []\n\n        req_extras = _ReqExtras()\n\n        # Mapping of requirement to set of distributions that required it;\n        # useful for reporting info about conflicts.\n        required_by = collections.defaultdict(set)\n\n        while requirements:\n            # process dependencies breadth-first\n            req = requirements.pop(0)\n            if req in processed:\n                # Ignore cyclic or redundant dependencies\n                continue\n\n            if not req_extras.markers_pass(req, extras):\n                continue\n\n            dist = self._resolve_dist(\n                req, best, replace_conflicting, env, installer, required_by, to_activate\n            )\n\n            # push the new requirements onto the stack\n            new_requirements = dist.requires(req.extras)[::-1]\n            requirements.extend(new_requirements)\n\n            # Register the new requirements needed by req\n            for new_requirement in new_requirements:\n                required_by[new_requirement].add(req.project_name)\n                req_extras[new_requirement] = req.extras\n\n            processed.add(req)\n\n        # return list of distros to activate\n        return to_activate\n\n    def _resolve_dist(\n        self, req, best, replace_conflicting, env, installer, required_by, to_activate\n    ) -> Distribution:\n        dist = best.get(req.key)\n        if dist is None:\n            # Find the best distribution and add it to the map\n            dist = self.by_key.get(req.key)\n            if dist is None or (dist not in req and replace_conflicting):\n                ws = self\n                if env is None:\n                    if dist is None:\n                        env = Environment(self.entries)\n                    else:\n                        # Use an empty environment and workingset to avoid\n                        # any further conflicts with the conflicting\n                        # distribution\n                        env = Environment([])\n                        ws = WorkingSet([])\n                dist = best[req.key] = env.best_match(\n                    req, ws, installer, replace_conflicting=replace_conflicting\n                )\n                if dist is None:\n                    requirers = required_by.get(req, None)\n                    raise DistributionNotFound(req, requirers)\n            to_activate.append(dist)\n        if dist not in req:\n            # Oops, the \"best\" so far conflicts with a dependency\n            dependent_req = required_by[req]\n            raise VersionConflict(dist, req).with_context(dependent_req)\n        return dist\n\n    @overload\n    def find_plugins(\n        self,\n        plugin_env: Environment,\n        full_env: Environment | None,\n        installer: _InstallerTypeT[_DistributionT],\n        fallback: bool = True,\n    ) -> tuple[list[_DistributionT], dict[Distribution, Exception]]: ...\n    @overload\n    def find_plugins(\n        self,\n        plugin_env: Environment,\n        full_env: Environment | None = None,\n        *,\n        installer: _InstallerTypeT[_DistributionT],\n        fallback: bool = True,\n    ) -> tuple[list[_DistributionT], dict[Distribution, Exception]]: ...\n    @overload\n    def find_plugins(\n        self,\n        plugin_env: Environment,\n        full_env: Environment | None = None,\n        installer: _InstallerType | None = None,\n        fallback: bool = True,\n    ) -> tuple[list[Distribution], dict[Distribution, Exception]]: ...\n    def find_plugins(\n        self,\n        plugin_env: Environment,\n        full_env: Environment | None = None,\n        installer: _InstallerType | None | _InstallerTypeT[_DistributionT] = None,\n        fallback: bool = True,\n    ) -> tuple[\n        list[Distribution] | list[_DistributionT],\n        dict[Distribution, Exception],\n    ]:\n        \"\"\"Find all activatable distributions in `plugin_env`\n\n        Example usage::\n\n            distributions, errors = working_set.find_plugins(\n                Environment(plugin_dirlist)\n            )\n            # add plugins+libs to sys.path\n            map(working_set.add, distributions)\n            # display errors\n            print('Could not load', errors)\n\n        The `plugin_env` should be an ``Environment`` instance that contains\n        only distributions that are in the project's \"plugin directory\" or\n        directories. The `full_env`, if supplied, should be an ``Environment``\n        contains all currently-available distributions.  If `full_env` is not\n        supplied, one is created automatically from the ``WorkingSet`` this\n        method is called on, which will typically mean that every directory on\n        ``sys.path`` will be scanned for distributions.\n\n        `installer` is a standard installer callback as used by the\n        ``resolve()`` method. The `fallback` flag indicates whether we should\n        attempt to resolve older versions of a plugin if the newest version\n        cannot be resolved.\n\n        This method returns a 2-tuple: (`distributions`, `error_info`), where\n        `distributions` is a list of the distributions found in `plugin_env`\n        that were loadable, along with any other distributions that are needed\n        to resolve their dependencies.  `error_info` is a dictionary mapping\n        unloadable plugin distributions to an exception instance describing the\n        error that occurred. Usually this will be a ``DistributionNotFound`` or\n        ``VersionConflict`` instance.\n        \"\"\"\n\n        plugin_projects = list(plugin_env)\n        # scan project names in alphabetic order\n        plugin_projects.sort()\n\n        error_info: dict[Distribution, Exception] = {}\n        distributions: dict[Distribution, Exception | None] = {}\n\n        if full_env is None:\n            env = Environment(self.entries)\n            env += plugin_env\n        else:\n            env = full_env + plugin_env\n\n        shadow_set = self.__class__([])\n        # put all our entries in shadow_set\n        list(map(shadow_set.add, self))\n\n        for project_name in plugin_projects:\n            for dist in plugin_env[project_name]:\n                req = [dist.as_requirement()]\n\n                try:\n                    resolvees = shadow_set.resolve(req, env, installer)\n\n                except ResolutionError as v:\n                    # save error info\n                    error_info[dist] = v\n                    if fallback:\n                        # try the next older version of project\n                        continue\n                    else:\n                        # give up on this project, keep going\n                        break\n\n                else:\n                    list(map(shadow_set.add, resolvees))\n                    distributions.update(dict.fromkeys(resolvees))\n\n                    # success, no need to try any more versions of this project\n                    break\n\n        sorted_distributions = list(distributions)\n        sorted_distributions.sort()\n\n        return sorted_distributions, error_info\n\n    def require(self, *requirements: _NestedStr):\n        \"\"\"Ensure that distributions matching `requirements` are activated\n\n        `requirements` must be a string or a (possibly-nested) sequence\n        thereof, specifying the distributions and versions required.  The\n        return value is a sequence of the distributions that needed to be\n        activated to fulfill the requirements; all relevant distributions are\n        included, even if they were already activated in this working set.\n        \"\"\"\n        needed = self.resolve(parse_requirements(requirements))\n\n        for dist in needed:\n            self.add(dist)\n\n        return needed\n\n    def subscribe(\n        self, callback: Callable[[Distribution], object], existing: bool = True\n    ):\n        \"\"\"Invoke `callback` for all distributions\n\n        If `existing=True` (default),\n        call on all existing ones, as well.\n        \"\"\"\n        if callback in self.callbacks:\n            return\n        self.callbacks.append(callback)\n        if not existing:\n            return\n        for dist in self:\n            callback(dist)\n\n    def _added_new(self, dist):\n        for callback in self.callbacks:\n            callback(dist)\n\n    def __getstate__(self):\n        return (\n            self.entries[:],\n            self.entry_keys.copy(),\n            self.by_key.copy(),\n            self.normalized_to_canonical_keys.copy(),\n            self.callbacks[:],\n        )\n\n    def __setstate__(self, e_k_b_n_c):\n        entries, keys, by_key, normalized_to_canonical_keys, callbacks = e_k_b_n_c\n        self.entries = entries[:]\n        self.entry_keys = keys.copy()\n        self.by_key = by_key.copy()\n        self.normalized_to_canonical_keys = normalized_to_canonical_keys.copy()\n        self.callbacks = callbacks[:]\n\n\nclass _ReqExtras(Dict[\"Requirement\", Tuple[str, ...]]):\n    \"\"\"\n    Map each requirement to the extras that demanded it.\n    \"\"\"\n\n    def markers_pass(self, req: Requirement, extras: tuple[str, ...] | None = None):\n        \"\"\"\n        Evaluate markers for req against each extra that\n        demanded it.\n\n        Return False if the req has a marker and fails\n        evaluation. Otherwise, return True.\n        \"\"\"\n        extra_evals = (\n            req.marker.evaluate({'extra': extra})\n            for extra in self.get(req, ()) + (extras or (None,))\n        )\n        return not req.marker or any(extra_evals)\n\n\nclass Environment:\n    \"\"\"Searchable snapshot of distributions on a search path\"\"\"\n\n    def __init__(\n        self,\n        search_path: Iterable[str] | None = None,\n        platform: str | None = get_supported_platform(),\n        python: str | None = PY_MAJOR,\n    ):\n        \"\"\"Snapshot distributions available on a search path\n\n        Any distributions found on `search_path` are added to the environment.\n        `search_path` should be a sequence of ``sys.path`` items.  If not\n        supplied, ``sys.path`` is used.\n\n        `platform` is an optional string specifying the name of the platform\n        that platform-specific distributions must be compatible with.  If\n        unspecified, it defaults to the current platform.  `python` is an\n        optional string naming the desired version of Python (e.g. ``'3.6'``);\n        it defaults to the current version.\n\n        You may explicitly set `platform` (and/or `python`) to ``None`` if you\n        wish to map *all* distributions, not just those compatible with the\n        running platform or Python version.\n        \"\"\"\n        self._distmap = {}\n        self.platform = platform\n        self.python = python\n        self.scan(search_path)\n\n    def can_add(self, dist: Distribution):\n        \"\"\"Is distribution `dist` acceptable for this environment?\n\n        The distribution must match the platform and python version\n        requirements specified when this environment was created, or False\n        is returned.\n        \"\"\"\n        py_compat = (\n            self.python is None\n            or dist.py_version is None\n            or dist.py_version == self.python\n        )\n        return py_compat and compatible_platforms(dist.platform, self.platform)\n\n    def remove(self, dist: Distribution):\n        \"\"\"Remove `dist` from the environment\"\"\"\n        self._distmap[dist.key].remove(dist)\n\n    def scan(self, search_path: Iterable[str] | None = None):\n        \"\"\"Scan `search_path` for distributions usable in this environment\n\n        Any distributions found are added to the environment.\n        `search_path` should be a sequence of ``sys.path`` items.  If not\n        supplied, ``sys.path`` is used.  Only distributions conforming to\n        the platform/python version defined at initialization are added.\n        \"\"\"\n        if search_path is None:\n            search_path = sys.path\n\n        for item in search_path:\n            for dist in find_distributions(item):\n                self.add(dist)\n\n    def __getitem__(self, project_name: str) -> list[Distribution]:\n        \"\"\"Return a newest-to-oldest list of distributions for `project_name`\n\n        Uses case-insensitive `project_name` comparison, assuming all the\n        project's distributions use their project's name converted to all\n        lowercase as their key.\n\n        \"\"\"\n        distribution_key = project_name.lower()\n        return self._distmap.get(distribution_key, [])\n\n    def add(self, dist: Distribution):\n        \"\"\"Add `dist` if we ``can_add()`` it and it has not already been added\"\"\"\n        if self.can_add(dist) and dist.has_version():\n            dists = self._distmap.setdefault(dist.key, [])\n            if dist not in dists:\n                dists.append(dist)\n                dists.sort(key=operator.attrgetter('hashcmp'), reverse=True)\n\n    @overload\n    def best_match(\n        self,\n        req: Requirement,\n        working_set: WorkingSet,\n        installer: _InstallerTypeT[_DistributionT],\n        replace_conflicting: bool = False,\n    ) -> _DistributionT: ...\n    @overload\n    def best_match(\n        self,\n        req: Requirement,\n        working_set: WorkingSet,\n        installer: _InstallerType | None = None,\n        replace_conflicting: bool = False,\n    ) -> Distribution | None: ...\n    def best_match(\n        self,\n        req: Requirement,\n        working_set: WorkingSet,\n        installer: _InstallerType | None | _InstallerTypeT[_DistributionT] = None,\n        replace_conflicting: bool = False,\n    ) -> Distribution | None:\n        \"\"\"Find distribution best matching `req` and usable on `working_set`\n\n        This calls the ``find(req)`` method of the `working_set` to see if a\n        suitable distribution is already active.  (This may raise\n        ``VersionConflict`` if an unsuitable version of the project is already\n        active in the specified `working_set`.)  If a suitable distribution\n        isn't active, this method returns the newest distribution in the\n        environment that meets the ``Requirement`` in `req`.  If no suitable\n        distribution is found, and `installer` is supplied, then the result of\n        calling the environment's ``obtain(req, installer)`` method will be\n        returned.\n        \"\"\"\n        try:\n            dist = working_set.find(req)\n        except VersionConflict:\n            if not replace_conflicting:\n                raise\n            dist = None\n        if dist is not None:\n            return dist\n        for dist in self[req.key]:\n            if dist in req:\n                return dist\n        # try to download/install\n        return self.obtain(req, installer)\n\n    @overload\n    def obtain(\n        self,\n        requirement: Requirement,\n        installer: _InstallerTypeT[_DistributionT],\n    ) -> _DistributionT: ...\n    @overload\n    def obtain(\n        self,\n        requirement: Requirement,\n        installer: Callable[[Requirement], None] | None = None,\n    ) -> None: ...\n    @overload\n    def obtain(\n        self,\n        requirement: Requirement,\n        installer: _InstallerType | None = None,\n    ) -> Distribution | None: ...\n    def obtain(\n        self,\n        requirement: Requirement,\n        installer: Callable[[Requirement], None]\n        | _InstallerType\n        | None\n        | _InstallerTypeT[_DistributionT] = None,\n    ) -> Distribution | None:\n        \"\"\"Obtain a distribution matching `requirement` (e.g. via download)\n\n        Obtain a distro that matches requirement (e.g. via download).  In the\n        base ``Environment`` class, this routine just returns\n        ``installer(requirement)``, unless `installer` is None, in which case\n        None is returned instead.  This method is a hook that allows subclasses\n        to attempt other ways of obtaining a distribution before falling back\n        to the `installer` argument.\"\"\"\n        return installer(requirement) if installer else None\n\n    def __iter__(self) -> Iterator[str]:\n        \"\"\"Yield the unique project names of the available distributions\"\"\"\n        for key in self._distmap.keys():\n            if self[key]:\n                yield key\n\n    def __iadd__(self, other: Distribution | Environment):\n        \"\"\"In-place addition of a distribution or environment\"\"\"\n        if isinstance(other, Distribution):\n            self.add(other)\n        elif isinstance(other, Environment):\n            for project in other:\n                for dist in other[project]:\n                    self.add(dist)\n        else:\n            raise TypeError(\"Can't add %r to environment\" % (other,))\n        return self\n\n    def __add__(self, other: Distribution | Environment):\n        \"\"\"Add an environment or distribution to an environment\"\"\"\n        new = self.__class__([], platform=None, python=None)\n        for env in self, other:\n            new += env\n        return new\n\n\n# XXX backward compatibility\nAvailableDistributions = Environment\n\n\nclass ExtractionError(RuntimeError):\n    \"\"\"An error occurred extracting a resource\n\n    The following attributes are available from instances of this exception:\n\n    manager\n        The resource manager that raised this exception\n\n    cache_path\n        The base directory for resource extraction\n\n    original_error\n        The exception instance that caused extraction to fail\n    \"\"\"\n\n    manager: ResourceManager\n    cache_path: str\n    original_error: BaseException | None\n\n\nclass ResourceManager:\n    \"\"\"Manage resource extraction and packages\"\"\"\n\n    extraction_path: str | None = None\n\n    def __init__(self):\n        self.cached_files = {}\n\n    def resource_exists(self, package_or_requirement: _PkgReqType, resource_name: str):\n        \"\"\"Does the named resource exist?\"\"\"\n        return get_provider(package_or_requirement).has_resource(resource_name)\n\n    def resource_isdir(self, package_or_requirement: _PkgReqType, resource_name: str):\n        \"\"\"Is the named resource an existing directory?\"\"\"\n        return get_provider(package_or_requirement).resource_isdir(resource_name)\n\n    def resource_filename(\n        self, package_or_requirement: _PkgReqType, resource_name: str\n    ):\n        \"\"\"Return a true filesystem path for specified resource\"\"\"\n        return get_provider(package_or_requirement).get_resource_filename(\n            self, resource_name\n        )\n\n    def resource_stream(self, package_or_requirement: _PkgReqType, resource_name: str):\n        \"\"\"Return a readable file-like object for specified resource\"\"\"\n        return get_provider(package_or_requirement).get_resource_stream(\n            self, resource_name\n        )\n\n    def resource_string(\n        self, package_or_requirement: _PkgReqType, resource_name: str\n    ) -> bytes:\n        \"\"\"Return specified resource as :obj:`bytes`\"\"\"\n        return get_provider(package_or_requirement).get_resource_string(\n            self, resource_name\n        )\n\n    def resource_listdir(self, package_or_requirement: _PkgReqType, resource_name: str):\n        \"\"\"List the contents of the named resource directory\"\"\"\n        return get_provider(package_or_requirement).resource_listdir(resource_name)\n\n    def extraction_error(self) -> NoReturn:\n        \"\"\"Give an error message for problems extracting file(s)\"\"\"\n\n        old_exc = sys.exc_info()[1]\n        cache_path = self.extraction_path or get_default_cache()\n\n        tmpl = textwrap.dedent(\n            \"\"\"\n            Can't extract file(s) to egg cache\n\n            The following error occurred while trying to extract file(s)\n            to the Python egg cache:\n\n              {old_exc}\n\n            The Python egg cache directory is currently set to:\n\n              {cache_path}\n\n            Perhaps your account does not have write access to this directory?\n            You can change the cache directory by setting the PYTHON_EGG_CACHE\n            environment variable to point to an accessible directory.\n            \"\"\"\n        ).lstrip()\n        err = ExtractionError(tmpl.format(**locals()))\n        err.manager = self\n        err.cache_path = cache_path\n        err.original_error = old_exc\n        raise err\n\n    def get_cache_path(self, archive_name: str, names: Iterable[StrPath] = ()):\n        \"\"\"Return absolute location in cache for `archive_name` and `names`\n\n        The parent directory of the resulting path will be created if it does\n        not already exist.  `archive_name` should be the base filename of the\n        enclosing egg (which may not be the name of the enclosing zipfile!),\n        including its \".egg\" extension.  `names`, if provided, should be a\n        sequence of path name parts \"under\" the egg's extraction location.\n\n        This method should only be called by resource providers that need to\n        obtain an extraction location, and only for names they intend to\n        extract, as it tracks the generated names for possible cleanup later.\n        \"\"\"\n        extract_path = self.extraction_path or get_default_cache()\n        target_path = os.path.join(extract_path, archive_name + '-tmp', *names)\n        try:\n            _bypass_ensure_directory(target_path)\n        except Exception:\n            self.extraction_error()\n\n        self._warn_unsafe_extraction_path(extract_path)\n\n        self.cached_files[target_path] = True\n        return target_path\n\n    @staticmethod\n    def _warn_unsafe_extraction_path(path):\n        \"\"\"\n        If the default extraction path is overridden and set to an insecure\n        location, such as /tmp, it opens up an opportunity for an attacker to\n        replace an extracted file with an unauthorized payload. Warn the user\n        if a known insecure location is used.\n\n        See Distribute #375 for more details.\n        \"\"\"\n        if os.name == 'nt' and not path.startswith(os.environ['windir']):\n            # On Windows, permissions are generally restrictive by default\n            #  and temp directories are not writable by other users, so\n            #  bypass the warning.\n            return\n        mode = os.stat(path).st_mode\n        if mode & stat.S_IWOTH or mode & stat.S_IWGRP:\n            msg = (\n                \"Extraction path is writable by group/others \"\n                \"and vulnerable to attack when \"\n                \"used with get_resource_filename ({path}). \"\n                \"Consider a more secure \"\n                \"location (set with .set_extraction_path or the \"\n                \"PYTHON_EGG_CACHE environment variable).\"\n            ).format(**locals())\n            warnings.warn(msg, UserWarning)\n\n    def postprocess(self, tempname: StrOrBytesPath, filename: StrOrBytesPath):\n        \"\"\"Perform any platform-specific postprocessing of `tempname`\n\n        This is where Mac header rewrites should be done; other platforms don't\n        have anything special they should do.\n\n        Resource providers should call this method ONLY after successfully\n        extracting a compressed resource.  They must NOT call it on resources\n        that are already in the filesystem.\n\n        `tempname` is the current (temporary) name of the file, and `filename`\n        is the name it will be renamed to by the caller after this routine\n        returns.\n        \"\"\"\n\n        if os.name == 'posix':\n            # Make the resource executable\n            mode = ((os.stat(tempname).st_mode) | 0o555) & 0o7777\n            os.chmod(tempname, mode)\n\n    def set_extraction_path(self, path: str):\n        \"\"\"Set the base path where resources will be extracted to, if needed.\n\n        If you do not call this routine before any extractions take place, the\n        path defaults to the return value of ``get_default_cache()``.  (Which\n        is based on the ``PYTHON_EGG_CACHE`` environment variable, with various\n        platform-specific fallbacks.  See that routine's documentation for more\n        details.)\n\n        Resources are extracted to subdirectories of this path based upon\n        information given by the ``IResourceProvider``.  You may set this to a\n        temporary directory, but then you must call ``cleanup_resources()`` to\n        delete the extracted files when done.  There is no guarantee that\n        ``cleanup_resources()`` will be able to remove all extracted files.\n\n        (Note: you may not change the extraction path for a given resource\n        manager once resources have been extracted, unless you first call\n        ``cleanup_resources()``.)\n        \"\"\"\n        if self.cached_files:\n            raise ValueError(\"Can't change extraction path, files already extracted\")\n\n        self.extraction_path = path\n\n    def cleanup_resources(self, force: bool = False) -> list[str]:\n        \"\"\"\n        Delete all extracted resource files and directories, returning a list\n        of the file and directory names that could not be successfully removed.\n        This function does not have any concurrency protection, so it should\n        generally only be called when the extraction path is a temporary\n        directory exclusive to a single process.  This method is not\n        automatically called; you must call it explicitly or register it as an\n        ``atexit`` function if you wish to ensure cleanup of a temporary\n        directory used for extractions.\n        \"\"\"\n        # XXX\n        return []\n\n\ndef get_default_cache() -> str:\n    \"\"\"\n    Return the ``PYTHON_EGG_CACHE`` environment variable\n    or a platform-relevant user cache dir for an app\n    named \"Python-Eggs\".\n    \"\"\"\n    return os.environ.get('PYTHON_EGG_CACHE') or _user_cache_dir(appname='Python-Eggs')\n\n\ndef safe_name(name: str):\n    \"\"\"Convert an arbitrary string to a standard distribution name\n\n    Any runs of non-alphanumeric/. characters are replaced with a single '-'.\n    \"\"\"\n    return re.sub('[^A-Za-z0-9.]+', '-', name)\n\n\ndef safe_version(version: str):\n    \"\"\"\n    Convert an arbitrary string to a standard version string\n    \"\"\"\n    try:\n        # normalize the version\n        return str(_packaging_version.Version(version))\n    except _packaging_version.InvalidVersion:\n        version = version.replace(' ', '.')\n        return re.sub('[^A-Za-z0-9.]+', '-', version)\n\n\ndef _forgiving_version(version):\n    \"\"\"Fallback when ``safe_version`` is not safe enough\n    >>> parse_version(_forgiving_version('0.23ubuntu1'))\n    <Version('0.23.dev0+sanitized.ubuntu1')>\n    >>> parse_version(_forgiving_version('0.23-'))\n    <Version('0.23.dev0+sanitized')>\n    >>> parse_version(_forgiving_version('0.-_'))\n    <Version('0.dev0+sanitized')>\n    >>> parse_version(_forgiving_version('42.+?1'))\n    <Version('42.dev0+sanitized.1')>\n    >>> parse_version(_forgiving_version('hello world'))\n    <Version('0.dev0+sanitized.hello.world')>\n    \"\"\"\n    version = version.replace(' ', '.')\n    match = _PEP440_FALLBACK.search(version)\n    if match:\n        safe = match[\"safe\"]\n        rest = version[len(safe) :]\n    else:\n        safe = \"0\"\n        rest = version\n    local = f\"sanitized.{_safe_segment(rest)}\".strip(\".\")\n    return f\"{safe}.dev0+{local}\"\n\n\ndef _safe_segment(segment):\n    \"\"\"Convert an arbitrary string into a safe segment\"\"\"\n    segment = re.sub('[^A-Za-z0-9.]+', '-', segment)\n    segment = re.sub('-[^A-Za-z0-9]+', '-', segment)\n    return re.sub(r'\\.[^A-Za-z0-9]+', '.', segment).strip(\".-\")\n\n\ndef safe_extra(extra: str):\n    \"\"\"Convert an arbitrary string to a standard 'extra' name\n\n    Any runs of non-alphanumeric characters are replaced with a single '_',\n    and the result is always lowercased.\n    \"\"\"\n    return re.sub('[^A-Za-z0-9.-]+', '_', extra).lower()\n\n\ndef to_filename(name: str):\n    \"\"\"Convert a project or version name to its filename-escaped form\n\n    Any '-' characters are currently replaced with '_'.\n    \"\"\"\n    return name.replace('-', '_')\n\n\ndef invalid_marker(text: str):\n    \"\"\"\n    Validate text as a PEP 508 environment marker; return an exception\n    if invalid or False otherwise.\n    \"\"\"\n    try:\n        evaluate_marker(text)\n    except SyntaxError as e:\n        e.filename = None\n        e.lineno = None\n        return e\n    return False\n\n\ndef evaluate_marker(text: str, extra: str | None = None) -> bool:\n    \"\"\"\n    Evaluate a PEP 508 environment marker.\n    Return a boolean indicating the marker result in this environment.\n    Raise SyntaxError if marker is invalid.\n\n    This implementation uses the 'pyparsing' module.\n    \"\"\"\n    try:\n        marker = _packaging_markers.Marker(text)\n        return marker.evaluate()\n    except _packaging_markers.InvalidMarker as e:\n        raise SyntaxError(e) from e\n\n\nclass NullProvider:\n    \"\"\"Try to implement resources and metadata for arbitrary PEP 302 loaders\"\"\"\n\n    egg_name: str | None = None\n    egg_info: str | None = None\n    loader: _LoaderProtocol | None = None\n\n    def __init__(self, module: _ModuleLike):\n        self.loader = getattr(module, '__loader__', None)\n        self.module_path = os.path.dirname(getattr(module, '__file__', ''))\n\n    def get_resource_filename(self, manager: ResourceManager, resource_name: str):\n        return self._fn(self.module_path, resource_name)\n\n    def get_resource_stream(self, manager: ResourceManager, resource_name: str):\n        return io.BytesIO(self.get_resource_string(manager, resource_name))\n\n    def get_resource_string(\n        self, manager: ResourceManager, resource_name: str\n    ) -> bytes:\n        return self._get(self._fn(self.module_path, resource_name))\n\n    def has_resource(self, resource_name: str):\n        return self._has(self._fn(self.module_path, resource_name))\n\n    def _get_metadata_path(self, name):\n        return self._fn(self.egg_info, name)\n\n    def has_metadata(self, name: str) -> bool:\n        if not self.egg_info:\n            return False\n\n        path = self._get_metadata_path(name)\n        return self._has(path)\n\n    def get_metadata(self, name: str):\n        if not self.egg_info:\n            return \"\"\n        path = self._get_metadata_path(name)\n        value = self._get(path)\n        try:\n            return value.decode('utf-8')\n        except UnicodeDecodeError as exc:\n            # Include the path in the error message to simplify\n            # troubleshooting, and without changing the exception type.\n            exc.reason += ' in {} file at path: {}'.format(name, path)\n            raise\n\n    def get_metadata_lines(self, name: str) -> Iterator[str]:\n        return yield_lines(self.get_metadata(name))\n\n    def resource_isdir(self, resource_name: str):\n        return self._isdir(self._fn(self.module_path, resource_name))\n\n    def metadata_isdir(self, name: str) -> bool:\n        return bool(self.egg_info and self._isdir(self._fn(self.egg_info, name)))\n\n    def resource_listdir(self, resource_name: str):\n        return self._listdir(self._fn(self.module_path, resource_name))\n\n    def metadata_listdir(self, name: str) -> list[str]:\n        if self.egg_info:\n            return self._listdir(self._fn(self.egg_info, name))\n        return []\n\n    def run_script(self, script_name: str, namespace: dict[str, Any]):\n        script = 'scripts/' + script_name\n        if not self.has_metadata(script):\n            raise ResolutionError(\n                \"Script {script!r} not found in metadata at {self.egg_info!r}\".format(\n                    **locals()\n                ),\n            )\n\n        script_text = self.get_metadata(script).replace('\\r\\n', '\\n')\n        script_text = script_text.replace('\\r', '\\n')\n        script_filename = self._fn(self.egg_info, script)\n        namespace['__file__'] = script_filename\n        if os.path.exists(script_filename):\n            source = _read_utf8_with_fallback(script_filename)\n            code = compile(source, script_filename, 'exec')\n            exec(code, namespace, namespace)\n        else:\n            from linecache import cache\n\n            cache[script_filename] = (\n                len(script_text),\n                0,\n                script_text.split('\\n'),\n                script_filename,\n            )\n            script_code = compile(script_text, script_filename, 'exec')\n            exec(script_code, namespace, namespace)\n\n    def _has(self, path) -> bool:\n        raise NotImplementedError(\n            \"Can't perform this operation for unregistered loader type\"\n        )\n\n    def _isdir(self, path) -> bool:\n        raise NotImplementedError(\n            \"Can't perform this operation for unregistered loader type\"\n        )\n\n    def _listdir(self, path) -> list[str]:\n        raise NotImplementedError(\n            \"Can't perform this operation for unregistered loader type\"\n        )\n\n    def _fn(self, base: str | None, resource_name: str):\n        if base is None:\n            raise TypeError(\n                \"`base` parameter in `_fn` is `None`. Either override this method or check the parameter first.\"\n            )\n        self._validate_resource_path(resource_name)\n        if resource_name:\n            return os.path.join(base, *resource_name.split('/'))\n        return base\n\n    @staticmethod\n    def _validate_resource_path(path):\n        \"\"\"\n        Validate the resource paths according to the docs.\n        https://setuptools.pypa.io/en/latest/pkg_resources.html#basic-resource-access\n\n        >>> warned = getfixture('recwarn')\n        >>> warnings.simplefilter('always')\n        >>> vrp = NullProvider._validate_resource_path\n        >>> vrp('foo/bar.txt')\n        >>> bool(warned)\n        False\n        >>> vrp('../foo/bar.txt')\n        >>> bool(warned)\n        True\n        >>> warned.clear()\n        >>> vrp('/foo/bar.txt')\n        >>> bool(warned)\n        True\n        >>> vrp('foo/../../bar.txt')\n        >>> bool(warned)\n        True\n        >>> warned.clear()\n        >>> vrp('foo/f../bar.txt')\n        >>> bool(warned)\n        False\n\n        Windows path separators are straight-up disallowed.\n        >>> vrp(r'\\\\foo/bar.txt')\n        Traceback (most recent call last):\n        ...\n        ValueError: Use of .. or absolute path in a resource path \\\nis not allowed.\n\n        >>> vrp(r'C:\\\\foo/bar.txt')\n        Traceback (most recent call last):\n        ...\n        ValueError: Use of .. or absolute path in a resource path \\\nis not allowed.\n\n        Blank values are allowed\n\n        >>> vrp('')\n        >>> bool(warned)\n        False\n\n        Non-string values are not.\n\n        >>> vrp(None)\n        Traceback (most recent call last):\n        ...\n        AttributeError: ...\n        \"\"\"\n        invalid = (\n            os.path.pardir in path.split(posixpath.sep)\n            or posixpath.isabs(path)\n            or ntpath.isabs(path)\n            or path.startswith(\"\\\\\")\n        )\n        if not invalid:\n            return\n\n        msg = \"Use of .. or absolute path in a resource path is not allowed.\"\n\n        # Aggressively disallow Windows absolute paths\n        if (path.startswith(\"\\\\\") or ntpath.isabs(path)) and not posixpath.isabs(path):\n            raise ValueError(msg)\n\n        # for compatibility, warn; in future\n        # raise ValueError(msg)\n        issue_warning(\n            msg[:-1] + \" and will raise exceptions in a future release.\",\n            DeprecationWarning,\n        )\n\n    def _get(self, path) -> bytes:\n        if hasattr(self.loader, 'get_data') and self.loader:\n            # Already checked get_data exists\n            return self.loader.get_data(path)  # type: ignore[attr-defined]\n        raise NotImplementedError(\n            \"Can't perform this operation for loaders without 'get_data()'\"\n        )\n\n\nregister_loader_type(object, NullProvider)\n\n\ndef _parents(path):\n    \"\"\"\n    yield all parents of path including path\n    \"\"\"\n    last = None\n    while path != last:\n        yield path\n        last = path\n        path, _ = os.path.split(path)\n\n\nclass EggProvider(NullProvider):\n    \"\"\"Provider based on a virtual filesystem\"\"\"\n\n    def __init__(self, module: _ModuleLike):\n        super().__init__(module)\n        self._setup_prefix()\n\n    def _setup_prefix(self):\n        # Assume that metadata may be nested inside a \"basket\"\n        # of multiple eggs and use module_path instead of .archive.\n        eggs = filter(_is_egg_path, _parents(self.module_path))\n        egg = next(eggs, None)\n        egg and self._set_egg(egg)\n\n    def _set_egg(self, path: str):\n        self.egg_name = os.path.basename(path)\n        self.egg_info = os.path.join(path, 'EGG-INFO')\n        self.egg_root = path\n\n\nclass DefaultProvider(EggProvider):\n    \"\"\"Provides access to package resources in the filesystem\"\"\"\n\n    def _has(self, path) -> bool:\n        return os.path.exists(path)\n\n    def _isdir(self, path) -> bool:\n        return os.path.isdir(path)\n\n    def _listdir(self, path):\n        return os.listdir(path)\n\n    def get_resource_stream(self, manager: object, resource_name: str):\n        return open(self._fn(self.module_path, resource_name), 'rb')\n\n    def _get(self, path) -> bytes:\n        with open(path, 'rb') as stream:\n            return stream.read()\n\n    @classmethod\n    def _register(cls):\n        loader_names = (\n            'SourceFileLoader',\n            'SourcelessFileLoader',\n        )\n        for name in loader_names:\n            loader_cls = getattr(importlib.machinery, name, type(None))\n            register_loader_type(loader_cls, cls)\n\n\nDefaultProvider._register()\n\n\nclass EmptyProvider(NullProvider):\n    \"\"\"Provider that returns nothing for all requests\"\"\"\n\n    # A special case, we don't want all Providers inheriting from NullProvider to have a potentially None module_path\n    module_path: str | None = None  # type: ignore[assignment]\n\n    _isdir = _has = lambda self, path: False\n\n    def _get(self, path) -> bytes:\n        return b''\n\n    def _listdir(self, path):\n        return []\n\n    def __init__(self):\n        pass\n\n\nempty_provider = EmptyProvider()\n\n\nclass ZipManifests(Dict[str, \"MemoizedZipManifests.manifest_mod\"]):\n    \"\"\"\n    zip manifest builder\n    \"\"\"\n\n    # `path` could be `StrPath | IO[bytes]` but that violates the LSP for `MemoizedZipManifests.load`\n    @classmethod\n    def build(cls, path: str):\n        \"\"\"\n        Build a dictionary similar to the zipimport directory\n        caches, except instead of tuples, store ZipInfo objects.\n\n        Use a platform-specific path separator (os.sep) for the path keys\n        for compatibility with pypy on Windows.\n        \"\"\"\n        with zipfile.ZipFile(path) as zfile:\n            items = (\n                (\n                    name.replace('/', os.sep),\n                    zfile.getinfo(name),\n                )\n                for name in zfile.namelist()\n            )\n            return dict(items)\n\n    load = build\n\n\nclass MemoizedZipManifests(ZipManifests):\n    \"\"\"\n    Memoized zipfile manifests.\n    \"\"\"\n\n    class manifest_mod(NamedTuple):\n        manifest: dict[str, zipfile.ZipInfo]\n        mtime: float\n\n    def load(self, path: str) -> dict[str, zipfile.ZipInfo]:  # type: ignore[override] # ZipManifests.load is a classmethod\n        \"\"\"\n        Load a manifest at path or return a suitable manifest already loaded.\n        \"\"\"\n        path = os.path.normpath(path)\n        mtime = os.stat(path).st_mtime\n\n        if path not in self or self[path].mtime != mtime:\n            manifest = self.build(path)\n            self[path] = self.manifest_mod(manifest, mtime)\n\n        return self[path].manifest\n\n\nclass ZipProvider(EggProvider):\n    \"\"\"Resource support for zips and eggs\"\"\"\n\n    eagers: list[str] | None = None\n    _zip_manifests = MemoizedZipManifests()\n    # ZipProvider's loader should always be a zipimporter or equivalent\n    loader: zipimport.zipimporter\n\n    def __init__(self, module: _ZipLoaderModule):\n        super().__init__(module)\n        self.zip_pre = self.loader.archive + os.sep\n\n    def _zipinfo_name(self, fspath):\n        # Convert a virtual filename (full path to file) into a zipfile subpath\n        # usable with the zipimport directory cache for our target archive\n        fspath = fspath.rstrip(os.sep)\n        if fspath == self.loader.archive:\n            return ''\n        if fspath.startswith(self.zip_pre):\n            return fspath[len(self.zip_pre) :]\n        raise AssertionError(\"%s is not a subpath of %s\" % (fspath, self.zip_pre))\n\n    def _parts(self, zip_path):\n        # Convert a zipfile subpath into an egg-relative path part list.\n        # pseudo-fs path\n        fspath = self.zip_pre + zip_path\n        if fspath.startswith(self.egg_root + os.sep):\n            return fspath[len(self.egg_root) + 1 :].split(os.sep)\n        raise AssertionError(\"%s is not a subpath of %s\" % (fspath, self.egg_root))\n\n    @property\n    def zipinfo(self):\n        return self._zip_manifests.load(self.loader.archive)\n\n    def get_resource_filename(self, manager: ResourceManager, resource_name: str):\n        if not self.egg_name:\n            raise NotImplementedError(\n                \"resource_filename() only supported for .egg, not .zip\"\n            )\n        # no need to lock for extraction, since we use temp names\n        zip_path = self._resource_to_zip(resource_name)\n        eagers = self._get_eager_resources()\n        if '/'.join(self._parts(zip_path)) in eagers:\n            for name in eagers:\n                self._extract_resource(manager, self._eager_to_zip(name))\n        return self._extract_resource(manager, zip_path)\n\n    @staticmethod\n    def _get_date_and_size(zip_stat):\n        size = zip_stat.file_size\n        # ymdhms+wday, yday, dst\n        date_time = zip_stat.date_time + (0, 0, -1)\n        # 1980 offset already done\n        timestamp = time.mktime(date_time)\n        return timestamp, size\n\n    # FIXME: 'ZipProvider._extract_resource' is too complex (12)\n    def _extract_resource(self, manager: ResourceManager, zip_path) -> str:  # noqa: C901\n        if zip_path in self._index():\n            for name in self._index()[zip_path]:\n                last = self._extract_resource(manager, os.path.join(zip_path, name))\n            # return the extracted directory name\n            return os.path.dirname(last)\n\n        timestamp, size = self._get_date_and_size(self.zipinfo[zip_path])\n\n        if not WRITE_SUPPORT:\n            raise OSError(\n                '\"os.rename\" and \"os.unlink\" are not supported on this platform'\n            )\n        try:\n            if not self.egg_name:\n                raise OSError(\n                    '\"egg_name\" is empty. This likely means no egg could be found from the \"module_path\".'\n                )\n            real_path = manager.get_cache_path(self.egg_name, self._parts(zip_path))\n\n            if self._is_current(real_path, zip_path):\n                return real_path\n\n            outf, tmpnam = _mkstemp(\n                \".$extract\",\n                dir=os.path.dirname(real_path),\n            )\n            os.write(outf, self.loader.get_data(zip_path))\n            os.close(outf)\n            utime(tmpnam, (timestamp, timestamp))\n            manager.postprocess(tmpnam, real_path)\n\n            try:\n                rename(tmpnam, real_path)\n\n            except OSError:\n                if os.path.isfile(real_path):\n                    if self._is_current(real_path, zip_path):\n                        # the file became current since it was checked above,\n                        #  so proceed.\n                        return real_path\n                    # Windows, del old file and retry\n                    elif os.name == 'nt':\n                        unlink(real_path)\n                        rename(tmpnam, real_path)\n                        return real_path\n                raise\n\n        except OSError:\n            # report a user-friendly error\n            manager.extraction_error()\n\n        return real_path\n\n    def _is_current(self, file_path, zip_path):\n        \"\"\"\n        Return True if the file_path is current for this zip_path\n        \"\"\"\n        timestamp, size = self._get_date_and_size(self.zipinfo[zip_path])\n        if not os.path.isfile(file_path):\n            return False\n        stat = os.stat(file_path)\n        if stat.st_size != size or stat.st_mtime != timestamp:\n            return False\n        # check that the contents match\n        zip_contents = self.loader.get_data(zip_path)\n        with open(file_path, 'rb') as f:\n            file_contents = f.read()\n        return zip_contents == file_contents\n\n    def _get_eager_resources(self):\n        if self.eagers is None:\n            eagers = []\n            for name in ('native_libs.txt', 'eager_resources.txt'):\n                if self.has_metadata(name):\n                    eagers.extend(self.get_metadata_lines(name))\n            self.eagers = eagers\n        return self.eagers\n\n    def _index(self):\n        try:\n            return self._dirindex\n        except AttributeError:\n            ind = {}\n            for path in self.zipinfo:\n                parts = path.split(os.sep)\n                while parts:\n                    parent = os.sep.join(parts[:-1])\n                    if parent in ind:\n                        ind[parent].append(parts[-1])\n                        break\n                    else:\n                        ind[parent] = [parts.pop()]\n            self._dirindex = ind\n            return ind\n\n    def _has(self, fspath) -> bool:\n        zip_path = self._zipinfo_name(fspath)\n        return zip_path in self.zipinfo or zip_path in self._index()\n\n    def _isdir(self, fspath) -> bool:\n        return self._zipinfo_name(fspath) in self._index()\n\n    def _listdir(self, fspath):\n        return list(self._index().get(self._zipinfo_name(fspath), ()))\n\n    def _eager_to_zip(self, resource_name: str):\n        return self._zipinfo_name(self._fn(self.egg_root, resource_name))\n\n    def _resource_to_zip(self, resource_name: str):\n        return self._zipinfo_name(self._fn(self.module_path, resource_name))\n\n\nregister_loader_type(zipimport.zipimporter, ZipProvider)\n\n\nclass FileMetadata(EmptyProvider):\n    \"\"\"Metadata handler for standalone PKG-INFO files\n\n    Usage::\n\n        metadata = FileMetadata(\"/path/to/PKG-INFO\")\n\n    This provider rejects all data and metadata requests except for PKG-INFO,\n    which is treated as existing, and will be the contents of the file at\n    the provided location.\n    \"\"\"\n\n    def __init__(self, path: StrPath):\n        self.path = path\n\n    def _get_metadata_path(self, name):\n        return self.path\n\n    def has_metadata(self, name: str) -> bool:\n        return name == 'PKG-INFO' and os.path.isfile(self.path)\n\n    def get_metadata(self, name: str):\n        if name != 'PKG-INFO':\n            raise KeyError(\"No metadata except PKG-INFO is available\")\n\n        with open(self.path, encoding='utf-8', errors=\"replace\") as f:\n            metadata = f.read()\n        self._warn_on_replacement(metadata)\n        return metadata\n\n    def _warn_on_replacement(self, metadata):\n        replacement_char = ''\n        if replacement_char in metadata:\n            tmpl = \"{self.path} could not be properly decoded in UTF-8\"\n            msg = tmpl.format(**locals())\n            warnings.warn(msg)\n\n    def get_metadata_lines(self, name: str) -> Iterator[str]:\n        return yield_lines(self.get_metadata(name))\n\n\nclass PathMetadata(DefaultProvider):\n    \"\"\"Metadata provider for egg directories\n\n    Usage::\n\n        # Development eggs:\n\n        egg_info = \"/path/to/PackageName.egg-info\"\n        base_dir = os.path.dirname(egg_info)\n        metadata = PathMetadata(base_dir, egg_info)\n        dist_name = os.path.splitext(os.path.basename(egg_info))[0]\n        dist = Distribution(basedir, project_name=dist_name, metadata=metadata)\n\n        # Unpacked egg directories:\n\n        egg_path = \"/path/to/PackageName-ver-pyver-etc.egg\"\n        metadata = PathMetadata(egg_path, os.path.join(egg_path,'EGG-INFO'))\n        dist = Distribution.from_filename(egg_path, metadata=metadata)\n    \"\"\"\n\n    def __init__(self, path: str, egg_info: str):\n        self.module_path = path\n        self.egg_info = egg_info\n\n\nclass EggMetadata(ZipProvider):\n    \"\"\"Metadata provider for .egg files\"\"\"\n\n    def __init__(self, importer: zipimport.zipimporter):\n        \"\"\"Create a metadata provider from a zipimporter\"\"\"\n\n        self.zip_pre = importer.archive + os.sep\n        self.loader = importer\n        if importer.prefix:\n            self.module_path = os.path.join(importer.archive, importer.prefix)\n        else:\n            self.module_path = importer.archive\n        self._setup_prefix()\n\n\n_distribution_finders: dict[type, _DistFinderType[Any]] = _declare_state(\n    'dict', '_distribution_finders', {}\n)\n\n\ndef register_finder(importer_type: type[_T], distribution_finder: _DistFinderType[_T]):\n    \"\"\"Register `distribution_finder` to find distributions in sys.path items\n\n    `importer_type` is the type or class of a PEP 302 \"Importer\" (sys.path item\n    handler), and `distribution_finder` is a callable that, passed a path\n    item and the importer instance, yields ``Distribution`` instances found on\n    that path item.  See ``pkg_resources.find_on_path`` for an example.\"\"\"\n    _distribution_finders[importer_type] = distribution_finder\n\n\ndef find_distributions(path_item: str, only: bool = False):\n    \"\"\"Yield distributions accessible via `path_item`\"\"\"\n    importer = get_importer(path_item)\n    finder = _find_adapter(_distribution_finders, importer)\n    return finder(importer, path_item, only)\n\n\ndef find_eggs_in_zip(\n    importer: zipimport.zipimporter, path_item: str, only: bool = False\n) -> Iterator[Distribution]:\n    \"\"\"\n    Find eggs in zip files; possibly multiple nested eggs.\n    \"\"\"\n    if importer.archive.endswith('.whl'):\n        # wheels are not supported with this finder\n        # they don't have PKG-INFO metadata, and won't ever contain eggs\n        return\n    metadata = EggMetadata(importer)\n    if metadata.has_metadata('PKG-INFO'):\n        yield Distribution.from_filename(path_item, metadata=metadata)\n    if only:\n        # don't yield nested distros\n        return\n    for subitem in metadata.resource_listdir(''):\n        if _is_egg_path(subitem):\n            subpath = os.path.join(path_item, subitem)\n            dists = find_eggs_in_zip(zipimport.zipimporter(subpath), subpath)\n            yield from dists\n        elif subitem.lower().endswith(('.dist-info', '.egg-info')):\n            subpath = os.path.join(path_item, subitem)\n            submeta = EggMetadata(zipimport.zipimporter(subpath))\n            submeta.egg_info = subpath\n            yield Distribution.from_location(path_item, subitem, submeta)\n\n\nregister_finder(zipimport.zipimporter, find_eggs_in_zip)\n\n\ndef find_nothing(\n    importer: object | None, path_item: str | None, only: bool | None = False\n):\n    return ()\n\n\nregister_finder(object, find_nothing)\n\n\ndef find_on_path(importer: object | None, path_item, only=False):\n    \"\"\"Yield distributions accessible on a sys.path directory\"\"\"\n    path_item = _normalize_cached(path_item)\n\n    if _is_unpacked_egg(path_item):\n        yield Distribution.from_filename(\n            path_item,\n            metadata=PathMetadata(path_item, os.path.join(path_item, 'EGG-INFO')),\n        )\n        return\n\n    entries = (os.path.join(path_item, child) for child in safe_listdir(path_item))\n\n    # scan for .egg and .egg-info in directory\n    for entry in sorted(entries):\n        fullpath = os.path.join(path_item, entry)\n        factory = dist_factory(path_item, entry, only)\n        yield from factory(fullpath)\n\n\ndef dist_factory(path_item, entry, only):\n    \"\"\"Return a dist_factory for the given entry.\"\"\"\n    lower = entry.lower()\n    is_egg_info = lower.endswith('.egg-info')\n    is_dist_info = lower.endswith('.dist-info') and os.path.isdir(\n        os.path.join(path_item, entry)\n    )\n    is_meta = is_egg_info or is_dist_info\n    return (\n        distributions_from_metadata\n        if is_meta\n        else find_distributions\n        if not only and _is_egg_path(entry)\n        else resolve_egg_link\n        if not only and lower.endswith('.egg-link')\n        else NoDists()\n    )\n\n\nclass NoDists:\n    \"\"\"\n    >>> bool(NoDists())\n    False\n\n    >>> list(NoDists()('anything'))\n    []\n    \"\"\"\n\n    def __bool__(self):\n        return False\n\n    def __call__(self, fullpath):\n        return iter(())\n\n\ndef safe_listdir(path: StrOrBytesPath):\n    \"\"\"\n    Attempt to list contents of path, but suppress some exceptions.\n    \"\"\"\n    try:\n        return os.listdir(path)\n    except (PermissionError, NotADirectoryError):\n        pass\n    except OSError as e:\n        # Ignore the directory if does not exist, not a directory or\n        # permission denied\n        if e.errno not in (errno.ENOTDIR, errno.EACCES, errno.ENOENT):\n            raise\n    return ()\n\n\ndef distributions_from_metadata(path: str):\n    root = os.path.dirname(path)\n    if os.path.isdir(path):\n        if len(os.listdir(path)) == 0:\n            # empty metadata dir; skip\n            return\n        metadata: _MetadataType = PathMetadata(root, path)\n    else:\n        metadata = FileMetadata(path)\n    entry = os.path.basename(path)\n    yield Distribution.from_location(\n        root,\n        entry,\n        metadata,\n        precedence=DEVELOP_DIST,\n    )\n\n\ndef non_empty_lines(path):\n    \"\"\"\n    Yield non-empty lines from file at path\n    \"\"\"\n    for line in _read_utf8_with_fallback(path).splitlines():\n        line = line.strip()\n        if line:\n            yield line\n\n\ndef resolve_egg_link(path):\n    \"\"\"\n    Given a path to an .egg-link, resolve distributions\n    present in the referenced path.\n    \"\"\"\n    referenced_paths = non_empty_lines(path)\n    resolved_paths = (\n        os.path.join(os.path.dirname(path), ref) for ref in referenced_paths\n    )\n    dist_groups = map(find_distributions, resolved_paths)\n    return next(dist_groups, ())\n\n\nif hasattr(pkgutil, 'ImpImporter'):\n    register_finder(pkgutil.ImpImporter, find_on_path)\n\nregister_finder(importlib.machinery.FileFinder, find_on_path)\n\n_namespace_handlers: dict[type, _NSHandlerType[Any]] = _declare_state(\n    'dict', '_namespace_handlers', {}\n)\n_namespace_packages: dict[str | None, list[str]] = _declare_state(\n    'dict', '_namespace_packages', {}\n)\n\n\ndef register_namespace_handler(\n    importer_type: type[_T], namespace_handler: _NSHandlerType[_T]\n):\n    \"\"\"Register `namespace_handler` to declare namespace packages\n\n    `importer_type` is the type or class of a PEP 302 \"Importer\" (sys.path item\n    handler), and `namespace_handler` is a callable like this::\n\n        def namespace_handler(importer, path_entry, moduleName, module):\n            # return a path_entry to use for child packages\n\n    Namespace handlers are only called if the importer object has already\n    agreed that it can handle the relevant path item, and they should only\n    return a subpath if the module __path__ does not already contain an\n    equivalent subpath.  For an example namespace handler, see\n    ``pkg_resources.file_ns_handler``.\n    \"\"\"\n    _namespace_handlers[importer_type] = namespace_handler\n\n\ndef _handle_ns(packageName, path_item):\n    \"\"\"Ensure that named package includes a subpath of path_item (if needed)\"\"\"\n\n    importer = get_importer(path_item)\n    if importer is None:\n        return None\n\n    # use find_spec (PEP 451) and fall-back to find_module (PEP 302)\n    try:\n        spec = importer.find_spec(packageName)\n    except AttributeError:\n        # capture warnings due to #1111\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            loader = importer.find_module(packageName)\n    else:\n        loader = spec.loader if spec else None\n\n    if loader is None:\n        return None\n    module = sys.modules.get(packageName)\n    if module is None:\n        module = sys.modules[packageName] = types.ModuleType(packageName)\n        module.__path__ = []\n        _set_parent_ns(packageName)\n    elif not hasattr(module, '__path__'):\n        raise TypeError(\"Not a package:\", packageName)\n    handler = _find_adapter(_namespace_handlers, importer)\n    subpath = handler(importer, path_item, packageName, module)\n    if subpath is not None:\n        path = module.__path__\n        path.append(subpath)\n        importlib.import_module(packageName)\n        _rebuild_mod_path(path, packageName, module)\n    return subpath\n\n\ndef _rebuild_mod_path(orig_path, package_name, module: types.ModuleType):\n    \"\"\"\n    Rebuild module.__path__ ensuring that all entries are ordered\n    corresponding to their sys.path order\n    \"\"\"\n    sys_path = [_normalize_cached(p) for p in sys.path]\n\n    def safe_sys_path_index(entry):\n        \"\"\"\n        Workaround for #520 and #513.\n        \"\"\"\n        try:\n            return sys_path.index(entry)\n        except ValueError:\n            return float('inf')\n\n    def position_in_sys_path(path):\n        \"\"\"\n        Return the ordinal of the path based on its position in sys.path\n        \"\"\"\n        path_parts = path.split(os.sep)\n        module_parts = package_name.count('.') + 1\n        parts = path_parts[:-module_parts]\n        return safe_sys_path_index(_normalize_cached(os.sep.join(parts)))\n\n    new_path = sorted(orig_path, key=position_in_sys_path)\n    new_path = [_normalize_cached(p) for p in new_path]\n\n    if isinstance(module.__path__, list):\n        module.__path__[:] = new_path\n    else:\n        module.__path__ = new_path\n\n\ndef declare_namespace(packageName: str):\n    \"\"\"Declare that package 'packageName' is a namespace package\"\"\"\n\n    msg = (\n        f\"Deprecated call to `pkg_resources.declare_namespace({packageName!r})`.\\n\"\n        \"Implementing implicit namespace packages (as specified in PEP 420) \"\n        \"is preferred to `pkg_resources.declare_namespace`. \"\n        \"See https://setuptools.pypa.io/en/latest/references/\"\n        \"keywords.html#keyword-namespace-packages\"\n    )\n    warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    _imp.acquire_lock()\n    try:\n        if packageName in _namespace_packages:\n            return\n\n        path: MutableSequence[str] = sys.path\n        parent, _, _ = packageName.rpartition('.')\n\n        if parent:\n            declare_namespace(parent)\n            if parent not in _namespace_packages:\n                __import__(parent)\n            try:\n                path = sys.modules[parent].__path__\n            except AttributeError as e:\n                raise TypeError(\"Not a package:\", parent) from e\n\n        # Track what packages are namespaces, so when new path items are added,\n        # they can be updated\n        _namespace_packages.setdefault(parent or None, []).append(packageName)\n        _namespace_packages.setdefault(packageName, [])\n\n        for path_item in path:\n            # Ensure all the parent's path items are reflected in the child,\n            # if they apply\n            _handle_ns(packageName, path_item)\n\n    finally:\n        _imp.release_lock()\n\n\ndef fixup_namespace_packages(path_item: str, parent: str | None = None):\n    \"\"\"Ensure that previously-declared namespace packages include path_item\"\"\"\n    _imp.acquire_lock()\n    try:\n        for package in _namespace_packages.get(parent, ()):\n            subpath = _handle_ns(package, path_item)\n            if subpath:\n                fixup_namespace_packages(subpath, package)\n    finally:\n        _imp.release_lock()\n\n\ndef file_ns_handler(\n    importer: object,\n    path_item: StrPath,\n    packageName: str,\n    module: types.ModuleType,\n):\n    \"\"\"Compute an ns-package subpath for a filesystem or zipfile importer\"\"\"\n\n    subpath = os.path.join(path_item, packageName.split('.')[-1])\n    normalized = _normalize_cached(subpath)\n    for item in module.__path__:\n        if _normalize_cached(item) == normalized:\n            break\n    else:\n        # Only return the path if it's not already there\n        return subpath\n\n\nif hasattr(pkgutil, 'ImpImporter'):\n    register_namespace_handler(pkgutil.ImpImporter, file_ns_handler)\n\nregister_namespace_handler(zipimport.zipimporter, file_ns_handler)\nregister_namespace_handler(importlib.machinery.FileFinder, file_ns_handler)\n\n\ndef null_ns_handler(\n    importer: object,\n    path_item: str | None,\n    packageName: str | None,\n    module: _ModuleLike | None,\n):\n    return None\n\n\nregister_namespace_handler(object, null_ns_handler)\n\n\n@overload\ndef normalize_path(filename: StrPath) -> str: ...\n@overload\ndef normalize_path(filename: BytesPath) -> bytes: ...\ndef normalize_path(filename: StrOrBytesPath):\n    \"\"\"Normalize a file/dir name for comparison purposes\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.normpath(_cygwin_patch(filename))))\n\n\ndef _cygwin_patch(filename: StrOrBytesPath):  # pragma: nocover\n    \"\"\"\n    Contrary to POSIX 2008, on Cygwin, getcwd (3) contains\n    symlink components. Using\n    os.path.abspath() works around this limitation. A fix in os.getcwd()\n    would probably better, in Cygwin even more so, except\n    that this seems to be by design...\n    \"\"\"\n    return os.path.abspath(filename) if sys.platform == 'cygwin' else filename\n\n\nif TYPE_CHECKING:\n    # https://github.com/python/mypy/issues/16261\n    # https://github.com/python/typeshed/issues/6347\n    @overload\n    def _normalize_cached(filename: StrPath) -> str: ...\n    @overload\n    def _normalize_cached(filename: BytesPath) -> bytes: ...\n    def _normalize_cached(filename: StrOrBytesPath) -> str | bytes: ...\nelse:\n\n    @functools.lru_cache(maxsize=None)\n    def _normalize_cached(filename):\n        return normalize_path(filename)\n\n\ndef _is_egg_path(path):\n    \"\"\"\n    Determine if given path appears to be an egg.\n    \"\"\"\n    return _is_zip_egg(path) or _is_unpacked_egg(path)\n\n\ndef _is_zip_egg(path):\n    return (\n        path.lower().endswith('.egg')\n        and os.path.isfile(path)\n        and zipfile.is_zipfile(path)\n    )\n\n\ndef _is_unpacked_egg(path):\n    \"\"\"\n    Determine if given path appears to be an unpacked egg.\n    \"\"\"\n    return path.lower().endswith('.egg') and os.path.isfile(\n        os.path.join(path, 'EGG-INFO', 'PKG-INFO')\n    )\n\n\ndef _set_parent_ns(packageName):\n    parts = packageName.split('.')\n    name = parts.pop()\n    if parts:\n        parent = '.'.join(parts)\n        setattr(sys.modules[parent], name, sys.modules[packageName])\n\n\nMODULE = re.compile(r\"\\w+(\\.\\w+)*$\").match\nEGG_NAME = re.compile(\n    r\"\"\"\n    (?P<name>[^-]+) (\n        -(?P<ver>[^-]+) (\n            -py(?P<pyver>[^-]+) (\n                -(?P<plat>.+)\n            )?\n        )?\n    )?\n    \"\"\",\n    re.VERBOSE | re.IGNORECASE,\n).match\n\n\nclass EntryPoint:\n    \"\"\"Object representing an advertised importable object\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        module_name: str,\n        attrs: Iterable[str] = (),\n        extras: Iterable[str] = (),\n        dist: Distribution | None = None,\n    ):\n        if not MODULE(module_name):\n            raise ValueError(\"Invalid module name\", module_name)\n        self.name = name\n        self.module_name = module_name\n        self.attrs = tuple(attrs)\n        self.extras = tuple(extras)\n        self.dist = dist\n\n    def __str__(self):\n        s = \"%s = %s\" % (self.name, self.module_name)\n        if self.attrs:\n            s += ':' + '.'.join(self.attrs)\n        if self.extras:\n            s += ' [%s]' % ','.join(self.extras)\n        return s\n\n    def __repr__(self):\n        return \"EntryPoint.parse(%r)\" % str(self)\n\n    @overload\n    def load(\n        self,\n        require: Literal[True] = True,\n        env: Environment | None = None,\n        installer: _InstallerType | None = None,\n    ) -> _ResolvedEntryPoint: ...\n    @overload\n    def load(\n        self,\n        require: Literal[False],\n        *args: Any,\n        **kwargs: Any,\n    ) -> _ResolvedEntryPoint: ...\n    def load(\n        self,\n        require: bool = True,\n        *args: Environment | _InstallerType | None,\n        **kwargs: Environment | _InstallerType | None,\n    ) -> _ResolvedEntryPoint:\n        \"\"\"\n        Require packages for this EntryPoint, then resolve it.\n        \"\"\"\n        if not require or args or kwargs:\n            warnings.warn(\n                \"Parameters to load are deprecated.  Call .resolve and \"\n                \".require separately.\",\n                PkgResourcesDeprecationWarning,\n                stacklevel=2,\n            )\n        if require:\n            # We could pass `env` and `installer` directly,\n            # but keeping `*args` and `**kwargs` for backwards compatibility\n            self.require(*args, **kwargs)  # type: ignore\n        return self.resolve()\n\n    def resolve(self) -> _ResolvedEntryPoint:\n        \"\"\"\n        Resolve the entry point from its module and attrs.\n        \"\"\"\n        module = __import__(self.module_name, fromlist=['__name__'], level=0)\n        try:\n            return functools.reduce(getattr, self.attrs, module)\n        except AttributeError as exc:\n            raise ImportError(str(exc)) from exc\n\n    def require(\n        self,\n        env: Environment | None = None,\n        installer: _InstallerType | None = None,\n    ):\n        if not self.dist:\n            error_cls = UnknownExtra if self.extras else AttributeError\n            raise error_cls(\"Can't require() without a distribution\", self)\n\n        # Get the requirements for this entry point with all its extras and\n        # then resolve them. We have to pass `extras` along when resolving so\n        # that the working set knows what extras we want. Otherwise, for\n        # dist-info distributions, the working set will assume that the\n        # requirements for that extra are purely optional and skip over them.\n        reqs = self.dist.requires(self.extras)\n        items = working_set.resolve(reqs, env, installer, extras=self.extras)\n        list(map(working_set.add, items))\n\n    pattern = re.compile(\n        r'\\s*'\n        r'(?P<name>.+?)\\s*'\n        r'=\\s*'\n        r'(?P<module>[\\w.]+)\\s*'\n        r'(:\\s*(?P<attr>[\\w.]+))?\\s*'\n        r'(?P<extras>\\[.*\\])?\\s*$'\n    )\n\n    @classmethod\n    def parse(cls, src: str, dist: Distribution | None = None):\n        \"\"\"Parse a single entry point from string `src`\n\n        Entry point syntax follows the form::\n\n            name = some.module:some.attr [extra1, extra2]\n\n        The entry name and module name are required, but the ``:attrs`` and\n        ``[extras]`` parts are optional\n        \"\"\"\n        m = cls.pattern.match(src)\n        if not m:\n            msg = \"EntryPoint must be in 'name=module:attrs [extras]' format\"\n            raise ValueError(msg, src)\n        res = m.groupdict()\n        extras = cls._parse_extras(res['extras'])\n        attrs = res['attr'].split('.') if res['attr'] else ()\n        return cls(res['name'], res['module'], attrs, extras, dist)\n\n    @classmethod\n    def _parse_extras(cls, extras_spec):\n        if not extras_spec:\n            return ()\n        req = Requirement.parse('x' + extras_spec)\n        if req.specs:\n            raise ValueError\n        return req.extras\n\n    @classmethod\n    def parse_group(\n        cls,\n        group: str,\n        lines: _NestedStr,\n        dist: Distribution | None = None,\n    ):\n        \"\"\"Parse an entry point group\"\"\"\n        if not MODULE(group):\n            raise ValueError(\"Invalid group name\", group)\n        this: dict[str, Self] = {}\n        for line in yield_lines(lines):\n            ep = cls.parse(line, dist)\n            if ep.name in this:\n                raise ValueError(\"Duplicate entry point\", group, ep.name)\n            this[ep.name] = ep\n        return this\n\n    @classmethod\n    def parse_map(\n        cls,\n        data: str | Iterable[str] | dict[str, str | Iterable[str]],\n        dist: Distribution | None = None,\n    ):\n        \"\"\"Parse a map of entry point groups\"\"\"\n        _data: Iterable[tuple[str | None, str | Iterable[str]]]\n        if isinstance(data, dict):\n            _data = data.items()\n        else:\n            _data = split_sections(data)\n        maps: dict[str, dict[str, Self]] = {}\n        for group, lines in _data:\n            if group is None:\n                if not lines:\n                    continue\n                raise ValueError(\"Entry points must be listed in groups\")\n            group = group.strip()\n            if group in maps:\n                raise ValueError(\"Duplicate group name\", group)\n            maps[group] = cls.parse_group(group, lines, dist)\n        return maps\n\n\ndef _version_from_file(lines):\n    \"\"\"\n    Given an iterable of lines from a Metadata file, return\n    the value of the Version field, if present, or None otherwise.\n    \"\"\"\n\n    def is_version_line(line):\n        return line.lower().startswith('version:')\n\n    version_lines = filter(is_version_line, lines)\n    line = next(iter(version_lines), '')\n    _, _, value = line.partition(':')\n    return safe_version(value.strip()) or None\n\n\nclass Distribution:\n    \"\"\"Wrap an actual or potential sys.path entry w/metadata\"\"\"\n\n    PKG_INFO = 'PKG-INFO'\n\n    def __init__(\n        self,\n        location: str | None = None,\n        metadata: _MetadataType = None,\n        project_name: str | None = None,\n        version: str | None = None,\n        py_version: str | None = PY_MAJOR,\n        platform: str | None = None,\n        precedence: int = EGG_DIST,\n    ):\n        self.project_name = safe_name(project_name or 'Unknown')\n        if version is not None:\n            self._version = safe_version(version)\n        self.py_version = py_version\n        self.platform = platform\n        self.location = location\n        self.precedence = precedence\n        self._provider = metadata or empty_provider\n\n    @classmethod\n    def from_location(\n        cls,\n        location: str,\n        basename: StrPath,\n        metadata: _MetadataType = None,\n        **kw: int,  # We could set `precedence` explicitly, but keeping this as `**kw` for full backwards and subclassing compatibility\n    ) -> Distribution:\n        project_name, version, py_version, platform = [None] * 4\n        basename, ext = os.path.splitext(basename)\n        if ext.lower() in _distributionImpl:\n            cls = _distributionImpl[ext.lower()]\n\n            match = EGG_NAME(basename)\n            if match:\n                project_name, version, py_version, platform = match.group(\n                    'name', 'ver', 'pyver', 'plat'\n                )\n        return cls(\n            location,\n            metadata,\n            project_name=project_name,\n            version=version,\n            py_version=py_version,\n            platform=platform,\n            **kw,\n        )._reload_version()\n\n    def _reload_version(self):\n        return self\n\n    @property\n    def hashcmp(self):\n        return (\n            self._forgiving_parsed_version,\n            self.precedence,\n            self.key,\n            self.location,\n            self.py_version or '',\n            self.platform or '',\n        )\n\n    def __hash__(self):\n        return hash(self.hashcmp)\n\n    def __lt__(self, other: Distribution):\n        return self.hashcmp < other.hashcmp\n\n    def __le__(self, other: Distribution):\n        return self.hashcmp <= other.hashcmp\n\n    def __gt__(self, other: Distribution):\n        return self.hashcmp > other.hashcmp\n\n    def __ge__(self, other: Distribution):\n        return self.hashcmp >= other.hashcmp\n\n    def __eq__(self, other: object):\n        if not isinstance(other, self.__class__):\n            # It's not a Distribution, so they are not equal\n            return False\n        return self.hashcmp == other.hashcmp\n\n    def __ne__(self, other: object):\n        return not self == other\n\n    # These properties have to be lazy so that we don't have to load any\n    # metadata until/unless it's actually needed.  (i.e., some distributions\n    # may not know their name or version without loading PKG-INFO)\n\n    @property\n    def key(self):\n        try:\n            return self._key\n        except AttributeError:\n            self._key = key = self.project_name.lower()\n            return key\n\n    @property\n    def parsed_version(self):\n        if not hasattr(self, \"_parsed_version\"):\n            try:\n                self._parsed_version = parse_version(self.version)\n            except _packaging_version.InvalidVersion as ex:\n                info = f\"(package: {self.project_name})\"\n                if hasattr(ex, \"add_note\"):\n                    ex.add_note(info)  # PEP 678\n                    raise\n                raise _packaging_version.InvalidVersion(f\"{str(ex)} {info}\") from None\n\n        return self._parsed_version\n\n    @property\n    def _forgiving_parsed_version(self):\n        try:\n            return self.parsed_version\n        except _packaging_version.InvalidVersion as ex:\n            self._parsed_version = parse_version(_forgiving_version(self.version))\n\n            notes = \"\\n\".join(getattr(ex, \"__notes__\", []))  # PEP 678\n            msg = f\"\"\"!!\\n\\n\n            *************************************************************************\n            {str(ex)}\\n{notes}\n\n            This is a long overdue deprecation.\n            For the time being, `pkg_resources` will use `{self._parsed_version}`\n            as a replacement to avoid breaking existing environments,\n            but no future compatibility is guaranteed.\n\n            If you maintain package {self.project_name} you should implement\n            the relevant changes to adequate the project to PEP 440 immediately.\n            *************************************************************************\n            \\n\\n!!\n            \"\"\"\n            warnings.warn(msg, DeprecationWarning)\n\n            return self._parsed_version\n\n    @property\n    def version(self):\n        try:\n            return self._version\n        except AttributeError as e:\n            version = self._get_version()\n            if version is None:\n                path = self._get_metadata_path_for_display(self.PKG_INFO)\n                msg = (\"Missing 'Version:' header and/or {} file at path: {}\").format(\n                    self.PKG_INFO, path\n                )\n                raise ValueError(msg, self) from e\n\n            return version\n\n    @property\n    def _dep_map(self):\n        \"\"\"\n        A map of extra to its list of (direct) requirements\n        for this distribution, including the null extra.\n        \"\"\"\n        try:\n            return self.__dep_map\n        except AttributeError:\n            self.__dep_map = self._filter_extras(self._build_dep_map())\n        return self.__dep_map\n\n    @staticmethod\n    def _filter_extras(dm: dict[str | None, list[Requirement]]):\n        \"\"\"\n        Given a mapping of extras to dependencies, strip off\n        environment markers and filter out any dependencies\n        not matching the markers.\n        \"\"\"\n        for extra in list(filter(None, dm)):\n            new_extra: str | None = extra\n            reqs = dm.pop(extra)\n            new_extra, _, marker = extra.partition(':')\n            fails_marker = marker and (\n                invalid_marker(marker) or not evaluate_marker(marker)\n            )\n            if fails_marker:\n                reqs = []\n            new_extra = safe_extra(new_extra) or None\n\n            dm.setdefault(new_extra, []).extend(reqs)\n        return dm\n\n    def _build_dep_map(self):\n        dm = {}\n        for name in 'requires.txt', 'depends.txt':\n            for extra, reqs in split_sections(self._get_metadata(name)):\n                dm.setdefault(extra, []).extend(parse_requirements(reqs))\n        return dm\n\n    def requires(self, extras: Iterable[str] = ()):\n        \"\"\"List of Requirements needed for this distro if `extras` are used\"\"\"\n        dm = self._dep_map\n        deps: list[Requirement] = []\n        deps.extend(dm.get(None, ()))\n        for ext in extras:\n            try:\n                deps.extend(dm[safe_extra(ext)])\n            except KeyError as e:\n                raise UnknownExtra(\n                    \"%s has no such extra feature %r\" % (self, ext)\n                ) from e\n        return deps\n\n    def _get_metadata_path_for_display(self, name):\n        \"\"\"\n        Return the path to the given metadata file, if available.\n        \"\"\"\n        try:\n            # We need to access _get_metadata_path() on the provider object\n            # directly rather than through this class's __getattr__()\n            # since _get_metadata_path() is marked private.\n            path = self._provider._get_metadata_path(name)\n\n        # Handle exceptions e.g. in case the distribution's metadata\n        # provider doesn't support _get_metadata_path().\n        except Exception:\n            return '[could not detect]'\n\n        return path\n\n    def _get_metadata(self, name):\n        if self.has_metadata(name):\n            yield from self.get_metadata_lines(name)\n\n    def _get_version(self):\n        lines = self._get_metadata(self.PKG_INFO)\n        return _version_from_file(lines)\n\n    def activate(self, path: list[str] | None = None, replace: bool = False):\n        \"\"\"Ensure distribution is importable on `path` (default=sys.path)\"\"\"\n        if path is None:\n            path = sys.path\n        self.insert_on(path, replace=replace)\n        if path is sys.path and self.location is not None:\n            fixup_namespace_packages(self.location)\n            for pkg in self._get_metadata('namespace_packages.txt'):\n                if pkg in sys.modules:\n                    declare_namespace(pkg)\n\n    def egg_name(self):\n        \"\"\"Return what this distribution's standard .egg filename should be\"\"\"\n        filename = \"%s-%s-py%s\" % (\n            to_filename(self.project_name),\n            to_filename(self.version),\n            self.py_version or PY_MAJOR,\n        )\n\n        if self.platform:\n            filename += '-' + self.platform\n        return filename\n\n    def __repr__(self):\n        if self.location:\n            return \"%s (%s)\" % (self, self.location)\n        else:\n            return str(self)\n\n    def __str__(self):\n        try:\n            version = getattr(self, 'version', None)\n        except ValueError:\n            version = None\n        version = version or \"[unknown version]\"\n        return \"%s %s\" % (self.project_name, version)\n\n    def __getattr__(self, attr):\n        \"\"\"Delegate all unrecognized public attributes to .metadata provider\"\"\"\n        if attr.startswith('_'):\n            raise AttributeError(attr)\n        return getattr(self._provider, attr)\n\n    def __dir__(self):\n        return list(\n            set(super().__dir__())\n            | set(attr for attr in self._provider.__dir__() if not attr.startswith('_'))\n        )\n\n    @classmethod\n    def from_filename(\n        cls,\n        filename: StrPath,\n        metadata: _MetadataType = None,\n        **kw: int,  # We could set `precedence` explicitly, but keeping this as `**kw` for full backwards and subclassing compatibility\n    ):\n        return cls.from_location(\n            _normalize_cached(filename), os.path.basename(filename), metadata, **kw\n        )\n\n    def as_requirement(self):\n        \"\"\"Return a ``Requirement`` that matches this distribution exactly\"\"\"\n        if isinstance(self.parsed_version, _packaging_version.Version):\n            spec = \"%s==%s\" % (self.project_name, self.parsed_version)\n        else:\n            spec = \"%s===%s\" % (self.project_name, self.parsed_version)\n\n        return Requirement.parse(spec)\n\n    def load_entry_point(self, group: str, name: str) -> _ResolvedEntryPoint:\n        \"\"\"Return the `name` entry point of `group` or raise ImportError\"\"\"\n        ep = self.get_entry_info(group, name)\n        if ep is None:\n            raise ImportError(\"Entry point %r not found\" % ((group, name),))\n        return ep.load()\n\n    @overload\n    def get_entry_map(self, group: None = None) -> dict[str, dict[str, EntryPoint]]: ...\n    @overload\n    def get_entry_map(self, group: str) -> dict[str, EntryPoint]: ...\n    def get_entry_map(self, group: str | None = None):\n        \"\"\"Return the entry point map for `group`, or the full entry map\"\"\"\n        if not hasattr(self, \"_ep_map\"):\n            self._ep_map = EntryPoint.parse_map(\n                self._get_metadata('entry_points.txt'), self\n            )\n        if group is not None:\n            return self._ep_map.get(group, {})\n        return self._ep_map\n\n    def get_entry_info(self, group: str, name: str):\n        \"\"\"Return the EntryPoint object for `group`+`name`, or ``None``\"\"\"\n        return self.get_entry_map(group).get(name)\n\n    # FIXME: 'Distribution.insert_on' is too complex (13)\n    def insert_on(  # noqa: C901\n        self,\n        path: list[str],\n        loc=None,\n        replace: bool = False,\n    ):\n        \"\"\"Ensure self.location is on path\n\n        If replace=False (default):\n            - If location is already in path anywhere, do nothing.\n            - Else:\n              - If it's an egg and its parent directory is on path,\n                insert just ahead of the parent.\n              - Else: add to the end of path.\n        If replace=True:\n            - If location is already on path anywhere (not eggs)\n              or higher priority than its parent (eggs)\n              do nothing.\n            - Else:\n              - If it's an egg and its parent directory is on path,\n                insert just ahead of the parent,\n                removing any lower-priority entries.\n              - Else: add it to the front of path.\n        \"\"\"\n\n        loc = loc or self.location\n        if not loc:\n            return\n\n        nloc = _normalize_cached(loc)\n        bdir = os.path.dirname(nloc)\n        npath = [(p and _normalize_cached(p) or p) for p in path]\n\n        for p, item in enumerate(npath):\n            if item == nloc:\n                if replace:\n                    break\n                else:\n                    # don't modify path (even removing duplicates) if\n                    # found and not replace\n                    return\n            elif item == bdir and self.precedence == EGG_DIST:\n                # if it's an .egg, give it precedence over its directory\n                # UNLESS it's already been added to sys.path and replace=False\n                if (not replace) and nloc in npath[p:]:\n                    return\n                if path is sys.path:\n                    self.check_version_conflict()\n                path.insert(p, loc)\n                npath.insert(p, nloc)\n                break\n        else:\n            if path is sys.path:\n                self.check_version_conflict()\n            if replace:\n                path.insert(0, loc)\n            else:\n                path.append(loc)\n            return\n\n        # p is the spot where we found or inserted loc; now remove duplicates\n        while True:\n            try:\n                np = npath.index(nloc, p + 1)\n            except ValueError:\n                break\n            else:\n                del npath[np], path[np]\n                # ha!\n                p = np\n\n        return\n\n    def check_version_conflict(self):\n        if self.key == 'setuptools':\n            # ignore the inevitable setuptools self-conflicts  :(\n            return\n\n        nsp = dict.fromkeys(self._get_metadata('namespace_packages.txt'))\n        loc = normalize_path(self.location)\n        for modname in self._get_metadata('top_level.txt'):\n            if (\n                modname not in sys.modules\n                or modname in nsp\n                or modname in _namespace_packages\n            ):\n                continue\n            if modname in ('pkg_resources', 'setuptools', 'site'):\n                continue\n            fn = getattr(sys.modules[modname], '__file__', None)\n            if fn and (\n                normalize_path(fn).startswith(loc) or fn.startswith(self.location)\n            ):\n                continue\n            issue_warning(\n                \"Module %s was already imported from %s, but %s is being added\"\n                \" to sys.path\" % (modname, fn, self.location),\n            )\n\n    def has_version(self):\n        try:\n            self.version\n        except ValueError:\n            issue_warning(\"Unbuilt egg for \" + repr(self))\n            return False\n        except SystemError:\n            # TODO: remove this except clause when python/cpython#103632 is fixed.\n            return False\n        return True\n\n    def clone(self, **kw: str | int | IResourceProvider | None):\n        \"\"\"Copy this distribution, substituting in any changed keyword args\"\"\"\n        names = 'project_name version py_version platform location precedence'\n        for attr in names.split():\n            kw.setdefault(attr, getattr(self, attr, None))\n        kw.setdefault('metadata', self._provider)\n        # Unsafely unpacking. But keeping **kw for backwards and subclassing compatibility\n        return self.__class__(**kw)  # type:ignore[arg-type]\n\n    @property\n    def extras(self):\n        return [dep for dep in self._dep_map if dep]\n\n\nclass EggInfoDistribution(Distribution):\n    def _reload_version(self):\n        \"\"\"\n        Packages installed by distutils (e.g. numpy or scipy),\n        which uses an old safe_version, and so\n        their version numbers can get mangled when\n        converted to filenames (e.g., 1.11.0.dev0+2329eae to\n        1.11.0.dev0_2329eae). These distributions will not be\n        parsed properly\n        downstream by Distribution and safe_version, so\n        take an extra step and try to get the version number from\n        the metadata file itself instead of the filename.\n        \"\"\"\n        md_version = self._get_version()\n        if md_version:\n            self._version = md_version\n        return self\n\n\nclass DistInfoDistribution(Distribution):\n    \"\"\"\n    Wrap an actual or potential sys.path entry\n    w/metadata, .dist-info style.\n    \"\"\"\n\n    PKG_INFO = 'METADATA'\n    EQEQ = re.compile(r\"([\\(,])\\s*(\\d.*?)\\s*([,\\)])\")\n\n    @property\n    def _parsed_pkg_info(self):\n        \"\"\"Parse and cache metadata\"\"\"\n        try:\n            return self._pkg_info\n        except AttributeError:\n            metadata = self.get_metadata(self.PKG_INFO)\n            self._pkg_info = email.parser.Parser().parsestr(metadata)\n            return self._pkg_info\n\n    @property\n    def _dep_map(self):\n        try:\n            return self.__dep_map\n        except AttributeError:\n            self.__dep_map = self._compute_dependencies()\n            return self.__dep_map\n\n    def _compute_dependencies(self) -> dict[str | None, list[Requirement]]:\n        \"\"\"Recompute this distribution's dependencies.\"\"\"\n        self.__dep_map: dict[str | None, list[Requirement]] = {None: []}\n\n        reqs: list[Requirement] = []\n        # Including any condition expressions\n        for req in self._parsed_pkg_info.get_all('Requires-Dist') or []:\n            reqs.extend(parse_requirements(req))\n\n        def reqs_for_extra(extra):\n            for req in reqs:\n                if not req.marker or req.marker.evaluate({'extra': extra}):\n                    yield req\n\n        common = types.MappingProxyType(dict.fromkeys(reqs_for_extra(None)))\n        self.__dep_map[None].extend(common)\n\n        for extra in self._parsed_pkg_info.get_all('Provides-Extra') or []:\n            s_extra = safe_extra(extra.strip())\n            self.__dep_map[s_extra] = [\n                r for r in reqs_for_extra(extra) if r not in common\n            ]\n\n        return self.__dep_map\n\n\n_distributionImpl = {\n    '.egg': Distribution,\n    '.egg-info': EggInfoDistribution,\n    '.dist-info': DistInfoDistribution,\n}\n\n\ndef issue_warning(*args, **kw):\n    level = 1\n    g = globals()\n    try:\n        # find the first stack frame that is *not* code in\n        # the pkg_resources module, to use for the warning\n        while sys._getframe(level).f_globals is g:\n            level += 1\n    except ValueError:\n        pass\n    warnings.warn(stacklevel=level + 1, *args, **kw)\n\n\ndef parse_requirements(strs: _NestedStr):\n    \"\"\"\n    Yield ``Requirement`` objects for each specification in `strs`.\n\n    `strs` must be a string, or a (possibly-nested) iterable thereof.\n    \"\"\"\n    return map(Requirement, join_continuation(map(drop_comment, yield_lines(strs))))\n\n\nclass RequirementParseError(_packaging_requirements.InvalidRequirement):\n    \"Compatibility wrapper for InvalidRequirement\"\n\n\nclass Requirement(_packaging_requirements.Requirement):\n    def __init__(self, requirement_string: str):\n        \"\"\"DO NOT CALL THIS UNDOCUMENTED METHOD; use Requirement.parse()!\"\"\"\n        super().__init__(requirement_string)\n        self.unsafe_name = self.name\n        project_name = safe_name(self.name)\n        self.project_name, self.key = project_name, project_name.lower()\n        self.specs = [(spec.operator, spec.version) for spec in self.specifier]\n        # packaging.requirements.Requirement uses a set for its extras. We use a variable-length tuple\n        self.extras: tuple[str] = tuple(map(safe_extra, self.extras))\n        self.hashCmp = (\n            self.key,\n            self.url,\n            self.specifier,\n            frozenset(self.extras),\n            str(self.marker) if self.marker else None,\n        )\n        self.__hash = hash(self.hashCmp)\n\n    def __eq__(self, other: object):\n        return isinstance(other, Requirement) and self.hashCmp == other.hashCmp\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __contains__(self, item: Distribution | str | tuple[str, ...]) -> bool:\n        if isinstance(item, Distribution):\n            if item.key != self.key:\n                return False\n\n            item = item.version\n\n        # Allow prereleases always in order to match the previous behavior of\n        # this method. In the future this should be smarter and follow PEP 440\n        # more accurately.\n        return self.specifier.contains(item, prereleases=True)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return \"Requirement.parse(%r)\" % str(self)\n\n    @staticmethod\n    def parse(s: str | Iterable[str]):\n        (req,) = parse_requirements(s)\n        return req\n\n\ndef _always_object(classes):\n    \"\"\"\n    Ensure object appears in the mro even\n    for old-style classes.\n    \"\"\"\n    if object not in classes:\n        return classes + (object,)\n    return classes\n\n\ndef _find_adapter(registry: Mapping[type, _AdapterT], ob: object) -> _AdapterT:\n    \"\"\"Return an adapter factory for `ob` from `registry`\"\"\"\n    types = _always_object(inspect.getmro(getattr(ob, '__class__', type(ob))))\n    for t in types:\n        if t in registry:\n            return registry[t]\n    # _find_adapter would previously return None, and immediately be called.\n    # So we're raising a TypeError to keep backward compatibility if anyone depended on that behaviour.\n    raise TypeError(f\"Could not find adapter for {registry} and {ob}\")\n\n\ndef ensure_directory(path: StrOrBytesPath):\n    \"\"\"Ensure that the parent directory of `path` exists\"\"\"\n    dirname = os.path.dirname(path)\n    os.makedirs(dirname, exist_ok=True)\n\n\ndef _bypass_ensure_directory(path):\n    \"\"\"Sandbox-bypassing version of ensure_directory()\"\"\"\n    if not WRITE_SUPPORT:\n        raise OSError('\"os.mkdir\" not supported on this platform.')\n    dirname, filename = split(path)\n    if dirname and filename and not isdir(dirname):\n        _bypass_ensure_directory(dirname)\n        try:\n            mkdir(dirname, 0o755)\n        except FileExistsError:\n            pass\n\n\ndef split_sections(s: _NestedStr) -> Iterator[tuple[str | None, list[str]]]:\n    \"\"\"Split a string or iterable thereof into (section, content) pairs\n\n    Each ``section`` is a stripped version of the section header (\"[section]\")\n    and each ``content`` is a list of stripped lines excluding blank lines and\n    comment-only lines.  If there are any such lines before the first section\n    header, they're returned in a first ``section`` of ``None``.\n    \"\"\"\n    section = None\n    content = []\n    for line in yield_lines(s):\n        if line.startswith(\"[\"):\n            if line.endswith(\"]\"):\n                if section or content:\n                    yield section, content\n                section = line[1:-1].strip()\n                content = []\n            else:\n                raise ValueError(\"Invalid section heading\", line)\n        else:\n            content.append(line)\n\n    # wrap up last segment\n    yield section, content\n\n\ndef _mkstemp(*args, **kw):\n    old_open = os.open\n    try:\n        # temporarily bypass sandboxing\n        os.open = os_open\n        return tempfile.mkstemp(*args, **kw)\n    finally:\n        # and then put it back\n        os.open = old_open\n\n\n# Silence the PEP440Warning by default, so that end users don't get hit by it\n# randomly just because they use pkg_resources. We want to append the rule\n# because we want earlier uses of filterwarnings to take precedence over this\n# one.\nwarnings.filterwarnings(\"ignore\", category=PEP440Warning, append=True)\n\n\nclass PkgResourcesDeprecationWarning(Warning):\n    \"\"\"\n    Base class for warning about deprecations in ``pkg_resources``\n\n    This class is not derived from ``DeprecationWarning``, and as such is\n    visible by default.\n    \"\"\"\n\n\n# Ported from ``setuptools`` to avoid introducing an import inter-dependency:\n_LOCALE_ENCODING = \"locale\" if sys.version_info >= (3, 10) else None\n\n\ndef _read_utf8_with_fallback(file: str, fallback_encoding=_LOCALE_ENCODING) -> str:\n    \"\"\"See setuptools.unicode_utils._read_utf8_with_fallback\"\"\"\n    try:\n        with open(file, \"r\", encoding=\"utf-8\") as f:\n            return f.read()\n    except UnicodeDecodeError:  # pragma: no cover\n        msg = f\"\"\"\\\n        ********************************************************************************\n        `encoding=\"utf-8\"` fails with {file!r}, trying `encoding={fallback_encoding!r}`.\n\n        This fallback behaviour is considered **deprecated** and future versions of\n        `setuptools/pkg_resources` may not implement it.\n\n        Please encode {file!r} with \"utf-8\" to ensure future builds will succeed.\n\n        If this file was produced by `setuptools` itself, cleaning up the cached files\n        and re-building/re-installing the package with a newer version of `setuptools`\n        (e.g. by updating `build-system.requires` in its `pyproject.toml`)\n        might solve the problem.\n        ********************************************************************************\n        \"\"\"\n        # TODO: Add a deadline?\n        #       See comment in setuptools.unicode_utils._Utf8EncodingNeeded\n        warnings.warn(msg, PkgResourcesDeprecationWarning, stacklevel=2)\n        with open(file, \"r\", encoding=fallback_encoding) as f:\n            return f.read()\n\n\n# from jaraco.functools 1.3\ndef _call_aside(f, *args, **kwargs):\n    f(*args, **kwargs)\n    return f\n\n\n@_call_aside\ndef _initialize(g=globals()):\n    \"Set up global resource manager (deliberately not state-saved)\"\n    manager = ResourceManager()\n    g['_manager'] = manager\n    g.update(\n        (name, getattr(manager, name))\n        for name in dir(manager)\n        if not name.startswith('_')\n    )\n\n\n@_call_aside\ndef _initialize_master_working_set():\n    \"\"\"\n    Prepare the master working set and make the ``require()``\n    API available.\n\n    This function has explicit effects on the global state\n    of pkg_resources. It is intended to be invoked once at\n    the initialization of this module.\n\n    Invocation by other packages is unsupported and done\n    at their own risk.\n    \"\"\"\n    working_set = _declare_state('object', 'working_set', WorkingSet._build_master())\n\n    require = working_set.require\n    iter_entry_points = working_set.iter_entry_points\n    add_activation_listener = working_set.subscribe\n    run_script = working_set.run_script\n    # backward compatibility\n    run_main = run_script\n    # Activate all distributions already on sys.path with replace=False and\n    # ensure that all distributions added to the working set in the future\n    # (e.g. by calling ``require()``) will get activated as well,\n    # with higher priority (replace=True).\n    tuple(dist.activate(replace=False) for dist in working_set)\n    add_activation_listener(\n        lambda dist: dist.activate(replace=True),\n        existing=False,\n    )\n    working_set.entries = []\n    # match order\n    list(map(working_set.add_entry, sys.path))\n    globals().update(locals())\n\n\nif TYPE_CHECKING:\n    # All of these are set by the @_call_aside methods above\n    __resource_manager = ResourceManager()  # Won't exist at runtime\n    resource_exists = __resource_manager.resource_exists\n    resource_isdir = __resource_manager.resource_isdir\n    resource_filename = __resource_manager.resource_filename\n    resource_stream = __resource_manager.resource_stream\n    resource_string = __resource_manager.resource_string\n    resource_listdir = __resource_manager.resource_listdir\n    set_extraction_path = __resource_manager.set_extraction_path\n    cleanup_resources = __resource_manager.cleanup_resources\n\n    working_set = WorkingSet()\n    require = working_set.require\n    iter_entry_points = working_set.iter_entry_points\n    add_activation_listener = working_set.subscribe\n    run_script = working_set.run_script\n    run_main = run_script\n",
  "metadata": {},
  "relative_path": "venv_new\\Lib\\site-packages\\pip\\_vendor\\pkg_resources\\__init__.py",
  "id": "83d1384c9ec80b907caf2714a1d3280e"
}