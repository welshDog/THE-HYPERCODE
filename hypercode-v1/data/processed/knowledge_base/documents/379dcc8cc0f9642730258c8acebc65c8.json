{
  "file_name": "interpreter.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\hypercode\\src\\core\\interpreter.py",
  "file_size": 8007,
  "created": "2025-11-26T23:37:35.584625",
  "modified": "2025-12-04T00:56:58.836952",
  "file_type": "code",
  "content_hash": "958e7ac9fa9cdf8116971bf733a2c7c4",
  "content_type": "text",
  "content": "# HyperCode Interpreter - Executes HyperCode AST\nimport time\nfrom typing import Any, Callable, Dict, List\nfrom .ast import *\nfrom .tokens import Token, TokenType\n\n\nclass RuntimeError(Exception):\n    def __init__(self, message: str, token: Token = None):\n        self.message = message\n        self.token = token\n        super().__init__(self.message)\n\n\nclass Environment:\n    def __init__(self, enclosing=None):\n        self.values: Dict[str, Any] = {}\n        self.enclosing = enclosing\n\n    def define(self, name: str, value: Any):\n        self.values[name] = value\n\n    def get(self, name: str):\n        if name in self.values:\n            return self.values[name]\n        if self.enclosing:\n            return self.enclosing.get(name)\n        raise RuntimeError(f\"Undefined variable '{name}'\")\n\n    def assign(self, name: str, value: Any):\n        if name in self.values:\n            self.values[name] = value\n            return\n        if self.enclosing:\n            self.enclosing.assign(name, value)\n            return\n        raise RuntimeError(f\"Undefined variable '{name}'\")\n\n\nclass Callable:\n    def arity(self) -> int:\n        raise NotImplementedError()\n\n    def call(self, interpreter, arguments: List[Any]) -> Any:\n        raise NotImplementedError()\n\n\nclass Function(Callable):\n    def __init__(self, declaration, closure):\n        self.declaration = declaration\n        self.closure = closure\n\n    def call(self, interpreter, arguments):\n        environment = Environment(self.closure)\n        for i in range(len(self.declaration.params)):\n            environment.define(self.declaration.params[i].lexeme, arguments[i])\n\n        try:\n            interpreter.execute_block(self.declaration.body, environment)\n        except ReturnException as return_value:\n            return return_value.value\n\n        return None\n\n    def arity(self):\n        return len(self.declaration.params)\n\n\nclass ReturnException(Exception):\n    def __init__(self, value):\n        self.value = value\n\n\nclass Interpreter:\n    def __init__(self):\n        self.globals = Environment()\n        self.environment = self.globals\n        self.output: List[str] = []\n        self.locals = {}\n\n        # Native functions\n        class Clock(Callable):\n            def arity(self) -> int:\n                return 0\n\n            def call(self, interpreter, arguments: List[Any]) -> float:\n                return time.time()\n\n            def __str__(self) -> str:\n                return \"<native fn>\"\n\n        self.globals.define(\"clock\", Clock())\n\n    def execute_block(self, statements, environment):\n        previous = self.environment\n        try:\n            self.environment = environment\n            for statement in statements:\n                self.execute(statement)\n        finally:\n            self.environment = previous\n\n    def interpret(self, statements: List[Stmt]):\n        try:\n            for statement in statements:\n                self.execute(statement)\n        except RuntimeError as error:\n            print(f\"âŒ Runtime Error: {error.message}\")\n            if error.token:\n                print(f\"   at line {error.token.line}\")\n\n    def execute(self, stmt: Stmt):\n        return stmt.accept(self)\n\n    def evaluate(self, expr: Expr):\n        return expr.accept(self)\n\n    def visit_Expression(self, stmt: Expression):\n        self.evaluate(stmt.expression)\n        return None\n\n    def visit_Print(self, stmt: Print):\n        value = self.evaluate(stmt.expression)\n        output = self.stringify(value)\n        self.output.append(output)\n        print(output)\n        return None\n\n    def visit_Var(self, stmt: Var):\n        value = None\n        if stmt.initializer:\n            value = self.evaluate(stmt.initializer)\n        self.environment.define(stmt.name.value, value)\n        return None\n\n    def visit_Block(self, stmt: Block):\n        self.execute_block(stmt.statements, Environment(self.environment))\n        return None\n\n    def visit_Expression(self, stmt: Expression):\n        self.evaluate(stmt.expression)\n        return None\n\n    def visit_Print(self, stmt: Print):\n        value = self.evaluate(stmt.expression)\n        print(value)\n        self.output.append(str(value))\n        return None\n\n    def visit_Intent(self, stmt: Intent):\n        for statement in stmt.statements:\n            self.execute(statement)\n        return None\n\n    def visit_Function(self, stmt: Function):\n        function = Function(stmt, self.environment)\n        self.environment.define(stmt.name.lexeme, function)\n        return None\n\n    def visit_Return(self, stmt: Return):\n        value = None\n        if stmt.value is not None:\n            value = self.evaluate(stmt.value)\n        raise ReturnException(value)\n\n    def visit_Literal(self, expr: Literal):\n        return expr.value\n\n    def visit_Grouping(self, expr: Grouping):\n        return self.evaluate(expr.expression)\n\n    def visit_Variable(self, expr: Variable):\n        return self.environment.get(expr.name.value)\n\n    def visit_Assign(self, expr: Assign):\n        value = self.evaluate(expr.value)\n        self.environment.assign(expr.name.value, value)\n        return value\n\n    def visit_Call(self, expr: Call):\n        callee = self.evaluate(expr.callee)\n\n        arguments = []\n        for argument in expr.arguments:\n            arguments.append(self.evaluate(argument))\n\n        if not isinstance(callee, Function):\n            raise RuntimeError(\"Can only call functions and classes.\", expr.paren)\n\n        if len(arguments) != callee.arity():\n            raise RuntimeError(\n                f\"Expected {callee.arity()} arguments but got {len(arguments)}.\",\n                expr.paren,\n            )\n\n        return callee.call(self, arguments)\n\n    def visit_Binary(self, expr: Binary):\n        left = self.evaluate(expr.left)\n        right = self.evaluate(expr.right)\n        op_type = expr.operator.token_type\n\n        if op_type == TokenType.PLUS:\n            if isinstance(left, str) or isinstance(right, str):\n                return str(left) + str(right)\n            return left + right\n        elif op_type == TokenType.MINUS:\n            return left - right\n        elif op_type == TokenType.STAR:\n            return left * right\n        elif op_type == TokenType.SLASH:\n            if right == 0:\n                raise RuntimeError(\"Division by zero\", expr.operator)\n            return left / right\n        elif op_type == TokenType.GREATER:\n            return left > right\n        elif op_type == TokenType.GREATER_EQUAL:\n            return left >= right\n        elif op_type == TokenType.LESS:\n            return left < right\n        elif op_type == TokenType.LESS_EQUAL:\n            return left <= right\n        elif op_type == TokenType.EQUAL_EQUAL:\n            return left == right\n        elif op_type == TokenType.BANG_EQUAL:\n            return left != right\n        return None\n\n    def visit_Unary(self, expr: Unary):\n        right = self.evaluate(expr.right)\n        if expr.operator.token_type == TokenType.MINUS:\n            return -right\n        elif expr.operator.token_type == TokenType.BANG:\n            return not self.is_truthy(right)\n        return None\n\n    def is_truthy(self, value):\n        if value is None:\n            return False\n        if isinstance(value, bool):\n            return value\n        return True\n\n    def stringify(self, value):\n        if value is None:\n            return \"nil\"\n        if isinstance(value, bool):\n            return \"true\" if value else \"false\"\n        if isinstance(value, float):\n            text = str(value)\n            if text.endswith(\".0\"):\n                text = text[:-2]\n            return text\n        return str(value)\n\n    def get_output(self) -> str:\n        return \"\\n\".join(self.output)\n",
  "metadata": {},
  "relative_path": "hypercode\\src\\core\\interpreter.py",
  "id": "379dcc8cc0f9642730258c8acebc65c8"
}