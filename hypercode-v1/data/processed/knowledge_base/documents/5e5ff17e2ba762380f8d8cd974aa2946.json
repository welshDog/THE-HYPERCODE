{
  "file_name": "interpreter.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\src\\core\\interpreter.py",
  "file_size": 10739,
  "created": "2025-11-25T18:01:45.377726",
  "modified": "2025-11-30T20:02:44.742268",
  "file_type": "code",
  "content_hash": "3947e9537e70fba164dd29e07eacce7f",
  "content_type": "text",
  "content": "# HyperCode Interpreter - Executes HyperCode AST\nimport time\nfrom typing import Any, Callable as PyCallable, Dict, List\nfrom .ast import *\nfrom .tokens import Token, TokenType\n\n\nclass RuntimeError(Exception):\n    def __init__(self, message: str, token: Token = None):\n        self.message = message\n        self.token = token\n        super().__init__(self.message)\n\n\nclass Environment:\n    def __init__(self, enclosing=None):\n        self.values: Dict[str, Any] = {}\n        self.enclosing = enclosing\n    \n    def define(self, name: str, value: Any):\n        self.values[name] = value\n    \n    def get(self, name: str):\n        if name in self.values:\n            return self.values[name]\n        if self.enclosing:\n            return self.enclosing.get(name)\n        raise RuntimeError(f\"Undefined variable '{name}'\")\n    \n    def assign(self, name: str, value: Any):\n        if name in self.values:\n            self.values[name] = value\n            return\n        if self.enclosing:\n            self.enclosing.assign(name, value)\n            return\n        raise RuntimeError(f\"Undefined variable '{name}'\")\n\n\nclass Callable:\n    def arity(self) -> int:\n        raise NotImplementedError()\n    \n    def call(self, interpreter, arguments: List[Any]) -> Any:\n        raise NotImplementedError()\n\n\nclass HyperCodeFunction(Callable):\n    def __init__(self, declaration, closure):\n        self.declaration = declaration\n        self.closure = closure\n    \n    def call(self, interpreter, arguments):\n        environment = Environment(self.closure)\n        for i in range(len(self.declaration.params)):\n            environment.define(self.declaration.params[i].lexeme, arguments[i])\n        \n        try:\n            interpreter.execute_block(self.declaration.body, environment)\n        except ReturnException as return_value:\n            return return_value.value\n        \n        return None\n    \n    def arity(self):\n        return len(self.declaration.params)\n\n\nclass ReturnException(Exception):\n    def __init__(self, value):\n        self.value = value\n\n\nclass Interpreter:\n    def __init__(self):\n        self.globals = Environment()\n        self.environment = self.globals\n        self.output: List[str] = []\n        self.locals = {}\n        \n        # Native functions\n        class Clock(Callable):\n            def arity(self) -> int:\n                return 0\n            \n            def call(self, interpreter, arguments: List[Any]) -> float:\n                return time.time()\n            \n            def __str__(self) -> str:\n                return \"<native fn>\"\n\n        class Double(Callable):\n            def arity(self) -> int:\n                return 1\n            \n            def call(self, interpreter, arguments: List[Any]) -> float:\n                if not isinstance(arguments[0], (int, float)):\n                    raise RuntimeError(\"Operand must be a number.\")\n                return arguments[0] * 2\n            \n            def __str__(self) -> str:\n                return \"<native fn>\"\n\n        class Square(Callable):\n            def arity(self) -> int:\n                return 1\n            \n            def call(self, interpreter, arguments: List[Any]) -> float:\n                if not isinstance(arguments[0], (int, float)):\n                    raise RuntimeError(\"Operand must be a number.\")\n                return arguments[0] * arguments[0]\n            \n            def __str__(self) -> str:\n                return \"<native fn>\"\n        \n        self.globals.define(\"clock\", Clock())\n        self.globals.define(\"double\", Double())\n        self.globals.define(\"square\", Square())\n    \n    def execute_block(self, statements, environment):\n        previous = self.environment\n        try:\n            self.environment = environment\n            for statement in statements:\n                self.execute(statement)\n        finally:\n            self.environment = previous\n    \n    def interpret(self, statements: List[Stmt]):\n        try:\n            for statement in statements:\n                self.execute(statement)\n        except ReturnException:\n            # A return from the top-level script. We can just ignore it and exit gracefully.\n            pass\n        except RuntimeError as error:\n            print(f\"âŒ Runtime Error: {error.message}\")\n            if error.token:\n                print(f\"   at line {error.token.line}\")\n    \n    def execute(self, stmt: Stmt):\n        return stmt.accept(self)\n    \n    def evaluate(self, expr: Expr):\n        return expr.accept(self)\n    \n    def visit_Expression(self, stmt: Expression):\n        self.evaluate(stmt.expression)\n        return None\n    \n    def visit_Print(self, stmt: Print):\n        value = self.evaluate(stmt.expression)\n        output = self.stringify(value)\n        self.output.append(output)\n        print(output)\n        return None\n    \n    def visit_Let(self, stmt: Let):\n        value = None\n        if stmt.initializer:\n            value = self.evaluate(stmt.initializer)\n        self.environment.define(stmt.name.lexeme, value)\n        return None\n\n    def visit_Block(self, stmt: Block):\n        self.execute_block(stmt.statements, Environment(self.environment))\n        return None\n        \n    def visit_BlockDecl(self, stmt: BlockDecl):\n        # For now, just execute the block in a new scope.\n        # In the future, this could define a callable/reusable block.\n        self.execute_block(stmt.body, Environment(self.environment))\n        return None\n\n    def visit_Intent(self, stmt: Intent):\n        for statement in stmt.statements:\n            self.execute(statement)\n        return None\n    \n    def visit_Function(self, stmt: Function):\n        function = HyperCodeFunction(stmt, self.environment)\n        self.environment.define(stmt.name.lexeme, function)\n        return None\n        \n    def visit_Return(self, stmt: Return):\n        value = None\n        if stmt.value is not None:\n            value = self.evaluate(stmt.value)\n        raise ReturnException(value)\n\n    def visit_Literal(self, expr: Literal):\n        return expr.value\n    \n    def visit_Grouping(self, expr: Grouping):\n        return self.evaluate(expr.expression)\n    \n    def visit_Variable(self, expr: Variable):\n        return self.environment.get(expr.name.lexeme)\n    \n    def visit_Assign(self, expr: Assign):\n        value = self.evaluate(expr.value)\n        self.environment.assign(expr.name.lexeme, value)\n        return value\n        \n    def visit_Pipe(self, expr: Pipe):\n        # Evaluate the head of the pipe\n        result = self.evaluate(expr.head)\n\n        # Sequentially call each step in the pipe\n        for step_expr in expr.steps:\n            callee = self.evaluate(step_expr)\n            if not isinstance(callee, Callable):\n                # For simplicity, we assume pipe steps are simple identifiers for now\n                if isinstance(step_expr, Variable):\n                    raise RuntimeError(f\"'{step_expr.name.lexeme}' is not a function.\", step_expr.name)\n                else:\n                    raise RuntimeError(\"Pipe steps must be callable functions.\")\n            \n            # Check arity\n            if callee.arity() != 1:\n                if isinstance(step_expr, Variable):\n                    raise RuntimeError(f\"Function '{step_expr.name.lexeme}' in pipe must accept exactly one argument.\", step_expr.name)\n                else:\n                    raise RuntimeError(\"Functions in a pipe must accept exactly one argument.\")\n\n            result = callee.call(self, [result])\n\n        # If there's a target, assign the final result to it\n        if expr.target:\n            self.environment.define(expr.target.lexeme, result)\n\n        return result\n\n    def visit_State(self, expr: State):\n        payload = None\n        if expr.payload:\n            payload = self.evaluate(expr.payload)\n        \n        return {\n            \"kind\": expr.name.lexeme,\n            \"payload\": payload\n        }\n\n    def visit_Call(self, expr: Call):\n        callee = self.evaluate(expr.callee)\n        \n        arguments = []\n        for argument in expr.arguments:\n            arguments.append(self.evaluate(argument))\n        \n        if not isinstance(callee, Callable):\n            raise RuntimeError(\"Can only call functions and classes.\", expr.paren)\n        \n        if len(arguments) != callee.arity():\n            raise RuntimeError(\n                f\"Expected {callee.arity()} arguments but got {len(arguments)}.\", \n                expr.paren\n            )\n        \n        return callee.call(self, arguments)\n    \n    def visit_Binary(self, expr: Binary):\n        left = self.evaluate(expr.left)\n        right = self.evaluate(expr.right)\n        op_type = expr.operator.type\n        \n        if op_type == TokenType.PLUS:\n            if isinstance(left, str) or isinstance(right, str):\n                return str(left) + str(right)\n            return left + right\n        elif op_type == TokenType.MINUS:\n            return left - right\n        elif op_type == TokenType.STAR:\n            return left * right\n        elif op_type == TokenType.SLASH:\n            if right == 0:\n                raise RuntimeError(\"Division by zero\", expr.operator)\n            return left / right\n        elif op_type == TokenType.GREATER:\n            return left > right\n        elif op_type == TokenType.GREATER_EQUAL:\n            return left >= right\n        elif op_type == TokenType.LESS:\n            return left < right\n        elif op_type == TokenType.LESS_EQUAL:\n            return left <= right\n        elif op_type == TokenType.EQUAL_EQUAL:\n            return left == right\n        elif op_type == TokenType.BANG_EQUAL:\n            return left != right\n        return None\n    \n    def visit_Unary(self, expr: Unary):\n        right = self.evaluate(expr.right)\n        if expr.operator.type == TokenType.MINUS:\n            return -right\n        elif expr.operator.type == TokenType.BANG:\n            return not self.is_truthy(right)\n        return None\n    \n    def is_truthy(self, value):\n        if value is None:\n            return False\n        if isinstance(value, bool):\n            return value\n        return True\n    \n    def stringify(self, value):\n        if value is None:\n            return \"nil\"\n        if isinstance(value, dict) and 'kind' in value and 'payload' in value:\n             return f\"@{value['kind']}({self.stringify(value['payload'])})\"\n        if isinstance(value, bool):\n            return \"true\" if value else \"false\"\n        if isinstance(value, float):\n            text = str(value)\n            if text.endswith(\".0\"):\n                text = text[:-2]\n            return text\n        return str(value)\n    \n    def get_output(self) -> str:\n        return \"\\n\".join(self.output)",
  "metadata": {},
  "relative_path": "src\\core\\interpreter.py",
  "id": "5e5ff17e2ba762380f8d8cd974aa2946"
}