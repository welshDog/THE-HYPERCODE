{
  "file_name": "__init__.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\venv_new\\Lib\\site-packages\\pip\\_vendor\\packaging\\licenses\\__init__.py",
  "file_size": 5727,
  "created": "2025-12-01T01:58:32.262179",
  "modified": "2025-12-01T01:58:32.267172",
  "file_type": "code",
  "content_hash": "942955719a1edf3d8c6a4df8085f4251",
  "content_type": "text",
  "content": "#######################################################################################\n#\n# Adapted from:\n#  https://github.com/pypa/hatch/blob/5352e44/backend/src/hatchling/licenses/parse.py\n#\n# MIT License\n#\n# Copyright (c) 2017-present Ofek Lev <oss@ofek.dev>\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy of this\n# software and associated documentation files (the \"Software\"), to deal in the Software\n# without restriction, including without limitation the rights to use, copy, modify,\n# merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to the following\n# conditions:\n#\n# The above copyright notice and this permission notice shall be included in all copies\n# or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\n#\n# With additional allowance of arbitrary `LicenseRef-` identifiers, not just\n# `LicenseRef-Public-Domain` and `LicenseRef-Proprietary`.\n#\n#######################################################################################\nfrom __future__ import annotations\n\nimport re\nfrom typing import NewType, cast\n\nfrom pip._vendor.packaging.licenses._spdx import EXCEPTIONS, LICENSES\n\n__all__ = [\n    \"NormalizedLicenseExpression\",\n    \"InvalidLicenseExpression\",\n    \"canonicalize_license_expression\",\n]\n\nlicense_ref_allowed = re.compile(\"^[A-Za-z0-9.-]*$\")\n\nNormalizedLicenseExpression = NewType(\"NormalizedLicenseExpression\", str)\n\n\nclass InvalidLicenseExpression(ValueError):\n    \"\"\"Raised when a license-expression string is invalid\n\n    >>> canonicalize_license_expression(\"invalid\")\n    Traceback (most recent call last):\n        ...\n    packaging.licenses.InvalidLicenseExpression: Invalid license expression: 'invalid'\n    \"\"\"\n\n\ndef canonicalize_license_expression(\n    raw_license_expression: str,\n) -> NormalizedLicenseExpression:\n    if not raw_license_expression:\n        message = f\"Invalid license expression: {raw_license_expression!r}\"\n        raise InvalidLicenseExpression(message)\n\n    # Pad any parentheses so tokenization can be achieved by merely splitting on\n    # whitespace.\n    license_expression = raw_license_expression.replace(\"(\", \" ( \").replace(\")\", \" ) \")\n    licenseref_prefix = \"LicenseRef-\"\n    license_refs = {\n        ref.lower(): \"LicenseRef-\" + ref[len(licenseref_prefix) :]\n        for ref in license_expression.split()\n        if ref.lower().startswith(licenseref_prefix.lower())\n    }\n\n    # Normalize to lower case so we can look up licenses/exceptions\n    # and so boolean operators are Python-compatible.\n    license_expression = license_expression.lower()\n\n    tokens = license_expression.split()\n\n    # Rather than implementing boolean logic, we create an expression that Python can\n    # parse. Everything that is not involved with the grammar itself is treated as\n    # `False` and the expression should evaluate as such.\n    python_tokens = []\n    for token in tokens:\n        if token not in {\"or\", \"and\", \"with\", \"(\", \")\"}:\n            python_tokens.append(\"False\")\n        elif token == \"with\":\n            python_tokens.append(\"or\")\n        elif token == \"(\" and python_tokens and python_tokens[-1] not in {\"or\", \"and\"}:\n            message = f\"Invalid license expression: {raw_license_expression!r}\"\n            raise InvalidLicenseExpression(message)\n        else:\n            python_tokens.append(token)\n\n    python_expression = \" \".join(python_tokens)\n    try:\n        invalid = eval(python_expression, globals(), locals())\n    except Exception:\n        invalid = True\n\n    if invalid is not False:\n        message = f\"Invalid license expression: {raw_license_expression!r}\"\n        raise InvalidLicenseExpression(message) from None\n\n    # Take a final pass to check for unknown licenses/exceptions.\n    normalized_tokens = []\n    for token in tokens:\n        if token in {\"or\", \"and\", \"with\", \"(\", \")\"}:\n            normalized_tokens.append(token.upper())\n            continue\n\n        if normalized_tokens and normalized_tokens[-1] == \"WITH\":\n            if token not in EXCEPTIONS:\n                message = f\"Unknown license exception: {token!r}\"\n                raise InvalidLicenseExpression(message)\n\n            normalized_tokens.append(EXCEPTIONS[token][\"id\"])\n        else:\n            if token.endswith(\"+\"):\n                final_token = token[:-1]\n                suffix = \"+\"\n            else:\n                final_token = token\n                suffix = \"\"\n\n            if final_token.startswith(\"licenseref-\"):\n                if not license_ref_allowed.match(final_token):\n                    message = f\"Invalid licenseref: {final_token!r}\"\n                    raise InvalidLicenseExpression(message)\n                normalized_tokens.append(license_refs[final_token] + suffix)\n            else:\n                if final_token not in LICENSES:\n                    message = f\"Unknown license: {final_token!r}\"\n                    raise InvalidLicenseExpression(message)\n                normalized_tokens.append(LICENSES[final_token][\"id\"] + suffix)\n\n    normalized_expression = \" \".join(normalized_tokens)\n\n    return cast(\n        NormalizedLicenseExpression,\n        normalized_expression.replace(\"( \", \"(\").replace(\" )\", \")\"),\n    )\n",
  "metadata": {},
  "relative_path": "venv_new\\Lib\\site-packages\\pip\\_vendor\\packaging\\licenses\\__init__.py",
  "id": "72fa4cb07c2d13398fb43bec4575fae4"
}