{
  "file_name": "requirements.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\venv_new\\Lib\\site-packages\\pip\\_internal\\resolution\\resolvelib\\requirements.py",
  "file_size": 8065,
  "created": "2025-12-01T01:58:31.377848",
  "modified": "2025-12-01T01:58:31.379221",
  "file_type": "code",
  "content_hash": "3ac646968193770054eef5ce0b299a4c",
  "content_type": "text",
  "content": "from typing import Any, Optional\n\nfrom pip._vendor.packaging.specifiers import SpecifierSet\nfrom pip._vendor.packaging.utils import NormalizedName, canonicalize_name\n\nfrom pip._internal.req.constructors import install_req_drop_extras\nfrom pip._internal.req.req_install import InstallRequirement\n\nfrom .base import Candidate, CandidateLookup, Requirement, format_name\n\n\nclass ExplicitRequirement(Requirement):\n    def __init__(self, candidate: Candidate) -> None:\n        self.candidate = candidate\n\n    def __str__(self) -> str:\n        return str(self.candidate)\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({self.candidate!r})\"\n\n    def __hash__(self) -> int:\n        return hash(self.candidate)\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, ExplicitRequirement):\n            return False\n        return self.candidate == other.candidate\n\n    @property\n    def project_name(self) -> NormalizedName:\n        # No need to canonicalize - the candidate did this\n        return self.candidate.project_name\n\n    @property\n    def name(self) -> str:\n        # No need to canonicalize - the candidate did this\n        return self.candidate.name\n\n    def format_for_error(self) -> str:\n        return self.candidate.format_for_error()\n\n    def get_candidate_lookup(self) -> CandidateLookup:\n        return self.candidate, None\n\n    def is_satisfied_by(self, candidate: Candidate) -> bool:\n        return candidate == self.candidate\n\n\nclass SpecifierRequirement(Requirement):\n    def __init__(self, ireq: InstallRequirement) -> None:\n        assert ireq.link is None, \"This is a link, not a specifier\"\n        self._ireq = ireq\n        self._equal_cache: Optional[str] = None\n        self._hash: Optional[int] = None\n        self._extras = frozenset(canonicalize_name(e) for e in self._ireq.extras)\n\n    @property\n    def _equal(self) -> str:\n        if self._equal_cache is not None:\n            return self._equal_cache\n\n        self._equal_cache = str(self._ireq)\n        return self._equal_cache\n\n    def __str__(self) -> str:\n        return str(self._ireq.req)\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({str(self._ireq.req)!r})\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, SpecifierRequirement):\n            return NotImplemented\n        return self._equal == other._equal\n\n    def __hash__(self) -> int:\n        if self._hash is not None:\n            return self._hash\n\n        self._hash = hash(self._equal)\n        return self._hash\n\n    @property\n    def project_name(self) -> NormalizedName:\n        assert self._ireq.req, \"Specifier-backed ireq is always PEP 508\"\n        return canonicalize_name(self._ireq.req.name)\n\n    @property\n    def name(self) -> str:\n        return format_name(self.project_name, self._extras)\n\n    def format_for_error(self) -> str:\n        # Convert comma-separated specifiers into \"A, B, ..., F and G\"\n        # This makes the specifier a bit more \"human readable\", without\n        # risking a change in meaning. (Hopefully! Not all edge cases have\n        # been checked)\n        parts = [s.strip() for s in str(self).split(\",\")]\n        if len(parts) == 0:\n            return \"\"\n        elif len(parts) == 1:\n            return parts[0]\n\n        return \", \".join(parts[:-1]) + \" and \" + parts[-1]\n\n    def get_candidate_lookup(self) -> CandidateLookup:\n        return None, self._ireq\n\n    def is_satisfied_by(self, candidate: Candidate) -> bool:\n        assert candidate.name == self.name, (\n            f\"Internal issue: Candidate is not for this requirement \"\n            f\"{candidate.name} vs {self.name}\"\n        )\n        # We can safely always allow prereleases here since PackageFinder\n        # already implements the prerelease logic, and would have filtered out\n        # prerelease candidates if the user does not expect them.\n        assert self._ireq.req, \"Specifier-backed ireq is always PEP 508\"\n        spec = self._ireq.req.specifier\n        return spec.contains(candidate.version, prereleases=True)\n\n\nclass SpecifierWithoutExtrasRequirement(SpecifierRequirement):\n    \"\"\"\n    Requirement backed by an install requirement on a base package.\n    Trims extras from its install requirement if there are any.\n    \"\"\"\n\n    def __init__(self, ireq: InstallRequirement) -> None:\n        assert ireq.link is None, \"This is a link, not a specifier\"\n        self._ireq = install_req_drop_extras(ireq)\n        self._equal_cache: Optional[str] = None\n        self._hash: Optional[int] = None\n        self._extras = frozenset(canonicalize_name(e) for e in self._ireq.extras)\n\n    @property\n    def _equal(self) -> str:\n        if self._equal_cache is not None:\n            return self._equal_cache\n\n        self._equal_cache = str(self._ireq)\n        return self._equal_cache\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, SpecifierWithoutExtrasRequirement):\n            return NotImplemented\n        return self._equal == other._equal\n\n    def __hash__(self) -> int:\n        if self._hash is not None:\n            return self._hash\n\n        self._hash = hash(self._equal)\n        return self._hash\n\n\nclass RequiresPythonRequirement(Requirement):\n    \"\"\"A requirement representing Requires-Python metadata.\"\"\"\n\n    def __init__(self, specifier: SpecifierSet, match: Candidate) -> None:\n        self.specifier = specifier\n        self._specifier_string = str(specifier)  # for faster __eq__\n        self._hash: Optional[int] = None\n        self._candidate = match\n\n    def __str__(self) -> str:\n        return f\"Python {self.specifier}\"\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({str(self.specifier)!r})\"\n\n    def __hash__(self) -> int:\n        if self._hash is not None:\n            return self._hash\n\n        self._hash = hash((self._specifier_string, self._candidate))\n        return self._hash\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, RequiresPythonRequirement):\n            return False\n        return (\n            self._specifier_string == other._specifier_string\n            and self._candidate == other._candidate\n        )\n\n    @property\n    def project_name(self) -> NormalizedName:\n        return self._candidate.project_name\n\n    @property\n    def name(self) -> str:\n        return self._candidate.name\n\n    def format_for_error(self) -> str:\n        return str(self)\n\n    def get_candidate_lookup(self) -> CandidateLookup:\n        if self.specifier.contains(self._candidate.version, prereleases=True):\n            return self._candidate, None\n        return None, None\n\n    def is_satisfied_by(self, candidate: Candidate) -> bool:\n        assert candidate.name == self._candidate.name, \"Not Python candidate\"\n        # We can safely always allow prereleases here since PackageFinder\n        # already implements the prerelease logic, and would have filtered out\n        # prerelease candidates if the user does not expect them.\n        return self.specifier.contains(candidate.version, prereleases=True)\n\n\nclass UnsatisfiableRequirement(Requirement):\n    \"\"\"A requirement that cannot be satisfied.\"\"\"\n\n    def __init__(self, name: NormalizedName) -> None:\n        self._name = name\n\n    def __str__(self) -> str:\n        return f\"{self._name} (unavailable)\"\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({str(self._name)!r})\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, UnsatisfiableRequirement):\n            return NotImplemented\n        return self._name == other._name\n\n    def __hash__(self) -> int:\n        return hash(self._name)\n\n    @property\n    def project_name(self) -> NormalizedName:\n        return self._name\n\n    @property\n    def name(self) -> str:\n        return self._name\n\n    def format_for_error(self) -> str:\n        return str(self)\n\n    def get_candidate_lookup(self) -> CandidateLookup:\n        return None, None\n\n    def is_satisfied_by(self, candidate: Candidate) -> bool:\n        return False\n",
  "metadata": {},
  "relative_path": "venv_new\\Lib\\site-packages\\pip\\_internal\\resolution\\resolvelib\\requirements.py",
  "id": "83e4bdea3fd7f11e76f4374422c1d81f"
}