{
  "file_name": "coverage_html_cb_437fc316.js",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\htmlcov\\coverage_html_cb_437fc316.js",
  "file_size": 26209,
  "created": "2025-12-04T11:42:40.435194",
  "modified": "2025-12-04T11:42:40.435194",
  "file_type": "code",
  "content_hash": "98c7becd39ec2fbfbbb15427887323e7",
  "content_type": "text",
  "content": "// Licensed under the Apache License: http://www.apache.org/licenses/LICENSE-2.0\n// For details: https://github.com/coveragepy/coveragepy/blob/main/NOTICE.txt\n\n// Coverage.py HTML report browser code.\n/*jslint browser: true, sloppy: true, vars: true, plusplus: true, maxerr: 50, indent: 4 */\n/*global coverage: true, document, window, $ */\n\ncoverage = {};\n\n// General helpers\nfunction debounce(callback, wait) {\n    let timeoutId = null;\n    return function(...args) {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() => {\n            callback.apply(this, args);\n        }, wait);\n    };\n};\n\nfunction checkVisible(element) {\n    const rect = element.getBoundingClientRect();\n    const viewBottom = Math.max(document.documentElement.clientHeight, window.innerHeight);\n    const viewTop = 30;\n    return !(rect.bottom < viewTop || rect.top >= viewBottom);\n}\n\nfunction on_click(sel, fn) {\n    const elt = document.querySelector(sel);\n    if (elt) {\n        elt.addEventListener(\"click\", fn);\n    }\n}\n\n// Helpers for table sorting\nfunction getCellValue(row, column = 0) {\n    const cell = row.cells[column]  // nosemgrep: eslint.detect-object-injection\n    if (cell.childElementCount == 1) {\n        var child = cell.firstElementChild;\n        if (child.tagName === \"A\") {\n            child = child.firstElementChild;\n        }\n        if (child instanceof HTMLDataElement && child.value) {\n            return child.value;\n        }\n    }\n    return cell.innerText || cell.textContent;\n}\n\nfunction rowComparator(rowA, rowB, column = 0) {\n    let valueA = getCellValue(rowA, column);\n    let valueB = getCellValue(rowB, column);\n    if (!isNaN(valueA) && !isNaN(valueB)) {\n        return valueA - valueB;\n    }\n    return valueA.localeCompare(valueB, undefined, {numeric: true});\n}\n\nfunction sortColumn(th) {\n    // Get the current sorting direction of the selected header,\n    // clear state on other headers and then set the new sorting direction.\n    const currentSortOrder = th.getAttribute(\"aria-sort\");\n    [...th.parentElement.cells].forEach(header => header.setAttribute(\"aria-sort\", \"none\"));\n    var direction;\n    if (currentSortOrder === \"none\") {\n        direction = th.dataset.defaultSortOrder || \"ascending\";\n    }\n    else if (currentSortOrder === \"ascending\") {\n        direction = \"descending\";\n    }\n    else {\n        direction = \"ascending\";\n    }\n    th.setAttribute(\"aria-sort\", direction);\n\n    const column = [...th.parentElement.cells].indexOf(th)\n\n    // Sort all rows and afterwards append them in order to move them in the DOM.\n    Array.from(th.closest(\"table\").querySelectorAll(\"tbody tr\"))\n        .sort((rowA, rowB) => rowComparator(rowA, rowB, column) * (direction === \"ascending\" ? 1 : -1))\n        .forEach(tr => tr.parentElement.appendChild(tr));\n\n    // Save the sort order for next time.\n    if (th.id !== \"region\") {\n        let th_id = \"file\";  // Sort by file if we don't have a column id\n        let current_direction = direction;\n        const stored_list = localStorage.getItem(coverage.INDEX_SORT_STORAGE);\n        if (stored_list) {\n            ({th_id, direction} = JSON.parse(stored_list))\n        }\n        localStorage.setItem(coverage.INDEX_SORT_STORAGE, JSON.stringify({\n            \"th_id\": th.id,\n            \"direction\": current_direction\n        }));\n        if (th.id !== th_id || document.getElementById(\"region\")) {\n            // Sort column has changed, unset sorting by function or class.\n            localStorage.setItem(coverage.SORTED_BY_REGION, JSON.stringify({\n                \"by_region\": false,\n                \"region_direction\": current_direction\n            }));\n        }\n    }\n    else {\n        // Sort column has changed to by function or class, remember that.\n        localStorage.setItem(coverage.SORTED_BY_REGION, JSON.stringify({\n            \"by_region\": true,\n            \"region_direction\": direction\n        }));\n    }\n}\n\n// Find all the elements with data-shortcut attribute, and use them to assign a shortcut key.\ncoverage.assign_shortkeys = function () {\n    document.querySelectorAll(\"[data-shortcut]\").forEach(element => {\n        document.addEventListener(\"keypress\", event => {\n            if (event.target.tagName.toLowerCase() === \"input\") {\n                return; // ignore keypress from search filter\n            }\n            if (event.key === element.dataset.shortcut) {\n                element.click();\n            }\n        });\n    });\n};\n\n// Create the events for the filter box.\ncoverage.wire_up_filter = function () {\n    // Populate the filter and hide100 inputs if there are saved values for them.\n    const saved_filter_value = localStorage.getItem(coverage.FILTER_STORAGE);\n    if (saved_filter_value) {\n        document.getElementById(\"filter\").value = saved_filter_value;\n    }\n    const saved_hide100_value = localStorage.getItem(coverage.HIDE100_STORAGE);\n    if (saved_hide100_value) {\n        document.getElementById(\"hide100\").checked = JSON.parse(saved_hide100_value);\n    }\n\n    // Cache elements.\n    const table = document.querySelector(\"table.index\");\n    const table_body_rows = table.querySelectorAll(\"tbody tr\");\n    const no_rows = document.getElementById(\"no_rows\");\n\n    // Observe filter keyevents.\n    const filter_handler = (event => {\n        // Keep running total of each metric, first index contains number of shown rows\n        const totals = new Array(table.rows[0].cells.length).fill(0);\n        // Accumulate the percentage as fraction\n        totals[totals.length - 1] = { \"numer\": 0, \"denom\": 0 };  // nosemgrep: eslint.detect-object-injection\n\n        var text = document.getElementById(\"filter\").value;\n        // Store filter value\n        localStorage.setItem(coverage.FILTER_STORAGE, text);\n        const casefold = (text === text.toLowerCase());\n        const hide100 = document.getElementById(\"hide100\").checked;\n        // Store hide value.\n        localStorage.setItem(coverage.HIDE100_STORAGE, JSON.stringify(hide100));\n\n        // Hide / show elements.\n        table_body_rows.forEach(row => {\n            var show = false;\n            // Check the text filter.\n            for (let column = 0; column < totals.length; column++) {\n                cell = row.cells[column];\n                if (cell.classList.contains(\"name\")) {\n                    var celltext = cell.textContent;\n                    if (casefold) {\n                        celltext = celltext.toLowerCase();\n                    }\n                    if (celltext.includes(text)) {\n                        show = true;\n                    }\n                }\n            }\n\n            // Check the \"hide covered\" filter.\n            if (show && hide100) {\n                const [numer, denom] = row.cells[row.cells.length - 1].dataset.ratio.split(\" \");\n                show = (numer !== denom);\n            }\n\n            if (!show) {\n                // hide\n                row.classList.add(\"hidden\");\n                return;\n            }\n\n            // show\n            row.classList.remove(\"hidden\");\n            totals[0]++;\n\n            for (let column = 0; column < totals.length; column++) {\n                // Accumulate dynamic totals\n                cell = row.cells[column]  // nosemgrep: eslint.detect-object-injection\n                if (cell.classList.contains(\"name\")) {\n                    continue;\n                }\n                if (column === totals.length - 1) {\n                    // Last column contains percentage\n                    const [numer, denom] = cell.dataset.ratio.split(\" \");\n                    totals[column][\"numer\"] += parseInt(numer, 10);  // nosemgrep: eslint.detect-object-injection\n                    totals[column][\"denom\"] += parseInt(denom, 10);  // nosemgrep: eslint.detect-object-injection\n                }\n                else {\n                    totals[column] += parseInt(cell.textContent, 10);  // nosemgrep: eslint.detect-object-injection\n                }\n            }\n        });\n\n        // Show placeholder if no rows will be displayed.\n        if (!totals[0]) {\n            // Show placeholder, hide table.\n            no_rows.style.display = \"block\";\n            table.style.display = \"none\";\n            return;\n        }\n\n        // Hide placeholder, show table.\n        no_rows.style.display = null;\n        table.style.display = null;\n\n        const footer = table.tFoot.rows[0];\n        // Calculate new dynamic sum values based on visible rows.\n        for (let column = 0; column < totals.length; column++) {\n            // Get footer cell element.\n            const cell = footer.cells[column];  // nosemgrep: eslint.detect-object-injection\n            if (cell.classList.contains(\"name\")) {\n                continue;\n            }\n\n            // Set value into dynamic footer cell element.\n            if (column === totals.length - 1) {\n                // Percentage column uses the numerator and denominator,\n                // and adapts to the number of decimal places.\n                const match = /\\.([0-9]+)/.exec(cell.textContent);\n                const places = match ? match[1].length : 0;\n                const { numer, denom } = totals[column];  // nosemgrep: eslint.detect-object-injection\n                cell.dataset.ratio = `${numer} ${denom}`;\n                // Check denom to prevent NaN if filtered files contain no statements\n                cell.textContent = denom\n                    ? `${(numer * 100 / denom).toFixed(places)}%`\n                    : `${(100).toFixed(places)}%`;\n            }\n            else {\n                cell.textContent = totals[column];  // nosemgrep: eslint.detect-object-injection\n            }\n        }\n    });\n\n    document.getElementById(\"filter\").addEventListener(\"input\", debounce(filter_handler));\n    document.getElementById(\"hide100\").addEventListener(\"input\", debounce(filter_handler));\n\n    // Trigger change event on setup, to force filter on page refresh\n    // (filter value may still be present).\n    document.getElementById(\"filter\").dispatchEvent(new Event(\"input\"));\n    document.getElementById(\"hide100\").dispatchEvent(new Event(\"input\"));\n};\ncoverage.FILTER_STORAGE = \"COVERAGE_FILTER_VALUE\";\ncoverage.HIDE100_STORAGE = \"COVERAGE_HIDE100_VALUE\";\n\n// Set up the click-to-sort columns.\ncoverage.wire_up_sorting = function () {\n    document.querySelectorAll(\"[data-sortable] th[aria-sort]\").forEach(\n        th => th.addEventListener(\"click\", e => sortColumn(e.target))\n    );\n\n    // Look for a localStorage item containing previous sort settings:\n    let th_id = \"file\", direction = \"ascending\";\n    const stored_list = localStorage.getItem(coverage.INDEX_SORT_STORAGE);\n    if (stored_list) {\n        ({th_id, direction} = JSON.parse(stored_list));\n    }\n    let by_region = false, region_direction = \"ascending\";\n    const sorted_by_region = localStorage.getItem(coverage.SORTED_BY_REGION);\n    if (sorted_by_region) {\n        ({\n            by_region,\n            region_direction\n        } = JSON.parse(sorted_by_region));\n    }\n\n    const region_id = \"region\";\n    if (by_region && document.getElementById(region_id)) {\n        direction = region_direction;\n    }\n    // If we are in a page that has a column with id of \"region\", sort on\n    // it if the last sort was by function or class.\n    let th;\n    if (document.getElementById(region_id)) {\n        th = document.getElementById(by_region ? region_id : th_id);\n    }\n    else {\n        th = document.getElementById(th_id);\n    }\n    th.setAttribute(\"aria-sort\", direction === \"ascending\" ? \"descending\" : \"ascending\");\n    th.click()\n};\n\ncoverage.INDEX_SORT_STORAGE = \"COVERAGE_INDEX_SORT_2\";\ncoverage.SORTED_BY_REGION = \"COVERAGE_SORT_REGION\";\n\n// Loaded on index.html\ncoverage.index_ready = function () {\n    coverage.assign_shortkeys();\n    coverage.wire_up_filter();\n    coverage.wire_up_sorting();\n\n    on_click(\".button_prev_file\", coverage.to_prev_file);\n    on_click(\".button_next_file\", coverage.to_next_file);\n\n    on_click(\".button_show_hide_help\", coverage.show_hide_help);\n};\n\n// -- pyfile stuff --\n\ncoverage.LINE_FILTERS_STORAGE = \"COVERAGE_LINE_FILTERS\";\n\ncoverage.pyfile_ready = function () {\n    // If we're directed to a particular line number, highlight the line.\n    var frag = location.hash;\n    if (frag.length > 2 && frag[1] === \"t\") {\n        document.querySelector(frag).closest(\".n\").classList.add(\"highlight\");\n        coverage.set_sel(parseInt(frag.substr(2), 10));\n    }\n    else {\n        coverage.set_sel(0);\n    }\n\n    on_click(\".button_toggle_run\", coverage.toggle_lines);\n    on_click(\".button_toggle_mis\", coverage.toggle_lines);\n    on_click(\".button_toggle_exc\", coverage.toggle_lines);\n    on_click(\".button_toggle_par\", coverage.toggle_lines);\n\n    on_click(\".button_next_chunk\", coverage.to_next_chunk_nicely);\n    on_click(\".button_prev_chunk\", coverage.to_prev_chunk_nicely);\n    on_click(\".button_top_of_page\", coverage.to_top);\n    on_click(\".button_first_chunk\", coverage.to_first_chunk);\n\n    on_click(\".button_prev_file\", coverage.to_prev_file);\n    on_click(\".button_next_file\", coverage.to_next_file);\n    on_click(\".button_to_index\", coverage.to_index);\n\n    on_click(\".button_show_hide_help\", coverage.show_hide_help);\n\n    coverage.filters = undefined;\n    try {\n        coverage.filters = localStorage.getItem(coverage.LINE_FILTERS_STORAGE);\n    } catch(err) {}\n\n    if (coverage.filters) {\n        coverage.filters = JSON.parse(coverage.filters);\n    }\n    else {\n        coverage.filters = {run: false, exc: true, mis: true, par: true};\n    }\n\n    for (cls in coverage.filters) {\n        coverage.set_line_visibilty(cls, coverage.filters[cls]);  // nosemgrep: eslint.detect-object-injection\n    }\n\n    coverage.assign_shortkeys();\n    coverage.init_scroll_markers();\n    coverage.wire_up_sticky_header();\n\n    document.querySelectorAll(\"[id^=ctxs]\").forEach(\n        cbox => cbox.addEventListener(\"click\", coverage.expand_contexts)\n    );\n\n    // Rebuild scroll markers when the window height changes.\n    window.addEventListener(\"resize\", coverage.build_scroll_markers);\n};\n\ncoverage.toggle_lines = function (event) {\n    const btn = event.target.closest(\"button\");\n    const category = btn.value\n    const show = !btn.classList.contains(\"show_\" + category);\n    coverage.set_line_visibilty(category, show);\n    coverage.build_scroll_markers();\n    coverage.filters[category] = show;\n    try {\n        localStorage.setItem(coverage.LINE_FILTERS_STORAGE, JSON.stringify(coverage.filters));\n    } catch(err) {}\n};\n\ncoverage.set_line_visibilty = function (category, should_show) {\n    const cls = \"show_\" + category;\n    const btn = document.querySelector(\".button_toggle_\" + category);\n    if (btn) {\n        if (should_show) {\n            document.querySelectorAll(\"#source .\" + category).forEach(e => e.classList.add(cls));\n            btn.classList.add(cls);\n        }\n        else {\n            document.querySelectorAll(\"#source .\" + category).forEach(e => e.classList.remove(cls));\n            btn.classList.remove(cls);\n        }\n    }\n};\n\n// Return the nth line div.\ncoverage.line_elt = function (n) {\n    return document.getElementById(\"t\" + n)?.closest(\"p\");\n};\n\n// Set the selection.  b and e are line numbers.\ncoverage.set_sel = function (b, e) {\n    // The first line selected.\n    coverage.sel_begin = b;\n    // The next line not selected.\n    coverage.sel_end = (e === undefined) ? b+1 : e;\n};\n\ncoverage.to_top = function () {\n    coverage.set_sel(0, 1);\n    coverage.scroll_window(0);\n};\n\ncoverage.to_first_chunk = function () {\n    coverage.set_sel(0, 1);\n    coverage.to_next_chunk();\n};\n\ncoverage.to_prev_file = function () {\n    window.location = document.getElementById(\"prevFileLink\").href;\n}\n\ncoverage.to_next_file = function () {\n    window.location = document.getElementById(\"nextFileLink\").href;\n}\n\ncoverage.to_index = function () {\n    location.href = document.getElementById(\"indexLink\").href;\n}\n\ncoverage.show_hide_help = function () {\n    const helpCheck = document.getElementById(\"help_panel_state\")\n    helpCheck.checked = !helpCheck.checked;\n}\n\n// Return a string indicating what kind of chunk this line belongs to,\n// or null if not a chunk.\ncoverage.chunk_indicator = function (line_elt) {\n    const classes = line_elt?.className;\n    if (!classes) {\n        return null;\n    }\n    const match = classes.match(/\\bshow_\\w+\\b/);\n    if (!match) {\n        return null;\n    }\n    return match[0];\n};\n\ncoverage.to_next_chunk = function () {\n    const c = coverage;\n\n    // Find the start of the next colored chunk.\n    var probe = c.sel_end;\n    var chunk_indicator, probe_line;\n    while (true) {\n        probe_line = c.line_elt(probe);\n        if (!probe_line) {\n            return;\n        }\n        chunk_indicator = c.chunk_indicator(probe_line);\n        if (chunk_indicator) {\n            break;\n        }\n        probe++;\n    }\n\n    // There's a next chunk, `probe` points to it.\n    var begin = probe;\n\n    // Find the end of this chunk.\n    var next_indicator = chunk_indicator;\n    while (next_indicator === chunk_indicator) {\n        probe++;\n        probe_line = c.line_elt(probe);\n        next_indicator = c.chunk_indicator(probe_line);\n    }\n    c.set_sel(begin, probe);\n    c.show_selection();\n};\n\ncoverage.to_prev_chunk = function () {\n    const c = coverage;\n\n    // Find the end of the prev colored chunk.\n    var probe = c.sel_begin-1;\n    var probe_line = c.line_elt(probe);\n    if (!probe_line) {\n        return;\n    }\n    var chunk_indicator = c.chunk_indicator(probe_line);\n    while (probe > 1 && !chunk_indicator) {\n        probe--;\n        probe_line = c.line_elt(probe);\n        if (!probe_line) {\n            return;\n        }\n        chunk_indicator = c.chunk_indicator(probe_line);\n    }\n\n    // There's a prev chunk, `probe` points to its last line.\n    var end = probe+1;\n\n    // Find the beginning of this chunk.\n    var prev_indicator = chunk_indicator;\n    while (prev_indicator === chunk_indicator) {\n        probe--;\n        if (probe <= 0) {\n            return;\n        }\n        probe_line = c.line_elt(probe);\n        prev_indicator = c.chunk_indicator(probe_line);\n    }\n    c.set_sel(probe+1, end);\n    c.show_selection();\n};\n\n// Returns 0, 1, or 2: how many of the two ends of the selection are on\n// the screen right now?\ncoverage.selection_ends_on_screen = function () {\n    if (coverage.sel_begin === 0) {\n        return 0;\n    }\n\n    const begin = coverage.line_elt(coverage.sel_begin);\n    const end = coverage.line_elt(coverage.sel_end-1);\n\n    return (\n        (checkVisible(begin) ? 1 : 0)\n        + (checkVisible(end) ? 1 : 0)\n    );\n};\n\ncoverage.to_next_chunk_nicely = function () {\n    if (coverage.selection_ends_on_screen() === 0) {\n        // The selection is entirely off the screen:\n        // Set the top line on the screen as selection.\n\n        // This will select the top-left of the viewport\n        // As this is most likely the span with the line number we take the parent\n        const line = document.elementFromPoint(0, 0).parentElement;\n        if (line.parentElement !== document.getElementById(\"source\")) {\n            // The element is not a source line but the header or similar\n            coverage.select_line_or_chunk(1);\n        }\n        else {\n            // We extract the line number from the id\n            coverage.select_line_or_chunk(parseInt(line.id.substring(1), 10));\n        }\n    }\n    coverage.to_next_chunk();\n};\n\ncoverage.to_prev_chunk_nicely = function () {\n    if (coverage.selection_ends_on_screen() === 0) {\n        // The selection is entirely off the screen:\n        // Set the lowest line on the screen as selection.\n\n        // This will select the bottom-left of the viewport\n        // As this is most likely the span with the line number we take the parent\n        const line = document.elementFromPoint(document.documentElement.clientHeight-1, 0).parentElement;\n        if (line.parentElement !== document.getElementById(\"source\")) {\n            // The element is not a source line but the header or similar\n            coverage.select_line_or_chunk(coverage.lines_len);\n        }\n        else {\n            // We extract the line number from the id\n            coverage.select_line_or_chunk(parseInt(line.id.substring(1), 10));\n        }\n    }\n    coverage.to_prev_chunk();\n};\n\n// Select line number lineno, or if it is in a colored chunk, select the\n// entire chunk\ncoverage.select_line_or_chunk = function (lineno) {\n    var c = coverage;\n    var probe_line = c.line_elt(lineno);\n    if (!probe_line) {\n        return;\n    }\n    var the_indicator = c.chunk_indicator(probe_line);\n    if (the_indicator) {\n        // The line is in a highlighted chunk.\n        // Search backward for the first line.\n        var probe = lineno;\n        var indicator = the_indicator;\n        while (probe > 0 && indicator === the_indicator) {\n            probe--;\n            probe_line = c.line_elt(probe);\n            if (!probe_line) {\n                break;\n            }\n            indicator = c.chunk_indicator(probe_line);\n        }\n        var begin = probe + 1;\n\n        // Search forward for the last line.\n        probe = lineno;\n        indicator = the_indicator;\n        while (indicator === the_indicator) {\n            probe++;\n            probe_line = c.line_elt(probe);\n            indicator = c.chunk_indicator(probe_line);\n        }\n\n        coverage.set_sel(begin, probe);\n    }\n    else {\n        coverage.set_sel(lineno);\n    }\n};\n\ncoverage.show_selection = function () {\n    // Highlight the lines in the chunk\n    document.querySelectorAll(\"#source .highlight\").forEach(e => e.classList.remove(\"highlight\"));\n    for (let probe = coverage.sel_begin; probe < coverage.sel_end; probe++) {\n        coverage.line_elt(probe).querySelector(\".n\").classList.add(\"highlight\");\n    }\n\n    coverage.scroll_to_selection();\n};\n\ncoverage.scroll_to_selection = function () {\n    // Scroll the page if the chunk isn't fully visible.\n    if (coverage.selection_ends_on_screen() < 2) {\n        const element = coverage.line_elt(coverage.sel_begin);\n        coverage.scroll_window(element.offsetTop - 60);\n    }\n};\n\ncoverage.scroll_window = function (to_pos) {\n    window.scroll({top: to_pos, behavior: \"smooth\"});\n};\n\ncoverage.init_scroll_markers = function () {\n    // Init some variables\n    coverage.lines_len = document.querySelectorAll(\"#source > p\").length;\n\n    // Build html\n    coverage.build_scroll_markers();\n};\n\ncoverage.build_scroll_markers = function () {\n    const temp_scroll_marker = document.getElementById(\"scroll_marker\")\n    if (temp_scroll_marker) temp_scroll_marker.remove();\n    // Don't build markers if the window has no scroll bar.\n    if (document.body.scrollHeight <= window.innerHeight) {\n        return;\n    }\n\n    const marker_scale = window.innerHeight / document.body.scrollHeight;\n    const line_height = Math.min(Math.max(3, window.innerHeight / coverage.lines_len), 10);\n\n    let previous_line = -99, last_mark, last_top;\n\n    const scroll_marker = document.createElement(\"div\");\n    scroll_marker.id = \"scroll_marker\";\n    document.getElementById(\"source\").querySelectorAll(\n        \"p.show_run, p.show_mis, p.show_exc, p.show_exc, p.show_par\"\n    ).forEach(element => {\n        const line_top = Math.floor(element.offsetTop * marker_scale);\n        const line_number = parseInt(element.querySelector(\".n a\").id.substr(1));\n\n        if (line_number === previous_line + 1) {\n            // If this solid missed block just make previous mark higher.\n            last_mark.style.height = `${line_top + line_height - last_top}px`;\n        }\n        else {\n            // Add colored line in scroll_marker block.\n            last_mark = document.createElement(\"div\");\n            last_mark.id = `m${line_number}`;\n            last_mark.classList.add(\"marker\");\n            last_mark.style.height = `${line_height}px`;\n            last_mark.style.top = `${line_top}px`;\n            scroll_marker.append(last_mark);\n            last_top = line_top;\n        }\n\n        previous_line = line_number;\n    });\n\n    // Append last to prevent layout calculation\n    document.body.append(scroll_marker);\n};\n\ncoverage.wire_up_sticky_header = function () {\n    const header = document.querySelector(\"header\");\n    const header_bottom = (\n        header.querySelector(\".content h2\").getBoundingClientRect().top -\n        header.getBoundingClientRect().top\n    );\n\n    function updateHeader() {\n        if (window.scrollY > header_bottom) {\n            header.classList.add(\"sticky\");\n        }\n        else {\n            header.classList.remove(\"sticky\");\n        }\n    }\n\n    window.addEventListener(\"scroll\", updateHeader);\n    updateHeader();\n};\n\ncoverage.expand_contexts = function (e) {\n    var ctxs = e.target.parentNode.querySelector(\".ctxs\");\n\n    if (!ctxs.classList.contains(\"expanded\")) {\n        var ctxs_text = ctxs.textContent;\n        var width = Number(ctxs_text[0]);\n        ctxs.textContent = \"\";\n        for (var i = 1; i < ctxs_text.length; i += width) {\n            key = ctxs_text.substring(i, i + width).trim();\n            ctxs.appendChild(document.createTextNode(contexts[key]));\n            ctxs.appendChild(document.createElement(\"br\"));\n        }\n        ctxs.classList.add(\"expanded\");\n    }\n};\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    if (document.body.classList.contains(\"indexfile\")) {\n        coverage.index_ready();\n    }\n    else {\n        coverage.pyfile_ready();\n    }\n});\n",
  "metadata": {},
  "relative_path": "htmlcov\\coverage_html_cb_437fc316.js",
  "id": "b429b150bb2b10f0fc7922cd78eace6e"
}