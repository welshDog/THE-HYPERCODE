{
  "file_name": "spatial-visualizer.ts",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\src\\src\\spatial-visualizer.ts",
  "file_size": 9674,
  "created": "2025-11-23T12:01:48.536566",
  "modified": "2025-11-23T12:01:48.536566",
  "file_type": "code",
  "content_hash": "0abf11ec888bfe31bd38c0a6b7c65a95",
  "content_type": "text",
  "content": "import * as d3 from 'd3';\nimport { CodeAnalysis, CodeNode } from './code-analyzer';\n\nexport interface VisualizationMode {\n  type: 'mindmap' | 'force-directed' | 'hierarchical' | 'radial';\n  minimalNoise: boolean;\n  highContrast: boolean;\n}\n\nexport class SpatialVisualizer {\n  private mode: VisualizationMode = {\n    type: 'mindmap',\n    minimalNoise: true,\n    highContrast: false\n  };\n\n  private colorScheme = {\n    function: '#6366f1',      // indigo\n    class: '#ec4899',          // pink\n    variable: '#10b981',       // emerald\n    import: '#f59e0b',         // amber\n    interface: '#8b5cf6',      // violet\n    link: '#d1d5db',           // gray\n    background: '#ffffff',\n    text: '#111827'\n  };\n\n  /**\n   * Generate SVG visualization from code analysis\n   */\n  generateVisualization(analysis: CodeAnalysis): SVGElement {\n    const svg = d3.create('svg')\n      .attr('viewBox', [0, 0, 1200, 800])\n      .attr('style', 'max-width: 100%; height: auto; background: white;');\n\n    if (this.mode.type === 'mindmap') {\n      this.renderMindMap(svg, analysis);\n    } else if (this.mode.type === 'force-directed') {\n      this.renderForceDirected(svg, analysis);\n    } else if (this.mode.type === 'hierarchical') {\n      this.renderHierarchical(svg, analysis);\n    } else if (this.mode.type === 'radial') {\n      this.renderRadial(svg, analysis);\n    }\n\n    return svg.node() as SVGElement;\n  }\n\n  private renderMindMap(svg: d3.Selection<SVGSVGElement, unknown, HTMLElement, unknown>, analysis: CodeAnalysis) {\n    const nodeRadius = 30;\n    const width = 1200;\n    const height = 800;\n\n    // Center node (file/module)\n    svg.append('circle')\n      .attr('cx', width / 2)\n      .attr('cy', height / 2)\n      .attr('r', nodeRadius + 10)\n      .attr('fill', '#fbbf24')\n      .attr('opacity', 0.9);\n\n    svg.append('text')\n      .attr('x', width / 2)\n      .attr('y', height / 2)\n      .attr('text-anchor', 'middle')\n      .attr('dy', '0.3em')\n      .attr('font-size', '12px')\n      .attr('font-weight', 'bold')\n      .attr('fill', '#000')\n      .text('Code');\n\n    // Arrange nodes in concentric circles\n    const nodesByType = this.groupNodesByType(analysis.nodes);\n    let angleOffset = 0;\n    let radiusOffset = 150;\n\n    Object.entries(nodesByType).forEach(([type, nodes]) => {\n      const angleStep = (Math.PI * 2) / nodes.length;\n\n      nodes.forEach((node, idx) => {\n        const angle = angleOffset + idx * angleStep;\n        const x = width / 2 + radiusOffset * Math.cos(angle);\n        const y = height / 2 + radiusOffset * Math.sin(angle);\n\n        // Draw edge from center\n        svg.append('line')\n          .attr('x1', width / 2)\n          .attr('y1', height / 2)\n          .attr('x2', x)\n          .attr('y2', y)\n          .attr('stroke', this.colorScheme.link)\n          .attr('stroke-width', 2)\n          .attr('opacity', 0.5);\n\n        // Draw node\n        svg.append('circle')\n          .attr('cx', x)\n          .attr('cy', y)\n          .attr('r', nodeRadius)\n          .attr('fill', this.colorScheme[node.type as keyof typeof this.colorScheme])\n          .attr('opacity', 0.8)\n          .attr('cursor', 'pointer');\n\n        // Node label\n        svg.append('text')\n          .attr('x', x)\n          .attr('y', y)\n          .attr('text-anchor', 'middle')\n          .attr('dy', '0.3em')\n          .attr('font-size', '10px')\n          .attr('font-weight', 'bold')\n          .attr('fill', '#fff')\n          .text(node.name.substring(0, 8))\n          .attr('pointer-events', 'none');\n\n        // Cognitive load indicator (ring)\n        const ringOpacity = node.cognitiveLoad / 10;\n        svg.append('circle')\n          .attr('cx', x)\n          .attr('cy', y)\n          .attr('r', nodeRadius + 5)\n          .attr('fill', 'none')\n          .attr('stroke', '#ef4444')\n          .attr('stroke-width', 2)\n          .attr('opacity', ringOpacity);\n      });\n\n      radiusOffset += 100;\n    });\n\n    // Add cognitive load legend\n    this.addLegend(svg, analysis);\n  }\n\n  private renderForceDirected(svg: d3.Selection<SVGSVGElement, unknown, HTMLElement, unknown>, analysis: CodeAnalysis) {\n    const width = 1200;\n    const height = 800;\n\n    const simulation = d3.forceSimulation(analysis.nodes)\n      .force('link', d3.forceLink<CodeNode, any>()\n        .id((d: CodeNode) => d.name)\n        .distance(100))\n      .force('charge', d3.forceManyBody().strength(-300))\n      .force('center', d3.forceCenter(width / 2, height / 2))\n      .force('collision', d3.forceCollide(40));\n\n    // Render links\n    svg.selectAll('line')\n      .data(analysis.relationships)\n      .enter()\n      .append('line')\n      .attr('stroke', this.colorScheme.link)\n      .attr('stroke-width', 2)\n      .attr('opacity', 0.5);\n\n    // Render nodes\n    const nodes = svg.selectAll('circle')\n      .data(analysis.nodes)\n      .enter()\n      .append('circle')\n      .attr('r', (d: CodeNode) => 30 + d.complexity * 5)\n      .attr('fill', (d: CodeNode) => this.colorScheme[d.type as keyof typeof this.colorScheme])\n      .attr('opacity', 0.8);\n\n    // Labels\n    svg.selectAll('text')\n      .data(analysis.nodes)\n      .enter()\n      .append('text')\n      .attr('text-anchor', 'middle')\n      .attr('dy', '0.3em')\n      .attr('font-size', '10px')\n      .attr('fill', '#fff')\n      .text((d: CodeNode) => d.name.substring(0, 10));\n\n    simulation.on('tick', () => {\n      nodes.attr('cx', (d: any) => d.x).attr('cy', (d: any) => d.y);\n    });\n  }\n\n  private renderHierarchical(svg: d3.Selection<SVGSVGElement, unknown, HTMLElement, unknown>, analysis: CodeAnalysis) {\n    const width = 1200;\n    const height = 800;\n    const depth = 3;\n\n    const nodesByDepth: CodeNode[][] = [[], [], []];\n    analysis.nodes.forEach((node, idx) => {\n      nodesByDepth[idx % depth].push(node);\n    });\n\n    nodesByDepth.forEach((nodesAtDepth, depthIdx) => {\n      const xSpacing = width / (nodesAtDepth.length + 1);\n      const y = 100 + depthIdx * 300;\n\n      nodesAtDepth.forEach((node, idx) => {\n        const x = xSpacing * (idx + 1);\n\n        svg.append('circle')\n          .attr('cx', x)\n          .attr('cy', y)\n          .attr('r', 30)\n          .attr('fill', this.colorScheme[node.type as keyof typeof this.colorScheme])\n          .attr('opacity', 0.8);\n\n        svg.append('text')\n          .attr('x', x)\n          .attr('y', y)\n          .attr('text-anchor', 'middle')\n          .attr('dy', '0.3em')\n          .attr('font-size', '10px')\n          .attr('fill', '#fff')\n          .text(node.name.substring(0, 8));\n      });\n    });\n\n    this.addLegend(svg, analysis);\n  }\n\n  private renderRadial(svg: d3.Selection<SVGSVGElement, unknown, HTMLElement, unknown>, analysis: CodeAnalysis) {\n    const width = 1200;\n    const height = 800;\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    const angleStep = (Math.PI * 2) / analysis.nodes.length;\n    const radius = 300;\n\n    analysis.nodes.forEach((node, idx) => {\n      const angle = idx * angleStep;\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n\n      svg.append('line')\n        .attr('x1', centerX)\n        .attr('y1', centerY)\n        .attr('x2', x)\n        .attr('y2', y)\n        .attr('stroke', this.colorScheme.link)\n        .attr('stroke-width', 1)\n        .attr('opacity', 0.3);\n\n      svg.append('circle')\n        .attr('cx', x)\n        .attr('cy', y)\n        .attr('r', 30)\n        .attr('fill', this.colorScheme[node.type as keyof typeof this.colorScheme])\n        .attr('opacity', 0.8);\n\n      svg.append('text')\n        .attr('x', x)\n        .attr('y', y)\n        .attr('text-anchor', 'middle')\n        .attr('dy', '0.3em')\n        .attr('font-size', '10px')\n        .attr('fill', '#fff')\n        .text(node.name.substring(0, 8));\n    });\n\n    this.addLegend(svg, analysis);\n  }\n\n  private groupNodesByType(nodes: CodeNode[]): Record<string, CodeNode[]> {\n    return nodes.reduce((acc, node) => {\n      if (!acc[node.type]) acc[node.type] = [];\n      acc[node.type].push(node);\n      return acc;\n    }, {} as Record<string, CodeNode[]>);\n  }\n\n  private addLegend(svg: d3.Selection<SVGSVGElement, unknown, HTMLElement, unknown>, analysis: CodeAnalysis) {\n    const legendX = 20;\n    const legendY = 20;\n    const itemHeight = 25;\n\n    svg.append('text')\n      .attr('x', legendX)\n      .attr('y', legendY)\n      .attr('font-size', '12px')\n      .attr('font-weight', 'bold')\n      .text(`Cognitive Load: ${analysis.cognitiveLoadScore.toFixed(1)}/10`);\n\n    Object.entries(this.colorScheme).slice(0, 5).forEach(([type, color], idx) => {\n      if (type === 'function' || type === 'class' || type === 'variable') {\n        svg.append('circle')\n          .attr('cx', legendX + 10)\n          .attr('cy', legendY + 30 + idx * itemHeight)\n          .attr('r', 6)\n          .attr('fill', color);\n\n        svg.append('text')\n          .attr('x', legendX + 25)\n          .attr('y', legendY + 35 + idx * itemHeight)\n          .attr('font-size', '11px')\n          .text(type);\n      }\n    });\n  }\n\n  toggleMode() {\n    const modes: VisualizationMode['type'][] = ['mindmap', 'force-directed', 'hierarchical', 'radial'];\n    const currentIdx = modes.indexOf(this.mode.type);\n    this.mode.type = modes[(currentIdx + 1) % modes.length];\n  }\n\n  updateOnChange() {\n    // Debounced re-render trigger\n    console.log('ðŸ“Š Code changed, visualization will update');\n  }\n}\n",
  "metadata": {},
  "relative_path": "src\\src\\spatial-visualizer.ts",
  "id": "39b929b112bdd1c0313a6ec288198079"
}