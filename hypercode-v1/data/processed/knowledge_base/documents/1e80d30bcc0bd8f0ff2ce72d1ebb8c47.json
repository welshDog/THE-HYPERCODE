{
  "file_name": "database.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\live_research\\database.py",
  "file_size": 9502,
  "created": "2025-12-04T12:43:22.859925",
  "modified": "2025-12-04T12:43:25.481198",
  "file_type": "code",
  "content_hash": "3be01ed63a0fba0d543a414d5b905888",
  "content_type": "text",
  "content": "import sqlite3\nfrom pathlib import Path\nfrom typing import List, Dict, Any, Optional\nimport json\n\n\nclass ResearchDatabase:\n    def __init__(self, db_path: str = \"research.db\"):\n        \"\"\"Initialize the database connection and create tables if they don't exist.\"\"\"\n        self.db_path = db_path\n        self._create_tables()\n\n    def _get_connection(self):\n        \"\"\"Create and return a database connection.\"\"\"\n        return sqlite3.connect(self.db_path)\n\n    def _create_tables(self):\n        \"\"\"Create the necessary tables if they don't exist.\"\"\"\n        with self._get_connection() as conn:\n            cursor = conn.cursor()\n\n            # Research entries table\n            cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS research_entries (\n                id TEXT PRIMARY KEY,\n                date TEXT NOT NULL,\n                topic TEXT NOT NULL,\n                source TEXT,\n                summary TEXT,\n                details TEXT,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n            \"\"\")\n\n            # Tags table\n            cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS tags (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT UNIQUE NOT NULL\n            )\n            \"\"\")\n\n            # Research entry tags junction table\n            cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS research_entry_tags (\n                entry_id TEXT,\n                tag_id INTEGER,\n                PRIMARY KEY (entry_id, tag_id),\n                FOREIGN KEY (entry_id) REFERENCES research_entries(id) ON DELETE CASCADE,\n                FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE\n            )\n            \"\"\")\n\n            # Create triggers for updated_at\n            cursor.execute(\"\"\"\n            CREATE TRIGGER IF NOT EXISTS update_research_entries_timestamp\n            AFTER UPDATE ON research_entries\n            FOR EACH ROW\n            BEGIN\n                UPDATE research_entries SET updated_at = CURRENT_TIMESTAMP\n                WHERE id = OLD.id;\n            END;\n            \"\"\")\n\n            conn.commit()\n\n    def add_research_entry(self, entry_data: Dict[str, Any]) -> bool:\n        \"\"\"Add a new research entry to the database.\"\"\"\n        required_fields = [\"id\", \"date\", \"topic\"]\n        if not all(field in entry_data for field in required_fields):\n            raise ValueError(f\"Missing required fields. Required: {required_fields}\")\n\n        with self._get_connection() as conn:\n            cursor = conn.cursor()\n\n            try:\n                # Insert or replace research entry\n                cursor.execute(\n                    \"\"\"\n                INSERT OR REPLACE INTO research_entries \n                (id, date, topic, source, summary, details)\n                VALUES (?, ?, ?, ?, ?, ?)\n                \"\"\",\n                    (\n                        entry_data[\"id\"],\n                        entry_data[\"date\"],\n                        entry_data[\"topic\"],\n                        entry_data.get(\"source\", \"\"),\n                        entry_data.get(\"summary\", \"\"),\n                        entry_data.get(\"details\", \"\"),\n                    ),\n                )\n\n                # Handle tags\n                if \"tags\" in entry_data and isinstance(entry_data[\"tags\"], list):\n                    for tag_name in entry_data[\"tags\"]:\n                        # Insert tag if it doesn't exist\n                        cursor.execute(\n                            \"\"\"\n                        INSERT OR IGNORE INTO tags (name) VALUES (?)\n                        \"\"\",\n                            (tag_name,),\n                        )\n\n                        # Get tag ID\n                        cursor.execute(\n                            \"SELECT id FROM tags WHERE name = ?\", (tag_name,)\n                        )\n                        tag_id = cursor.fetchone()[0]\n\n                        # Link tag to research entry\n                        cursor.execute(\n                            \"\"\"\n                        INSERT OR IGNORE INTO research_entry_tags (entry_id, tag_id)\n                        VALUES (?, ?)\n                        \"\"\",\n                            (entry_data[\"id\"], tag_id),\n                        )\n\n                conn.commit()\n                return True\n\n            except sqlite3.Error as e:\n                print(f\"Database error: {e}\")\n                return False\n\n    def get_research_entry(self, entry_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Retrieve a research entry by its ID.\"\"\"\n        with self._get_connection() as conn:\n            conn.row_factory = sqlite3.Row\n            cursor = conn.cursor()\n\n            cursor.execute(\n                \"\"\"\n            SELECT * FROM research_entries WHERE id = ?\n            \"\"\",\n                (entry_id,),\n            )\n\n            entry = cursor.fetchone()\n            if not entry:\n                return None\n\n            # Get tags for this entry\n            cursor.execute(\n                \"\"\"\n            SELECT t.name FROM tags t\n            JOIN research_entry_tags ret ON t.id = ret.tag_id\n            WHERE ret.entry_id = ?\n            \"\"\",\n                (entry_id,),\n            )\n\n            tags = [row[0] for row in cursor.fetchall()]\n\n            return dict(entry) | {\"tags\": tags}\n\n    def search_entries(\n        self, query: str = \"\", tag: str = None, limit: int = 100\n    ) -> List[Dict[str, Any]]:\n        \"\"\"Search research entries by content or tags.\"\"\"\n        with self._get_connection() as conn:\n            conn.row_factory = sqlite3.Row\n            cursor = conn.cursor()\n\n            sql = \"\"\"\n            SELECT DISTINCT re.* FROM research_entries re\n            \"\"\"\n\n            params = []\n            conditions = []\n\n            if query:\n                conditions.append(\"\"\"\n                (re.topic LIKE ? OR re.summary LIKE ? OR re.details LIKE ?)\n                \"\"\")\n                search_term = f\"%{query}%\"\n                params.extend([search_term, search_term, search_term])\n\n            if tag:\n                conditions.append(\"\"\"\n                re.id IN (\n                    SELECT ret.entry_id FROM research_entry_tags ret\n                    JOIN tags t ON ret.tag_id = t.id\n                    WHERE t.name = ?\n                )\n                \"\"\")\n                params.append(tag)\n\n            if conditions:\n                sql += \" WHERE \" + \" AND \".join(conditions)\n\n            sql += \" ORDER BY re.date DESC, re.updated_at DESC\"\n\n            if limit:\n                sql += \" LIMIT ?\"\n                params.append(limit)\n\n            cursor.execute(sql, params)\n            entries = cursor.fetchall()\n\n            # Get tags for each entry\n            result = []\n            for entry in entries:\n                entry_id = entry[\"id\"]\n                cursor.execute(\n                    \"\"\"\n                SELECT t.name FROM tags t\n                JOIN research_entry_tags ret ON t.id = ret.tag_id\n                WHERE ret.entry_id = ?\n                \"\"\",\n                    (entry_id,),\n                )\n                tags = [row[0] for row in cursor.fetchall()]\n                result.append(dict(entry) | {\"tags\": tags})\n\n            return result\n\n    def import_from_json(self, json_path: str) -> int:\n        \"\"\"Import research entries from a JSON file.\"\"\"\n        try:\n            with open(json_path, \"r\", encoding=\"utf-8\") as f:\n                entries = json.load(f)\n\n            if not isinstance(entries, list):\n                entries = [entries]\n\n            success_count = 0\n            for entry in entries:\n                if self.add_research_entry(entry):\n                    success_count += 1\n\n            return success_count\n\n        except (json.JSONDecodeError, FileNotFoundError, IOError) as e:\n            print(f\"Error importing from {json_path}: {e}\")\n            return 0\n\n\ndef setup_database() -> ResearchDatabase:\n    \"\"\"Initialize and return a configured ResearchDatabase instance.\"\"\"\n    # Create data directory if it doesn't exist\n    data_dir = Path(\"c:\\\\Users\\\\lyndz\\\\Downloads\\\\hypercode PROJECT\\\\hypercode\\\\data\")\n    data_dir.mkdir(parents=True, exist_ok=True)\n\n    # Initialize database\n    db_path = str(data_dir / \"research.db\")\n    db = ResearchDatabase(db_path)\n\n    # Import existing JSON files if database is empty\n    with db._get_connection() as conn:\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT COUNT(*) FROM research_entries\")\n        if cursor.fetchone()[0] == 0:\n            json_dir = data_dir / \"reseach data json\"\n            if json_dir.exists() and json_dir.is_dir():\n                for json_file in json_dir.glob(\"*.json\"):\n                    db.import_from_json(str(json_file))\n\n    return db\n\n\n# Example usage\nif __name__ == \"__main__\":\n    db = setup_database()\n    print(f\"Database initialized at: {db.db_path}\")\n\n    # Example search\n    print(\"\\nRecent entries:\")\n    for entry in db.search_entries(limit=3):\n        print(\n            f\"- {entry['date']}: {entry['topic']} ({', '.join(entry['tags']) if 'tags' in entry else 'No tags'})\"\n        )\n",
  "metadata": {},
  "relative_path": "live_research\\database.py",
  "id": "1e80d30bcc0bd8f0ff2ce72d1ebb8c47"
}