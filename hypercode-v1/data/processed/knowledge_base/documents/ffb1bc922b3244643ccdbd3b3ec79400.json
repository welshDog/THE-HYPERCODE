{
  "file_name": "_wrap.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\venv_new\\Lib\\site-packages\\pip\\_vendor\\rich\\_wrap.py",
  "file_size": 3404,
  "created": "2025-12-01T01:58:33.223311",
  "modified": "2025-12-01T01:58:33.224137",
  "file_type": "code",
  "content_hash": "440510bfdf54e59b40ae3d34537ea429",
  "content_type": "text",
  "content": "from __future__ import annotations\n\nimport re\nfrom typing import Iterable\n\nfrom ._loop import loop_last\nfrom .cells import cell_len, chop_cells\n\nre_word = re.compile(r\"\\s*\\S+\\s*\")\n\n\ndef words(text: str) -> Iterable[tuple[int, int, str]]:\n    \"\"\"Yields each word from the text as a tuple\n    containing (start_index, end_index, word). A \"word\" in this context may\n    include the actual word and any whitespace to the right.\n    \"\"\"\n    position = 0\n    word_match = re_word.match(text, position)\n    while word_match is not None:\n        start, end = word_match.span()\n        word = word_match.group(0)\n        yield start, end, word\n        word_match = re_word.match(text, end)\n\n\ndef divide_line(text: str, width: int, fold: bool = True) -> list[int]:\n    \"\"\"Given a string of text, and a width (measured in cells), return a list\n    of cell offsets which the string should be split at in order for it to fit\n    within the given width.\n\n    Args:\n        text: The text to examine.\n        width: The available cell width.\n        fold: If True, words longer than `width` will be folded onto a new line.\n\n    Returns:\n        A list of indices to break the line at.\n    \"\"\"\n    break_positions: list[int] = []  # offsets to insert the breaks at\n    append = break_positions.append\n    cell_offset = 0\n    _cell_len = cell_len\n\n    for start, _end, word in words(text):\n        word_length = _cell_len(word.rstrip())\n        remaining_space = width - cell_offset\n        word_fits_remaining_space = remaining_space >= word_length\n\n        if word_fits_remaining_space:\n            # Simplest case - the word fits within the remaining width for this line.\n            cell_offset += _cell_len(word)\n        else:\n            # Not enough space remaining for this word on the current line.\n            if word_length > width:\n                # The word doesn't fit on any line, so we can't simply\n                # place it on the next line...\n                if fold:\n                    # Fold the word across multiple lines.\n                    folded_word = chop_cells(word, width=width)\n                    for last, line in loop_last(folded_word):\n                        if start:\n                            append(start)\n                        if last:\n                            cell_offset = _cell_len(line)\n                        else:\n                            start += len(line)\n                else:\n                    # Folding isn't allowed, so crop the word.\n                    if start:\n                        append(start)\n                    cell_offset = _cell_len(word)\n            elif cell_offset and start:\n                # The word doesn't fit within the remaining space on the current\n                # line, but it *can* fit on to the next (empty) line.\n                append(start)\n                cell_offset = _cell_len(word)\n\n    return break_positions\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from .console import Console\n\n    console = Console(width=10)\n    console.print(\"12345 abcdefghijklmnopqrstuvwyxzABCDEFGHIJKLMNOPQRSTUVWXYZ 12345\")\n    print(chop_cells(\"abcdefghijklmnopqrstuvwxyz\", 10))\n\n    console = Console(width=20)\n    console.rule()\n    console.print(\"TextualはPythonの高速アプリケーション開発フレームワークです\")\n\n    console.rule()\n    console.print(\"アプリケーションは1670万色を使用でき\")\n",
  "metadata": {},
  "relative_path": "venv_new\\Lib\\site-packages\\pip\\_vendor\\rich\\_wrap.py",
  "id": "ffb1bc922b3244643ccdbd3b3ec79400"
}