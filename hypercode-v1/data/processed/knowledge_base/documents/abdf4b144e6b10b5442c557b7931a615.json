{
  "file_name": "cache.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\venv_new\\Lib\\site-packages\\pip\\_vendor\\cachecontrol\\cache.py",
  "file_size": 1953,
  "created": "2025-12-01T01:58:31.725171",
  "modified": "2025-12-01T01:58:31.726609",
  "file_type": "code",
  "content_hash": "b06db1426d9b08f643761cb34c978b82",
  "content_type": "text",
  "content": "# SPDX-FileCopyrightText: 2015 Eric Larson\n#\n# SPDX-License-Identifier: Apache-2.0\n\n\"\"\"\nThe cache object API for implementing caches. The default is a thread\nsafe in-memory dictionary.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom threading import Lock\nfrom typing import IO, TYPE_CHECKING, MutableMapping\n\nif TYPE_CHECKING:\n    from datetime import datetime\n\n\nclass BaseCache:\n    def get(self, key: str) -> bytes | None:\n        raise NotImplementedError()\n\n    def set(\n        self, key: str, value: bytes, expires: int | datetime | None = None\n    ) -> None:\n        raise NotImplementedError()\n\n    def delete(self, key: str) -> None:\n        raise NotImplementedError()\n\n    def close(self) -> None:\n        pass\n\n\nclass DictCache(BaseCache):\n    def __init__(self, init_dict: MutableMapping[str, bytes] | None = None) -> None:\n        self.lock = Lock()\n        self.data = init_dict or {}\n\n    def get(self, key: str) -> bytes | None:\n        return self.data.get(key, None)\n\n    def set(\n        self, key: str, value: bytes, expires: int | datetime | None = None\n    ) -> None:\n        with self.lock:\n            self.data.update({key: value})\n\n    def delete(self, key: str) -> None:\n        with self.lock:\n            if key in self.data:\n                self.data.pop(key)\n\n\nclass SeparateBodyBaseCache(BaseCache):\n    \"\"\"\n    In this variant, the body is not stored mixed in with the metadata, but is\n    passed in (as a bytes-like object) in a separate call to ``set_body()``.\n\n    That is, the expected interaction pattern is::\n\n        cache.set(key, serialized_metadata)\n        cache.set_body(key)\n\n    Similarly, the body should be loaded separately via ``get_body()``.\n    \"\"\"\n\n    def set_body(self, key: str, body: bytes) -> None:\n        raise NotImplementedError()\n\n    def get_body(self, key: str) -> IO[bytes] | None:\n        \"\"\"\n        Return the body as file-like object.\n        \"\"\"\n        raise NotImplementedError()\n",
  "metadata": {},
  "relative_path": "venv_new\\Lib\\site-packages\\pip\\_vendor\\cachecontrol\\cache.py",
  "id": "abdf4b144e6b10b5442c557b7931a615"
}