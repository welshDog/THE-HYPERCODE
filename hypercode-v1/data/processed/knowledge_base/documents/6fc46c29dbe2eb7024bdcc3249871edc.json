{
  "file_name": "hypercode-parser-COMPLETE.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\hypercode\\src\\hypercode-parser-COMPLETE.py",
  "file_size": 8926,
  "created": "2025-11-26T23:37:35.628756",
  "modified": "2025-11-26T23:37:35.628756",
  "file_type": "code",
  "content_hash": "ff7d1801c55e611c502a2e45ff7a33e8",
  "content_type": "text",
  "content": "\"\"\"\nHyperCode Parser - Complete Implementation\nConverts token stream into Abstract Syntax Tree (AST)\n\nFeatures:\n- Recursive descent parsing\n- Loop nesting support\n- Error recovery\n- AST visualization\n- Semantic validation\n\"\"\"\n\nimport sys\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import List, Optional\n\n# Import lexer (assumes hypercode-lexer-COMPLETE.py)\nfrom hypercode_lexer_COMPLETE import LexerError, Token, TokenType\n\n\nclass NodeType(Enum):\n    \"\"\"AST Node types\"\"\"\n\n    PROGRAM = \"program\"\n    PUSH = \"push\"\n    POP = \"pop\"\n    INCR = \"increment\"\n    DECR = \"decrement\"\n    OUTPUT = \"output\"\n    INPUT = \"input\"\n    LOOP = \"loop\"\n    SPATIAL_2D = \"spatial_2d\"\n    AI_NATIVE = \"ai_native\"\n\n\n@dataclass\nclass ASTNode:\n    \"\"\"\n    Abstract Syntax Tree Node.\n\n    Represents a single operation or block in HyperCode.\n    \"\"\"\n\n    node_type: NodeType\n    value: Optional[int] = None\n    children: List[\"ASTNode\"] = field(default_factory=list)\n    line: int = 0\n    column: int = 0\n\n    def __repr__(self, indent: int = 0) -> str:\n        \"\"\"Pretty-print AST (neurodivergent-friendly)\"\"\"\n        spaces = \"  \" * indent\n        result = f\"{spaces}{self.node_type.value}\"\n\n        if self.value is not None:\n            result += f\" (value={self.value})\"\n\n        if self.children:\n            result += \" {\"\n            for child in self.children:\n                result += \"\\n\" + child.__repr__(indent + 1)\n            result += f\"\\n{spaces}}}\"\n\n        return result\n\n\nclass ParserError(Exception):\n    \"\"\"Parser-specific errors with context\"\"\"\n\n    def __init__(self, message: str, token: Token):\n        self.message = message\n        self.token = token\n        super().__init__(\n            f\"Line {token.line}, Col {token.column}: {message}\\n\"\n            f\"  Near: '{token.value}'\"\n        )\n\n\nclass HyperCodeParser:\n    \"\"\"\n    Parses HyperCode token stream into AST.\n\n    Grammar (simplified BNF):\n\n    program    ::= statement*\n    statement  ::= operation | loop | spatial | ai_native\n    operation  ::= PUSH | POP | INCR | DECR | OUTPUT | INPUT\n    loop       ::= LOOP_START statement* LOOP_END\n    spatial    ::= SPATIAL_2D statement*\n    ai_native  ::= AI_NATIVE\n    \"\"\"\n\n    def __init__(self, tokens: List[Token]):\n        \"\"\"\n        Initialize parser with token stream.\n\n        Args:\n            tokens: List of tokens from lexer\n        \"\"\"\n        self.tokens = tokens\n        self.position = 0\n        self.current_token = tokens[0] if tokens else None\n\n    def parse(self) -> ASTNode:\n        \"\"\"\n        Parse tokens into AST.\n\n        Returns:\n            Root AST node (PROGRAM)\n\n        Raises:\n            ParserError: On syntax errors\n        \"\"\"\n        program = ASTNode(NodeType.PROGRAM)\n\n        while not self._is_at_end():\n            if self.current_token.type == TokenType.EOF:\n                break\n\n            statement = self._parse_statement()\n            if statement:\n                program.children.append(statement)\n\n        return program\n\n    def _parse_statement(self) -> Optional[ASTNode]:\n        \"\"\"Parse a single statement\"\"\"\n        token = self.current_token\n\n        # Simple operations\n        if token.type == TokenType.PUSH:\n            self._advance()\n            return ASTNode(NodeType.PUSH, line=token.line, column=token.column)\n\n        elif token.type == TokenType.POP:\n            self._advance()\n            return ASTNode(NodeType.POP, line=token.line, column=token.column)\n\n        elif token.type == TokenType.INCR:\n            self._advance()\n            return ASTNode(NodeType.INCR, line=token.line, column=token.column)\n\n        elif token.type == TokenType.DECR:\n            self._advance()\n            return ASTNode(NodeType.DECR, line=token.line, column=token.column)\n\n        elif token.type == TokenType.OUTPUT:\n            self._advance()\n            return ASTNode(NodeType.OUTPUT, line=token.line, column=token.column)\n\n        elif token.type == TokenType.INPUT:\n            self._advance()\n            return ASTNode(NodeType.INPUT, line=token.line, column=token.column)\n\n        # Loop\n        elif token.type == TokenType.LOOP_START:\n            return self._parse_loop()\n\n        # Spatial 2D mode\n        elif token.type == TokenType.SPATIAL_2D:\n            self._advance()\n            return ASTNode(NodeType.SPATIAL_2D, line=token.line, column=token.column)\n\n        # AI-native marker\n        elif token.type == TokenType.AI_NATIVE:\n            self._advance()\n            return ASTNode(NodeType.AI_NATIVE, line=token.line, column=token.column)\n\n        # Unexpected token\n        else:\n            raise ParserError(f\"Unexpected token: {token.type.value}\", token)\n\n    def _parse_loop(self) -> ASTNode:\n        \"\"\"\n        Parse loop structure: [ statements ]\n\n        Returns:\n            Loop AST node\n        \"\"\"\n        start_token = self.current_token\n\n        if start_token.type != TokenType.LOOP_START:\n            raise ParserError(\"Expected '[' to start loop\", start_token)\n\n        self._advance()  # Skip [\n\n        loop_node = ASTNode(\n            NodeType.LOOP, line=start_token.line, column=start_token.column\n        )\n\n        # Parse loop body\n        while not self._is_at_end() and self.current_token.type != TokenType.LOOP_END:\n            statement = self._parse_statement()\n            if statement:\n                loop_node.children.append(statement)\n\n        # Expect closing ]\n        if self.current_token.type != TokenType.LOOP_END:\n            raise ParserError(\n                f\"Unclosed loop: expected ']', got {self.current_token.type.value}\",\n                start_token,\n            )\n\n        self._advance()  # Skip ]\n\n        return loop_node\n\n    def _advance(self):\n        \"\"\"Move to next token\"\"\"\n        if self.position < len(self.tokens) - 1:\n            self.position += 1\n            self.current_token = self.tokens[self.position]\n\n    def _is_at_end(self) -> bool:\n        \"\"\"Check if at end of token stream\"\"\"\n        return (\n            self.position >= len(self.tokens)\n            or self.current_token.type == TokenType.EOF\n        )\n\n    def validate(self) -> List[str]:\n        \"\"\"\n        Validate AST structure.\n\n        Returns:\n            List of warnings (empty if no issues)\n        \"\"\"\n        warnings = []\n\n        # Check for unbalanced loops (already handled by parser)\n        # Check for infinite loops (basic heuristic)\n        # Check for unreachable code\n\n        return warnings\n\n    def print_ast(self, node: Optional[ASTNode] = None, indent: int = 0):\n        \"\"\"\n        Print AST in readable format.\n\n        Args:\n            node: AST node to print (defaults to root)\n            indent: Indentation level\n        \"\"\"\n        if node is None:\n            return\n\n        print(node.__repr__(indent))\n\n\ndef main():\n    \"\"\"CLI interface for the parser\"\"\"\n    import argparse\n\n    from hypercode_lexer_COMPLETE import HyperCodeLexer\n\n    parser = argparse.ArgumentParser(\n        description=\"HyperCode Parser - Generate AST from HyperCode programs\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  python parser.py program.hc\n  python parser.py program.hc --visualize\n        \"\"\",\n    )\n\n    parser.add_argument(\"file\", help=\"HyperCode source file\")\n    parser.add_argument(\n        \"--visualize\", action=\"store_true\", help=\"Print AST visualization\"\n    )\n\n    args = parser.parse_args()\n\n    # Read source\n    try:\n        with open(args.file, \"r\") as f:\n            source = f.read()\n    except FileNotFoundError:\n        print(f\"‚ùå Error: File not found: {args.file}\", file=sys.stderr)\n        return 1\n\n    # Lex\n    try:\n        lexer = HyperCodeLexer(source, args.file)\n        tokens = lexer.tokenize()\n        print(f\"‚úÖ Lexing complete: {len(tokens) - 1} tokens\")\n    except LexerError as e:\n        print(f\"‚ùå Lexer Error: {e}\", file=sys.stderr)\n        return 1\n\n    # Parse\n    try:\n        hc_parser = HyperCodeParser(tokens)\n        ast = hc_parser.parse()\n        print(f\"‚úÖ Parsing complete: {len(ast.children)} top-level statements\")\n\n        # Validate\n        warnings = hc_parser.validate()\n        if warnings:\n            print(\"\\n‚ö†Ô∏è  Warnings:\")\n            for warning in warnings:\n                print(f\"   {warning}\")\n\n        # Visualize\n        if args.visualize:\n            print(\"\\nüìä AST Visualization:\")\n            hc_parser.print_ast(ast)\n\n        return 0\n\n    except ParserError as e:\n        print(f\"‚ùå Parser Error: {e}\", file=sys.stderr)\n        return 1\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
  "metadata": {},
  "relative_path": "hypercode\\src\\hypercode-parser-COMPLETE.py",
  "id": "6fc46c29dbe2eb7024bdcc3249871edc"
}