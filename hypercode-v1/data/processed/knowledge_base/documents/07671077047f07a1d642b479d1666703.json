{
  "file_name": "RECIPES.md",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\src\\core\\hypercode-\\docs\\RECIPES.md",
  "file_size": 9026,
  "created": "2025-11-13T00:25:18.728014",
  "modified": "2025-11-17T18:15:38.517480",
  "file_type": "code",
  "content_hash": "2fc71c588a141db8848a41fb6ed15152",
  "content_type": "markdown",
  "content": "# HyperCode Recipes\n\n## Table of Contents\n\n1. [String Manipulation](#string-manipulation)\n2. [Array Operations](#array-operations)\n3. [Object Manipulation](#object-manipulation)\n4. [Async Patterns](#async-patterns)\n5. [File Operations](#file-operations)\n6. [Data Validation](#data-validation)\n7. [Date and Time](#date-and-time)\n8. [Networking](#networking)\n9. [Error Handling](#error-handling)\n10. [Performance](#performance)\n\n## String Manipulation\n\n### Reverse a String\n\n```javascript\nfunction reverseString(str) {\n  return str.split(\"\").reverse().join(\"\");\n}\n\nreverseString(\"hello\"); // 'olleh'\n```\n\n### Generate Random String\n\n```javascript\nfunction randomString(length = 8) {\n  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  let result = \"\";\n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * chars.length));\n  }\n  return result;\n}\n```\n\n## Array Operations\n\n### Find Unique Elements\n\n```javascript\nfunction unique(array) {\n  return [...new Set(array)];\n}\n\nunique([1, 2, 2, 3, 4, 4, 5]); // [1, 2, 3, 4, 5]\n```\n\n### Group By Property\n\n```javascript\nfunction groupBy(array, key) {\n  return array.reduce((acc, item) => {\n    const group = item[key];\n    if (!acc[group]) acc[group] = [];\n    acc[group].push(item);\n    return acc;\n  }, {});\n}\n\nconst users = [\n  { id: 1, name: \"Alice\", role: \"admin\" },\n  { id: 2, name: \"Bob\", role: \"user\" },\n  { id: 3, name: \"Charlie\", role: \"admin\" },\n];\n\ngroupBy(users, \"role\");\n/*\n{\n    admin: [\n        { id: 1, name: 'Alice', role: 'admin' },\n        { id: 3, name: 'Charlie', role: 'admin' }\n    ],\n    user: [\n        { id: 2, name: 'Bob', role: 'user' }\n    ]\n}\n*/\n```\n\n## Object Manipulation\n\n### Deep Clone Object\n\n```javascript\nfunction deepClone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\n// Or using the structured clone API (if available)\nfunction deepClone(obj) {\n  return structuredClone ? structuredClone(obj) : JSON.parse(JSON.stringify(obj));\n}\n```\n\n### Merge Objects\n\n```javascript\nfunction mergeObjects(...objects) {\n  return Object.assign({}, ...objects);\n}\n\nconst defaults = { theme: \"light\", fontSize: 14 };\nconst userSettings = { fontSize: 16, darkMode: true };\n\nmergeObjects(defaults, userSettings);\n// { theme: 'light', fontSize: 16, darkMode: true }\n```\n\n## Async Patterns\n\n### Retry with Exponential Backoff\n\n```javascript\nasync function fetchWithRetry(url, maxRetries = 3) {\n  let lastError;\n\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      const response = await fetch(url);\n      if (response.ok) return await response.json();\n      throw new Error(`HTTP error! status: ${response.status}`);\n    } catch (error) {\n      lastError = error;\n      const delay = Math.pow(2, i) * 1000;\n      await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n  }\n\n  throw lastError;\n}\n```\n\n### Parallel Execution with Limit\n\n```javascript\nasync function mapConcurrent(array, asyncFn, concurrency = 5) {\n  const results = [];\n  const executing = [];\n\n  for (const item of array) {\n    const p = Promise.resolve().then(() => asyncFn(item));\n    results.push(p);\n\n    const e = p.then(() => executing.splice(executing.indexOf(e), 1));\n    executing.push(e);\n\n    if (executing.length >= concurrency) {\n      await Promise.race(executing);\n    }\n  }\n\n  return Promise.all(results);\n}\n```\n\n## File Operations\n\n### Read File Line by Line\n\n```javascript\nconst fs = import(\"fs\");\nconst readline = import(\"readline\");\n\nasync function processFileByLine(filename, processLine) {\n  const fileStream = fs.createReadStream(filename);\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity,\n  });\n\n  for await (const line of rl) {\n    await processLine(line);\n  }\n}\n```\n\n### Watch File for Changes\n\n```javascript\nconst fs = import(\"fs\");\n\nfunction watchFile(filename, callback) {\n  let lastMtime = null;\n\n  setInterval(() => {\n    try {\n      const stats = fs.statSync(filename);\n      if (lastMtime && stats.mtime > lastMtime) {\n        callback();\n      }\n      lastMtime = stats.mtime;\n    } catch (error) {\n      console.error(\"Error watching file:\", error);\n    }\n  }, 1000); // Check every second\n}\n```\n\n## Data Validation\n\n### Validate Email\n\n```javascript\nfunction isValidEmail(email) {\n  const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return re.test(String(email).toLowerCase());\n}\n```\n\n### Schema Validation\n\n```javascript\nfunction validate(schema, data) {\n  const errors = [];\n\n  for (const [key, validator] of Object.entries(schema)) {\n    try {\n      validator(data[key]);\n    } catch (error) {\n      errors.push({\n        field: key,\n        error: error.message,\n      });\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n\n// Usage\nconst userSchema = {\n  username: (value) => {\n    if (!value) throw new Error(\"Username is required\");\n    if (value.length < 3) throw new Error(\"Username too short\");\n  },\n  email: (value) => {\n    if (!isValidEmail(value)) throw new Error(\"Invalid email\");\n  },\n};\n\nconst result = validate(userSchema, { username: \"al\", email: \"invalid\" });\n```\n\n## Date and Time\n\n### Format Date\n\n```javascript\nfunction formatDate(date, format = \"YYYY-MM-DD\") {\n  const d = new Date(date);\n  const pad = (num) => String(num).padStart(2, \"0\");\n\n  return format\n    .replace(/YYYY/g, d.getFullYear())\n    .replace(/MM/g, pad(d.getMonth() + 1))\n    .replace(/DD/g, pad(d.getDate()))\n    .replace(/HH/g, pad(d.getHours()))\n    .replace(/mm/g, pad(d.getMinutes()))\n    .replace(/ss/g, pad(d.getSeconds()));\n}\n\nformatDate(new Date(), \"YYYY-MM-DD HH:mm:ss\"); // '2025-11-12 19:30:45'\n```\n\n### Time Since\n\n```javascript\nfunction timeSince(date) {\n  const seconds = Math.floor((new Date() - new Date(date)) / 1000);\n\n  const intervals = {\n    year: 31536000,\n    month: 2592000,\n    week: 604800,\n    day: 86400,\n    hour: 3600,\n    minute: 60,\n  };\n\n  for (const [unit, secondsInUnit] of Object.entries(intervals)) {\n    const interval = Math.floor(seconds / secondsInUnit);\n    if (interval >= 1) {\n      return interval === 1 ? `${interval} ${unit} ago` : `${interval} ${unit}s ago`;\n    }\n  }\n\n  return \"just now\";\n}\n```\n\n## Networking\n\n### Simple HTTP Server\n\n```javascript\nconst http = import(\"http\");\n\nconst server = http.createServer((req, res) => {\n  if (req.url === \"/\") {\n    res.status(200).send(\"Hello, World!\");\n  } else if (req.url === \"/api/data\") {\n    res.status(200).json({ message: \"API Response\" });\n  } else {\n    res.status(404).send(\"Not Found\");\n  }\n});\n\nserver.listen(3000, () => {\n  console.log(\"Server running on http://localhost:3000\");\n});\n```\n\n### Fetch with Timeout\n\n```javascript\nasync function fetchWithTimeout(url, options = {}, timeout = 5000) {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n  try {\n    const response = await fetch(url, {\n      ...options,\n      signal: controller.signal,\n    });\n    clearTimeout(timeoutId);\n    return response;\n  } catch (error) {\n    clearTimeout(timeoutId);\n    throw error;\n  }\n}\n```\n\n## Error Handling\n\n### Error Boundary\n\n```javascript\nclass ErrorBoundary {\n  constructor(component) {\n    this.component = component;\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.error(\"Error caught by boundary:\", error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <div>Something went wrong: {this.state.error.message}</div>;\n    }\n    return this.component;\n  }\n}\n```\n\n### Retry with Exponential Backoff\n\n```javascript\nasync function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {\n  let lastError;\n\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error;\n      if (i < maxRetries - 1) {\n        const delay = baseDelay * Math.pow(2, i) + Math.random() * 1000;\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      }\n    }\n  }\n\n  throw lastError;\n}\n```\n\n## Performance\n\n### Debounce Function\n\n```javascript\nfunction debounce(fn, delay) {\n  let timeoutId;\n  return function (...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn.apply(this, args), delay);\n  };\n}\n\n// Usage\nconst handleResize = debounce(() => {\n  console.log(\"Window resized\");\n}, 250);\n\nwindow.addEventListener(\"resize\", handleResize);\n```\n\n### Memoization\n\n```javascript\nfunction memoize(fn) {\n  const cache = new Map();\n\n  return function (...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Usage\nconst expensiveCalculation = memoize(function (n) {\n  console.log(\"Calculating...\");\n  return n * 2;\n});\n\nexpensiveCalculation(5); // Calculates and caches\nexpensiveCalculation(5); // Returns cached result\n```\n\n---\n\n_Recipes last updated: November 12, 2025_",
  "metadata": {
    "headers": [
      "HyperCode Recipes",
      "Table of Contents",
      "String Manipulation",
      "Reverse a String",
      "Generate Random String",
      "Array Operations",
      "Find Unique Elements",
      "Group By Property",
      "Object Manipulation",
      "Deep Clone Object",
      "Merge Objects",
      "Async Patterns",
      "Retry with Exponential Backoff",
      "Parallel Execution with Limit",
      "File Operations",
      "Read File Line by Line",
      "Watch File for Changes",
      "Data Validation",
      "Validate Email",
      "Schema Validation",
      "Date and Time",
      "Format Date",
      "Time Since",
      "Networking",
      "Simple HTTP Server",
      "Fetch with Timeout",
      "Error Handling",
      "Error Boundary",
      "Retry with Exponential Backoff",
      "Performance",
      "Debounce Function",
      "Memoization"
    ]
  },
  "relative_path": "src\\core\\hypercode-\\docs\\RECIPES.md",
  "id": "07671077047f07a1d642b479d1666703"
}