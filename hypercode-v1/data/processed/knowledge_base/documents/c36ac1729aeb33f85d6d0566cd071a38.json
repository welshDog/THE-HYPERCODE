{
  "file_name": "code_insights.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\code_insights.py",
  "file_size": 3332,
  "created": "2025-12-04T16:50:38.243263",
  "modified": "2025-12-04T20:22:08.883912",
  "file_type": "code",
  "content_hash": "233915924a0d6100026cb9f937e1d6f0",
  "content_type": "text",
  "content": "from collections import Counter\nfrom pathlib import Path\nfrom typing import Dict, List, Set\n\nfrom hypercode_db import CodeEntity, HypercodeDB\n\n\ndef analyze_code_patterns(db: HypercodeDB) -> None:\n    \"\"\"Analyze function and class naming patterns.\"\"\"\n    print(\"\\nðŸ” ANALYZING CODE PATTERNS\")\n\n    # Get all functions and classes\n    functions = [e for e in db.entities if e.type == \"function\"]\n    # Removed unused 'classes' variable\n\n    # Analyze function name patterns\n    verb_counts: Dict[str, int] = Counter()\n    for func in functions:\n        # Split function names by underscores and get the first word\n        first_word = func.name.split(\"_\")[0].lower()\n        if first_word:\n            verb_counts[first_word] += 1\n\n    print(\"\\nMost common function name starters:\")\n    for verb, count in Counter(verb_counts).most_common(10):\n        print(f\"  {verb}(): {count} functions\")\n\n\ndef find_undocumented_code(db: HypercodeDB) -> None:\n    \"\"\"Find complex but undocumented code.\"\"\"\n    print(\"\\nðŸ“ UNDOCUMENTED CODE ANALYSIS\")\n\n    # Get all classes with methods but no docstring\n    undocumented_classes = [\n        c\n        for c in db.entities\n        if c.type == \"class\" and c.methods and not (c.docstring and c.docstring.strip())\n    ]\n\n    print(f\"\\nFound {len(undocumented_classes)} undocumented classes with methods\")\n    for i, cls in enumerate(undocumented_classes[:5], 1):\n        print(f\"  {i}. {cls.name} ({len(cls.methods)} methods) in {cls.file}\")\n\n\ndef analyze_test_coverage(db: HypercodeDB) -> Dict[str, Any]:\n    \"\"\"Analyze test coverage patterns.\n\n    Returns:\n        Dictionary containing test coverage statistics\n    \"\"\"\n    try:\n        # Find test files and test functions\n        test_files = [f for f in db.by_file.keys() if \"test\" in f.lower()]\n        test_functions = [\n            e\n            for e in db.entities\n            if e.type == \"function\" and e.name.lower().startswith(\"test_\")\n        ]\n\n        # Count testable entities (functions and classes)\n        testable_entities = [\n            e\n            for e in db.entities\n            if e.type in (\"function\", \"class\")\n            and not e.name.startswith(\"_\")  # Skip private methods\n            and not any(\n                skip in e.file.lower() for skip in [\"test\", \"venv\", \"site-packages\"]\n            )\n        ]\n\n        # Calculate coverage\n        coverage = {\n            \"test_files\": len(test_files),\n            \"test_functions\": len(test_functions),\n            \"testable_entities\": len(testable_entities),\n            \"coverage_ratio\": len(test_functions) / max(1, len(testable_entities)),\n        }\n\n        return coverage\n\n    except Exception as e:\n        print(f\"Error analyzing test coverage: {str(e)}\")\n        return {\n            \"test_files\": 0,\n            \"test_functions\": 0,\n            \"testable_entities\": 0,\n            \"coverage_ratio\": 0.0,\n            \"error\": str(e),\n        }\n\n\nif __name__ == \"__main__\":\n    print(\"Loading database for advanced analysis...\")\n    db = HypercodeDB(\"HYPER_DATABASE.json\")\n\n    analyze_code_patterns(db)\n    find_undocumented_code(db)\n    analyze_test_coverage(db)\n\n    print(\"\\nðŸŽ‰ Analysis complete! Use hypercode_db.py for interactive searching\")\n",
  "metadata": {},
  "relative_path": "code_insights.py",
  "id": "c36ac1729aeb33f85d6d0566cd071a38"
}