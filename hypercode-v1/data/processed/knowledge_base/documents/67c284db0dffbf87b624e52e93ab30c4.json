{
  "file_name": "enhanced_validator.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\src\\duelcode\\enhanced_validator.py",
  "file_size": 14716,
  "created": "2025-11-23T11:56:45.659709",
  "modified": "2025-11-23T11:56:45.659709",
  "file_type": "code",
  "content_hash": "b08952938a687723d15befb9d3222ce5",
  "content_type": "text",
  "content": "\"\"\"\nEnhanced DuelCode Validator with additional validation rules.\n\"\"\"\n\nimport re\nfrom dataclasses import dataclass\nfrom enum import Enum, auto\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple\n\n\nclass Severity(Enum):\n    ERROR = auto()\n    WARNING = auto()\n    INFO = auto()\n\n\n@dataclass\nclass ValidationResult:\n    message: str\n    severity: Severity\n    line: Optional[int] = None\n    col: Optional[int] = None\n\n\nclass DuelCodeEnhancedValidator:\n    \"\"\"Enhanced validator with additional rules for DuelCode documentation.\"\"\"\n\n    SUPPORTED_LANGUAGES = {\n        \"python\",\n        \"javascript\",\n        \"typescript\",\n        \"java\",\n        \"c\",\n        \"cpp\",\n        \"csharp\",\n        \"go\",\n        \"rust\",\n        \"ruby\",\n        \"php\",\n        \"swift\",\n        \"kotlin\",\n        \"dart\",\n        \"html\",\n        \"css\",\n        \"sql\",\n        \"json\",\n        \"yaml\",\n        \"markdown\",\n        \"mermaid\",\n    }\n\n    # Common programming language file extensions\n    CODE_EXTENSIONS = {\n        \".py\",\n        \".js\",\n        \".ts\",\n        \".jsx\",\n        \".tsx\",\n        \".java\",\n        \".c\",\n        \".cpp\",\n        \".h\",\n        \".hpp\",\n        \".cs\",\n        \".go\",\n        \".rs\",\n        \".rb\",\n        \".php\",\n        \".swift\",\n        \".kt\",\n        \".dart\",\n        \".html\",\n        \".css\",\n        \".scss\",\n        \".sql\",\n        \".json\",\n        \".yaml\",\n        \".yml\",\n        \".md\",\n    }\n\n    def __init__(self, file_path: str):\n        self.file_path = Path(file_path)\n        self.content = self.file_path.read_text(encoding=\"utf-8\")\n        self.lines = self.content.split(\"\\n\")\n        self.results: List[ValidationResult] = []\n        self._line_cache: Dict[str, List[Tuple[int, str]]] = {}\n\n    def _add_result(\n        self, message: str, severity: Severity, line: Optional[int] = None\n    ) -> None:\n        \"\"\"Add a validation result with proper line number.\"\"\"\n        col = None\n        if line is not None and 0 <= line < len(self.lines):\n            col = (\n                len(self.lines[line]) - len(self.lines[line].lstrip()) + 1\n                if self.lines[line].strip()\n                else 1\n            )\n        self.results.append(ValidationResult(message, severity, line, col))\n\n    def _find_lines(self, pattern: str) -> List[Tuple[int, str]]:\n        \"\"\"Find all lines matching the pattern with their line numbers.\"\"\"\n        if pattern not in self._line_cache:\n            self._line_cache[pattern] = [\n                (i, line)\n                for i, line in enumerate(self.lines)\n                if re.search(pattern, line, re.IGNORECASE)\n            ]\n        return self._line_cache[pattern]\n\n    # === New Validation Rules ===\n\n    def validate_code_blocks_have_language(self) -> None:\n        \"\"\"Ensure all code blocks have a specified language.\"\"\"\n        in_code_block = False\n        for i, line in enumerate(self.lines):\n            if line.startswith(\"```\"):\n                if not in_code_block and not line[3:].strip():\n                    self._add_result(\n                        \"Code block is missing a language specification\",\n                        Severity.ERROR,\n                        i,\n                    )\n                in_code_block = not in_code_block\n\n    def validate_has_visual_representation(self) -> None:\n        \"\"\"Ensure each part has a visual representation.\"\"\"\n        parts = self._find_lines(r\"^## Part \\d+:\")\n        visual_reps = self._find_lines(r\"^### üìä Visual Representation\")\n\n        if parts and not visual_reps:\n            self._add_result(\n                \"Document contains parts but no visual representations\",\n                Severity.WARNING,\n                0,\n            )\n\n    def validate_has_practical_exercise(self) -> None:\n        \"\"\"Ensure each part has a practical exercise.\"\"\"\n        parts = self._find_lines(r\"^## Part \\d+:\")\n        exercises = self._find_lines(r\"### üõ†Ô∏è Exercise\")\n\n        if parts and not exercises:\n            self._add_result(\n                \"Consider adding practical exercises for better engagement\",\n                Severity.INFO,\n                0,\n            )\n\n    def validate_has_learning_objectives(self) -> None:\n        \"\"\"Ensure learning objectives are present and well-formed.\"\"\"\n        objectives = self._find_lines(r\"^## üéØ Learning Objective\")\n        if not objectives:\n            self._add_result(\"Missing Learning Objectives section\", Severity.ERROR, 0)\n            return\n\n        # Check for at least 3 learning objectives\n        start_line = objectives[0][0]\n        objectives_count = 0\n        for i in range(start_line, min(start_line + 20, len(self.lines))):\n            if re.match(r\"^- \\[ \\]\", self.lines[i]):\n                objectives_count += 1\n\n        if objectives_count < 3:\n            self._add_result(\n                f\"Learning Objectives should have at least 3 items \"\n                f\"(found {objectives_count})\",\n                Severity.WARNING,\n                start_line,\n            )\n\n    def validate_has_checklist(self) -> None:\n        \"\"\"Ensure a checklist is present and has items.\"\"\"\n        checklist = self._find_lines(r\"^## üìã Before You Start\")\n        if not checklist:\n            self._add_result(\"Missing 'Before You Start' checklist\", Severity.ERROR, 0)\n            return\n\n        # Check for checklist items\n        start_line = checklist[0][0]\n        checklist_items = 0\n        for i in range(start_line, min(start_line + 20, len(self.lines))):\n            if re.match(r\"^- \\[ \\]\", self.lines[i]):\n                checklist_items += 1\n\n        if checklist_items < 3:\n            self._add_result(\n                f\"Checklist should have at least 3 items (found {checklist_items})\",\n                Severity.WARNING,\n                start_line,\n            )\n\n    def validate_has_conclusion(self) -> None:\n        \"\"\"Ensure the document has a conclusion section.\"\"\"\n        if not self._find_lines(r\"^## üèÅ Conclusion\"):\n            self._add_result(\n                \"Consider adding a 'Conclusion' section to summarize key points\",\n                Severity.INFO,\n                len(self.lines) - 1,\n            )\n\n    def validate_has_whats_next(self) -> None:\n        \"\"\"Suggest adding a 'What's Next' section.\"\"\"\n        if not self._find_lines(r\"^## ‚û°Ô∏è What\\'?s Next\"):\n            self._add_result(\n                \"Consider adding a 'What's Next' section to guide readers\",\n                Severity.INFO,\n                len(self.lines) - 1,\n            )\n\n    def validate_code_quality(self) -> None:\n        \"\"\"Check code quality in code blocks.\"\"\"\n        in_code_block = False\n        current_lang = None\n        code_block_lines: List[Tuple[int, str]] = []\n\n        for i, line in enumerate(self.lines):\n            if line.startswith(\"```\"):\n                if in_code_block and code_block_lines:\n                    self._analyze_code_block(\n                        code_block_lines,\n                        current_lang or \"unknown\",\n                        i - len(code_block_lines) - 1,\n                    )\n                    code_block_lines = []\n                else:\n                    current_lang = line[3:].strip().lower()\n                in_code_block = not in_code_block\n            elif in_code_block:\n                code_block_lines.append((i, line))\n\n    def _analyze_code_block(\n        self, lines: List[Tuple[int, str]], lang: str, start_line: int\n    ) -> None:\n        \"\"\"Analyze a code block for quality issues.\"\"\"\n        if not lines or not lang:\n            return\n\n        # Check for long lines\n        for line_num, line in lines:\n            if len(line) > 100:  # 100 character line length limit\n                self._add_result(\n                    \"Line exceeds 100 characters (consider breaking it up)\",\n                    Severity.WARNING,\n                    line_num,\n                )\n\n        # Language-specific checks\n        if lang == \"python\":\n            self._analyze_python_code(lines, start_line)\n        elif lang in (\"javascript\", \"typescript\"):\n            self._analyze_javascript_code(lines, start_line)\n\n    def _analyze_python_code(\n        self, lines: List[Tuple[int, str]], _start_line: int\n    ) -> None:\n        \"\"\"Python-specific code analysis.\"\"\"\n        for _i, (line_num, line) in enumerate(lines):\n            # Check for print statements (suggest using logging in production code)\n            if re.match(r\"^\\s*print\\(\", line):\n                self._add_result(\n                    \"Consider using logging instead of print() for production code\",\n                    Severity.INFO,\n                    line_num,\n                )\n\n            # Check for TODO comments\n            if \"TODO\" in line.upper() and not line.strip().startswith(\"#\"):\n                self._add_result(\n                    \"TODO comment found - make sure to address it\",\n                    Severity.INFO,\n                    line_num,\n                )\n\n    def _analyze_javascript_code(\n        self, lines: List[Tuple[int, str]], _start_line: int\n    ) -> None:\n        \"\"\"JavaScript/TypeScript-specific code analysis.\"\"\"\n        for _i, (line_num, line) in enumerate(lines):\n            # Check for console.log\n            if \"console.log(\" in line and not line.strip().startswith(\"//\"):\n                self._add_result(\n                    \"Consider removing or commenting out console.log statements \"\n                    \"in production code\",\n                    Severity.INFO,\n                    line_num,\n                )\n\n    def validate_has_glossary(self) -> None:\n        \"\"\"Suggest adding a glossary for technical terms.\"\"\"\n        technical_terms = [\n            \"API\",\n            \"REST\",\n            \"GraphQL\",\n            \"OAuth\",\n            \"JWT\",\n            \"Docker\",\n            \"Kubernetes\",\n            \"Microservices\",\n            \"CI/CD\",\n            \"TDD\",\n            \"BDD\",\n            \"MVC\",\n            \"ORM\",\n            \"SQL\",\n            \"NoSQL\",\n        ]\n\n        found_terms = []\n        for term in technical_terms:\n            if self._find_lines(r\"\\b\" + re.escape(term) + r\"\\b\"):\n                found_terms.append(term)\n\n        if found_terms and not self._find_lines(r\"^## üìö Glossary\"):\n            self._add_result(\n                f\"Document contains technical terms \"\n                f\"({', '.join(found_terms[:3])}...). \"\n                \"Consider adding a Glossary section.\",\n                Severity.INFO,\n                0,\n            )\n\n    def validate_has_see_also(self) -> None:\n        \"\"\"Suggest adding a 'See Also' section with related resources.\"\"\"\n        if not self._find_lines(r\"^## üîó See Also\"):\n            self._add_result(\n                \"Consider adding a 'See Also' section with links to related resources\",\n                Severity.INFO,\n                len(self.lines) - 1,\n            )\n\n    def validate_has_faq(self) -> None:\n        \"\"\"Suggest adding an FAQ section.\"\"\"\n        question_marks = self._find_lines(r\"\\?\")\n        if question_marks and not self._find_lines(r\"^## ‚ùì FAQ\"):\n            self._add_result(\n                \"Document contains questions. Consider adding an FAQ section\",\n                Severity.INFO,\n                len(self.lines) - 1,\n            )\n\n    def validate_has_acknowledgments(self) -> None:\n        \"\"\"Suggest adding an acknowledgments section.\"\"\"\n        if not self._find_lines(r\"^## üôè Acknowledgments\"):\n            self._add_result(\n                \"Consider adding an Acknowledgments section to credit contributors\",\n                Severity.INFO,\n                len(self.lines) - 1,\n            )\n\n    def validate_all(self) -> List[ValidationResult]:\n        \"\"\"Run all validations.\"\"\"\n        # Structure validations\n        self.validate_has_learning_objectives()\n        self.validate_has_checklist()\n        self.validate_has_visual_representation()\n        self.validate_has_practical_exercise()\n        self.validate_has_conclusion()\n        self.validate_has_whats_next()\n\n        # Code quality validations\n        self.validate_code_blocks_have_language()\n        self.validate_code_quality()\n\n        # Content suggestions\n        self.validate_has_glossary()\n        self.validate_has_see_also()\n        self.validate_has_faq()\n        self.validate_has_acknowledgments()\n\n        return self.results\n\n\ndef print_validation_results(results: List[ValidationResult]) -> None:\n    \"\"\"Print validation results in a user-friendly format.\"\"\"\n    if not results:\n        print(\"‚úÖ No issues found!\")\n        return\n\n    # Group by severity\n    by_severity: Dict[Severity, List[ValidationResult]] = {\n        Severity.ERROR: [],\n        Severity.WARNING: [],\n        Severity.INFO: [],\n    }\n\n    for result in results:\n        by_severity[result.severity].append(result)\n\n    # Print by severity\n    for severity, results in by_severity.items():\n        if not results:\n            continue\n\n        print(f\"\\n{severity.name}S ({len(results)}):\")\n        print(\"=\" * (len(severity.name) + 10))\n\n        for result in results:\n            location = f\"line {result.line}\" if result.line is not None else \"document\"\n            if result.col is not None:\n                location += f\":{result.col}\"\n            print(f\"‚Ä¢ {result.message} (at {location})\")\n\n\ndef main() -> None:\n    \"\"\"Main entry point for the enhanced validator.\"\"\"\n    import sys\n\n    if len(sys.argv) != 2:\n        print(\"Usage: python enhanced_validator.py <markdown_file>\")\n        sys.exit(1)\n\n    file_path = sys.argv[1]\n    if not Path(file_path).exists():\n        print(f\"Error: File '{file_path}' not found\")\n        sys.exit(1)\n\n    validator = DuelCodeEnhancedValidator(file_path)\n    results = validator.validate_all()\n\n    print(f\"Validating: {file_path}\")\n    print(\"-\" * 50)\n\n    print_validation_results(results)\n\n    has_errors = any(r.severity == Severity.ERROR for r in results)\n    has_warnings = any(r.severity == Severity.WARNING for r in results)\n\n    if has_errors:\n        print(\"\\n‚ùå Validation failed with errors\")\n        sys.exit(1)\n    elif has_warnings:\n        print(\"\\n‚ö†Ô∏è  Validation passed with warnings\")\n    else:\n        print(\"\\n‚úÖ Validation passed successfully!\")\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "metadata": {},
  "relative_path": "src\\duelcode\\enhanced_validator.py",
  "id": "67c284db0dffbf87b624e52e93ab30c4"
}