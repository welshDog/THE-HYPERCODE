{
  "file_name": "code-analyzer.ts",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\src\\core\\hypercode-\\spatial_visualizer\\src\\code-analyzer.ts",
  "file_size": 7255,
  "created": "2025-11-15T15:54:41.032321",
  "modified": "2025-11-15T15:54:41.034333",
  "file_type": "code",
  "content_hash": "cf8c982913fdd5de61e9d13abd8b9f31",
  "content_type": "text",
  "content": "// import * as parser from 'typescript-ast-parser';\n\nexport interface CodeNode {\n  name: string;\n  type: 'function' | 'class' | 'variable' | 'import' | 'interface';\n  line: number;\n  complexity: number;\n  cognitiveLoad: number;\n  dependencies: string[];\n  description?: string;\n}\n\nexport interface CodeAnalysis {\n  nodes: CodeNode[];\n  relationships: Array<{ from: string; to: string; type: string }>;\n  cognitiveLoadScore: number;\n  language: string;\n  totalComplexity: number;\n}\n\nexport class CodeAnalyzer {\n  /**\n   * Analyzes code structure and relationships\n   * Returns spatial metadata for mind-map visualization\n   */\n  async analyze(code: string, language: string): Promise<CodeAnalysis> {\n    const nodes: CodeNode[] = [];\n    const relationships: Array<{ from: string; to: string; type: string }> = [];\n\n    try {\n      // Parse based on language\n      if (language === 'python' || language === 'py') {\n        return this.analyzePython(code);\n      } else if (language === 'javascript' || language === 'typescript') {\n        return this.analyzeJavaScript(code);\n      } else {\n        return this.analyzeGeneric(code);\n      }\n    } catch (error) {\n      console.error('Analysis error:', error);\n      return {\n        nodes: [],\n        relationships: [],\n        cognitiveLoadScore: 0,\n        language,\n        totalComplexity: 0\n      };\n    }\n  }\n\n  private analyzePython(code: string): CodeAnalysis {\n    const nodes: CodeNode[] = [];\n    const lines = code.split('\\n');\n    const relationships: Array<{ from: string; to: string; type: string }> = [];\n\n    lines.forEach((line, idx) => {\n      const trimmed = line.trim();\n\n      // Detect functions\n      if (trimmed.startsWith('def ')) {\n        const match = trimmed.match(/def\\s+(\\w+)\\s*\\(/);\n        if (match) {\n          nodes.push({\n            name: match[1],\n            type: 'function',\n            line: idx + 1,\n            complexity: this.calculateComplexity(code, match[1]),\n            cognitiveLoad: this.calculateCognitiveLoad(line),\n            dependencies: this.extractDependencies(code, match[1])\n          });\n        }\n      }\n\n      // Detect classes\n      if (trimmed.startsWith('class ')) {\n        const match = trimmed.match(/class\\s+(\\w+)/);\n        if (match) {\n          nodes.push({\n            name: match[1],\n            type: 'class',\n            line: idx + 1,\n            complexity: 0,\n            cognitiveLoad: this.calculateCognitiveLoad(line),\n            dependencies: []\n          });\n        }\n      }\n\n      // Detect imports\n      if (trimmed.startsWith('import ') || trimmed.startsWith('from ')) {\n        nodes.push({\n          name: trimmed,\n          type: 'import',\n          line: idx + 1,\n          complexity: 0,\n          cognitiveLoad: 1,\n          dependencies: []\n        });\n      }\n    });\n\n    const cognitiveLoadScore = nodes.reduce((sum, n) => sum + n.cognitiveLoad, 0) / Math.max(nodes.length, 1);\n    const totalComplexity = nodes.reduce((sum, n) => sum + n.complexity, 0);\n\n    return {\n      nodes,\n      relationships,\n      cognitiveLoadScore,\n      language: 'python',\n      totalComplexity\n    };\n  }\n\n  private analyzeJavaScript(code: string): CodeAnalysis {\n    const nodes: CodeNode[] = [];\n    const lines = code.split('\\n');\n\n    lines.forEach((line, idx) => {\n      const trimmed = line.trim();\n\n      // Detect functions\n      if (trimmed.match(/function\\s+\\w+|const\\s+\\w+\\s*=\\s*(async\\s*)?\\(/)) {\n        const match = trimmed.match(/(?:function\\s+|const\\s+)(\\w+)/);\n        if (match) {\n          nodes.push({\n            name: match[1],\n            type: 'function',\n            line: idx + 1,\n            complexity: this.calculateComplexity(code, match[1]),\n            cognitiveLoad: this.calculateCognitiveLoad(line),\n            dependencies: []\n          });\n        }\n      }\n\n      // Detect classes\n      if (trimmed.startsWith('class ')) {\n        const match = trimmed.match(/class\\s+(\\w+)/);\n        if (match) {\n          nodes.push({\n            name: match[1],\n            type: 'class',\n            line: idx + 1,\n            complexity: 0,\n            cognitiveLoad: this.calculateCognitiveLoad(line),\n            dependencies: []\n          });\n        }\n      }\n\n      // Detect imports\n      if (trimmed.startsWith('import ') || trimmed.startsWith('require(')) {\n        nodes.push({\n          name: trimmed,\n          type: 'import',\n          line: idx + 1,\n          complexity: 0,\n          cognitiveLoad: 1,\n          dependencies: []\n        });\n      }\n    });\n\n    const cognitiveLoadScore = nodes.reduce((sum, n) => sum + n.cognitiveLoad, 0) / Math.max(nodes.length, 1);\n    const totalComplexity = nodes.reduce((sum, n) => sum + n.complexity, 0);\n\n    return {\n      nodes,\n      relationships: [],\n      cognitiveLoadScore,\n      language: 'javascript',\n      totalComplexity\n    };\n  }\n\n  private analyzeGeneric(code: string): CodeAnalysis {\n    const nodes: CodeNode[] = [];\n    const lines = code.split('\\n');\n\n    lines.forEach((line, idx) => {\n      if (line.trim().length > 0) {\n        nodes.push({\n          name: line.trim().substring(0, 50),\n          type: 'variable',\n          line: idx + 1,\n          complexity: 0,\n          cognitiveLoad: 1,\n          dependencies: []\n        });\n      }\n    });\n\n    return {\n      nodes: nodes.slice(0, 20),\n      relationships: [],\n      cognitiveLoadScore: 1,\n      language: 'unknown',\n      totalComplexity: 0\n    };\n  }\n\n  private calculateComplexity(code: string, funcName: string): number {\n    // Simplified cyclomatic complexity estimation\n    const funcStart = code.indexOf(funcName);\n    if (funcStart === -1) return 1;\n\n    const funcEnd = code.indexOf('\\n\\n', funcStart) || code.length;\n    const funcCode = code.substring(funcStart, funcEnd);\n\n    const ifCount = (funcCode.match(/\\bif\\b/g) || []).length;\n    const forCount = (funcCode.match(/\\bfor\\b/g) || []).length;\n    const whileCount = (funcCode.match(/\\bwhile\\b/g) || []).length;\n    const caseCount = (funcCode.match(/\\bcase\\b/g) || []).length;\n\n    return 1 + ifCount + forCount + whileCount + caseCount;\n  }\n\n  private calculateCognitiveLoad(line: string): number {\n    let load = 1;\n    load += (line.match(/\\(/g) || []).length * 0.2;\n    load += (line.match(/\\{/g) || []).length * 0.2;\n    load += (line.length > 80) ? 0.5 : 0;\n    return Math.min(load, 10);\n  }\n\n  private extractDependencies(code: string, funcName: string): string[] {\n    const deps: string[] = [];\n    const funcStart = code.indexOf(`function ${funcName}`) || code.indexOf(`def ${funcName}`);\n    if (funcStart === -1) return deps;\n\n    const funcEnd = code.indexOf('\\n\\n', funcStart) || code.length;\n    const funcCode = code.substring(funcStart, funcEnd);\n\n    const callMatches = funcCode.matchAll(/(\\w+)\\s*\\(/g);\n    for (const match of callMatches) {\n      if (match[1] !== funcName && !['if', 'for', 'while', 'return'].includes(match[1])) {\n        deps.push(match[1]);\n      }\n    }\n\n    return [...new Set(deps)];\n  }\n}\n",
  "metadata": {},
  "relative_path": "src\\core\\hypercode-\\spatial_visualizer\\src\\code-analyzer.ts",
  "id": "415c56acdfd36a553fdbc55c556b6c85"
}