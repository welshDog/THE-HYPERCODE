{
  "file_name": "hypercode_syntax.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\src\\core\\hypercode-\\mcp\\servers\\hypercode_syntax.py",
  "file_size": 11827,
  "created": "2025-11-16T20:48:14.032809",
  "modified": "2025-11-19T16:10:36.252088",
  "file_type": "code",
  "content_hash": "8534736318041044852764a46a8c034a",
  "content_type": "text",
  "content": "#!/usr/bin/env python3\n\"\"\"\nHyperCode Syntax MCP Server\nProvides real-time syntax highlighting, parsing, and neurodiversity features for IDEs\n\"\"\"\n\nimport asyncio\nimport json\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List\n\n# Add src to path for importing parser\nsys.path.append(str(Path(__file__).parent.parent.parent / \"src\" / \"parser\"))\ntry:\n    from visual_syntax_parser import (\n        ParsedFunction,\n        SemanticAnnotation,\n        VisualSyntaxParser,\n    )\nexcept ImportError:\n    # Fallback if parser module not available\n    ParsedFunction = Any\n    SemanticAnnotation = Any\n    VisualSyntaxParser = Any\n\n\nclass HyperCodeSyntaxServer:\n    \"\"\"ðŸŽ¨ MCP Server for HyperCode Visual Syntax Integration\"\"\"\n\n    def __init__(self) -> None:\n        self.parser = VisualSyntaxParser()\n        self.cache: Dict[str, Any] = {}\n\n    async def handle_request(self, request: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Handle MCP requests from IDE\"\"\"\n\n        method = request.get(\"method\")\n        params = request.get(\"params\", {})\n\n        if method == \"initialize\":\n            return self._initialize(params)\n        elif method == \"textDocument/didChange\":\n            return await self._document_changed(params)\n        elif method == \"textDocument/hover\":\n            return await self._text_hover(params)\n        elif method == \"textDocument/completion\":\n            return await self._completion(params)\n        elif method == \"hypercode/parse\":\n            return await self._parse_document(params)\n        elif method == \"hypercode/validate\":\n            return await self._validate_neurodiversity(params)\n        else:\n            return {\"error\": f\"Unknown method: {method}\"}\n\n    def _initialize(self, _params: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Initialize the MCP server\"\"\"\n        return {\n            \"capabilities\": {\n                \"textDocumentSync\": 1,\n                \"hoverProvider\": True,\n                \"completionProvider\": {\"resolveProvider\": False},\n                \"semanticTokensProvider\": {\n                    \"legend\": {\n                        \"tokenTypes\": [\n                            \"annotation\",\n                            \"function\",\n                            \"parameter\",\n                            \"neurodiverse\",\n                            \"semantic\",\n                            \"accessibility\",\n                        ],\n                        \"tokenModifiers\": [\"bold\", \"italic\", \"underline\"],\n                    }\n                },\n            }\n        }\n\n    async def _document_changed(self, params: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Handle document changes for real-time parsing\"\"\"\n        doc = params.get(\"textDocument\", {})\n        uri = doc.get(\"uri\")\n        content = params.get(\"content\", [])\n\n        # Update content\n        full_content = \"\\n\".join(change.get(\"text\", \"\") for change in content)\n        self.cache[uri] = full_content\n\n        # Parse and provide diagnostics\n        functions = self.parser.parse_content(full_content)\n        diagnostics = self._generate_diagnostics(functions)\n\n        return {\n            \"method\": \"textDocument/publishDiagnostics\",\n            \"params\": {\"uri\": uri, \"diagnostics\": diagnostics},\n        }\n\n    async def _text_hover(self, params: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Provide hover information for semantic annotations\"\"\"\n        position = params.get(\"position\", {})\n        uri = params.get(\"textDocument\", {}).get(\"uri\")\n\n        content = self.cache.get(uri, \"\")\n        lines = content.split(\"\\n\")\n\n        if position[\"line\"] < len(lines):\n            line = lines[position[\"line\"]]\n\n            # Check if line contains semantic annotation\n            annotations = self.parser._parse_line_annotations(\n                line, position[\"line\"] + 1\n            )\n            if annotations:\n                annotation = annotations[0]\n                hover_info = self._get_annotation_hover_info(annotation)\n\n                return {\"contents\": {\"kind\": \"markdown\", \"value\": hover_info}}\n\n        return {\"contents\": None}\n\n    async def _completion(self, _params: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Provide completion for semantic annotations\"\"\"\n        completions = []\n\n        # Emoji-based completions\n        annotations = [\n            \"ðŸ” @verifiable(...)\",\n            \"ðŸ“ @ensures(...)\",\n            \"ðŸ“‹ @requires(...)\",\n            \"ðŸ§  @intent(...)\",\n            \"ðŸŽ¯ @accessibility(...)\",\n            \"ðŸŽ¨ @computation(...)\",\n            \"âš¡ @operation(...)\",\n            \"ðŸ”„ @return(...)\",\n        ]\n\n        for annotation in annotations:\n            completions.append(\n                {\n                    \"label\": annotation,\n                    \"kind\": 15,  # Snippet\n                    \"insertText\": annotation,\n                    \"detail\": \"HyperCode semantic annotation\",\n                    \"documentation\": f\"Add {annotation} semantic marker\",\n                }\n            )\n\n        return {\"items\": completions}\n\n    async def _parse_document(self, params: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Parse entire document and return semantic structure\"\"\"\n        uri = params.get(\"uri\")\n        content = self.cache.get(uri or \"\", \"\")\n\n        functions = self.parser.parse_content(content)\n\n        return {\n            \"functions\": [\n                {\n                    \"name\": func.name,\n                    \"line\": func.line_start,\n                    \"annotations\": [\n                        {\n                            \"marker\": ann.marker.value,\n                            \"params\": ann.params,\n                            \"line\": ann.line_number,\n                        }\n                        for ann in func.annotations\n                    ],\n                    \"cognitive_load\": len(func.annotations),\n                }\n                for func in functions\n            ],\n            \"neurodiversity_compliance\": (\n                self.parser.calculate_neurodiversity_compliance(functions)\n            ),\n        }\n\n    async def _validate_neurodiversity(self, params: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Validate neurodiversity compliance and provide suggestions\"\"\"\n        uri = params.get(\"uri\")\n        content = self.cache.get(uri or \"\", \"\")\n\n        functions = self.parser.parse_content(content)\n        compliance = self.parser.calculate_neurodiversity_compliance(functions)\n\n        suggestions = []\n\n        # Check for missing accessibility annotations\n        for func in functions:\n            accessibility_marker = \"ðŸŽ¯\"\n            has_accessibility = any(\n                ann.marker.value == accessibility_marker for ann in func.annotations\n            )\n            if not has_accessibility:\n                suggestions.append(\n                    {\n                        \"line\": func.line_start,\n                        \"message\": (\n                            \"Consider adding ðŸŽ¯ @accessibility annotation \"\n                            \"for neurodiversity compliance\"\n                        ),\n                        \"severity\": \"info\",\n                        \"suggestion\": (\n                            'ðŸŽ¯ @accessibility(\"high_contrast\", \"screen_reader\")'\n                        ),\n                    }\n                )\n\n        return {\n            \"compliance_score\": compliance,\n            \"suggestions\": suggestions,\n            \"status\": \"compliant\" if compliance >= 80.0 else \"needs_improvement\",\n        }\n\n    def _generate_diagnostics(\n        self, functions: List[ParsedFunction]\n    ) -> List[Dict[str, Any]]:\n        \"\"\"Generate IDE diagnostics from parsed functions\"\"\"\n        diagnostics = []\n\n        # Calculate cognitive load for each function\n        for func in functions:\n            cognitive_load = len(func.annotations)\n\n            # Check cognitive load\n            if cognitive_load > 7:\n                diagnostics.append(\n                    {\n                        \"range\": {\n                            \"start\": {\"line\": func.line_start - 1, \"character\": 0},\n                            \"end\": {\n                                \"line\": func.line_start - 1,\n                                \"character\": len(func.name),\n                            },\n                        },\n                        \"severity\": 2,  # Warning\n                        \"message\": (\n                            f\"High cognitive load ({cognitive_load:.1f}) - \"\n                            \"consider simplifying\"\n                        ),\n                        \"source\": \"HyperCode Neurodiversity\",\n                    }\n                )\n\n            # Check for missing intent annotations\n            has_intent = any(ann.marker.value == \"ðŸ§ \" for ann in func.annotations)\n            if not has_intent:\n                diagnostics.append(\n                    {\n                        \"range\": {\n                            \"start\": {\"line\": func.line_start - 1, \"character\": 0},\n                            \"end\": {\n                                \"line\": func.line_start - 1,\n                                \"character\": len(func.name),\n                            },\n                        },\n                        \"severity\": 1,  # Info\n                        \"message\": \"Consider adding ðŸ§  @intent annotation for clarity\",\n                        \"source\": \"HyperCode Neurodiversity\",\n                    }\n                )\n\n        return diagnostics\n\n    def _get_annotation_hover_info(self, annotation: SemanticAnnotation) -> str:\n        \"\"\"Generate hover information for semantic annotations\"\"\"\n        marker_info = {\n            \"ðŸ”\": \"Verifiable - Formal verification and proof annotations\",\n            \"ðŸ“\": \"Ensures - Postconditions and guarantees\",\n            \"ðŸ“‹\": \"Requires - Preconditions and dependencies\",\n            \"ðŸ§ \": \"Intent - Purpose and cognitive context\",\n            \"ðŸŽ¯\": \"Accessibility - Neurodiversity and inclusive design\",\n            \"ðŸŽ¨\": \"Computation - Computational complexity and behavior\",\n            \"âš¡\": \"Operation - Runtime operations and side effects\",\n            \"ðŸ”„\": \"Return - Return value specifications\",\n        }\n\n        info = marker_info.get(annotation.marker.value, \"Unknown semantic marker\")\n\n        hover = f\"## {annotation.marker.value} {annotation.marker.name}\\n\\n\"\n        hover += f\"{info}\\n\\n\"\n\n        if annotation.params:\n            hover += \"**Parameters:**\\n\"\n            for key, value in annotation.params.items():\n                hover += f\"- `{key}`: {value}\\n\"\n\n        hover += f\"\\n*Line {annotation.line_number}*\"\n\n        return hover\n\n\nasync def main() -> None:\n    \"\"\"Main MCP server loop\"\"\"\n    server = HyperCodeSyntaxServer()\n\n    try:\n        while True:\n            line = await asyncio.get_event_loop().run_in_executor(\n                None, sys.stdin.readline\n            )\n\n            if not line:\n                break\n\n            try:\n                request = json.loads(line.strip())\n                response = await server.handle_request(request)\n\n                if response:\n                    print(json.dumps(response), flush=True)\n\n            except json.JSONDecodeError:\n                print(json.dumps({\"error\": \"Invalid JSON\"}), flush=True)\n            except Exception as e:\n                print(json.dumps({\"error\": str(e)}), flush=True)\n\n    except KeyboardInterrupt:\n        pass\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
  "metadata": {},
  "relative_path": "src\\core\\hypercode-\\mcp\\servers\\hypercode_syntax.py",
  "id": "57b229a8d91c8b5ece60658478080147"
}