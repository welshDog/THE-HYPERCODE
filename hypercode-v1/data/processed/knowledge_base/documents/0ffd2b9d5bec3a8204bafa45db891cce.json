{
  "file_name": "app.js",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\src\\core\\hypercode-\\hypercode-proto\\app.js",
  "file_size": 23563,
  "created": "2025-11-15T15:54:40.996027",
  "modified": "2025-11-17T18:15:39.032068",
  "file_type": "code",
  "content_hash": "3a054e1e5af2a0e252bc9a3b1657aee9",
  "content_type": "text",
  "content": "// HyperCode - Neurodivergent-Friendly Visual Coding Platform\n\n// ==================== DATA MODELS ====================\n\nconst nodeTypes = {\n  function: {\n    color: \"#4A90E2\",\n    icon: \"∆í\",\n    description: \"Function block\",\n    codeTemplate: \"def my_function():\\n    pass\",\n  },\n  loop: {\n    color: \"#50C878\",\n    icon: \"‚ü≤\",\n    description: \"Loop block\",\n    codeTemplate: \"for i in range(10):\\n    pass\",\n  },\n  condition: {\n    color: \"#F39C12\",\n    icon: \"?\",\n    description: \"Conditional block\",\n    codeTemplate: \"if condition:\\n    pass\",\n  },\n  data: {\n    color: \"#9B59B6\",\n    icon: \"‚ñ°\",\n    description: \"Data block\",\n    codeTemplate: \"data = None\",\n  },\n  output: {\n    color: \"#E74C3C\",\n    icon: \"‚Üí\",\n    description: \"Output block\",\n    codeTemplate: \"print(result)\",\n  },\n};\n\nconst sampleTasks = [\n  { title: \"Create main function\", status: \"done\", time: 15 },\n  { title: \"Add input validation\", status: \"in-progress\", time: 20 },\n  { title: \"Connect to output\", status: \"todo\", time: 10 },\n];\n\nconst accessibilityPresets = {\n  adhd: { theme: \"dark\", animations: 0, fontSize: \"large\" },\n  autism: { theme: \"high-contrast\", animations: 0, fontSize: \"medium\" },\n  dyslexia: { theme: \"light\", font: \"opendyslexic\", fontSize: \"large\" },\n};\n\n// ==================== STATE MANAGEMENT ====================\n\nconst state = {\n  nodes: [],\n  connections: [],\n  tasks: [...sampleTasks],\n  selectedNode: null,\n  nextNodeId: 1,\n  focusMode: false,\n  theme: \"dark\",\n  animationSpeed: 100,\n  fontSize: \"medium\",\n  useOpenDyslexic: false,\n  draggedNode: null,\n  dragOffset: { x: 0, y: 0 },\n  connectingFrom: null,\n};\n\n// ==================== INITIALIZATION ====================\n\nfunction init() {\n  setupEventListeners();\n  renderTasks();\n  updateProgress();\n\n  // Add sample nodes\n  addNode(\"function\", 100, 100);\n  addNode(\"data\", 300, 150);\n\n  updateCode();\n  announce(\"HyperCode initialized. Visual coding environment ready.\");\n}\n\n// ==================== EVENT LISTENERS ====================\n\nfunction setupEventListeners() {\n  // Theme buttons\n  document\n    .getElementById(\"theme-light\")\n    .addEventListener(\"click\", () => setTheme(\"light\"));\n  document\n    .getElementById(\"theme-dark\")\n    .addEventListener(\"click\", () => setTheme(\"dark\"));\n  document\n    .getElementById(\"theme-contrast\")\n    .addEventListener(\"click\", () => setTheme(\"high-contrast\"));\n\n  // Focus mode\n  document.getElementById(\"focus-mode\").addEventListener(\"click\", toggleFocusMode);\n\n  // Sidebar toggles\n  document.getElementById(\"toggle-sidebar-left\").addEventListener(\"click\", () => {\n    document.querySelector(\".sidebar\").classList.toggle(\"collapsed\");\n  });\n  document.getElementById(\"toggle-sidebar-right\").addEventListener(\"click\", () => {\n    document.querySelector(\".sidebar-right\").classList.toggle(\"collapsed\");\n  });\n\n  // Panel toggle\n  document.getElementById(\"toggle-panel\").addEventListener(\"click\", () => {\n    const panel = document.getElementById(\"bottom-panel\");\n    panel.classList.toggle(\"collapsed\");\n    document.getElementById(\"toggle-panel\").textContent = panel.classList.contains(\n      \"collapsed\",\n    )\n      ? \"‚ñ≤\"\n      : \"‚ñº\";\n  });\n\n  // Node type buttons\n  document.querySelectorAll(\"[data-node-type]\").forEach((btn) => {\n    btn.addEventListener(\"click\", (e) => {\n      const type = e.currentTarget.getAttribute(\"data-node-type\");\n      const x = Math.random() * 400 + 100;\n      const y = Math.random() * 300 + 100;\n      addNode(type, x, y);\n      announce(`${nodeTypes[type].description} added to canvas`);\n    });\n  });\n\n  // Run code\n  document.getElementById(\"run-code\").addEventListener(\"click\", runCode);\n\n  // Clear canvas\n  document.getElementById(\"clear-canvas\").addEventListener(\"click\", () => {\n    if (confirm(\"Clear all nodes?\")) {\n      state.nodes = [];\n      state.connections = [];\n      renderNodes();\n      updateCode();\n      announce(\"Canvas cleared\");\n    }\n  });\n\n  // Add task form\n  document.getElementById(\"add-task-form\").addEventListener(\"submit\", (e) => {\n    e.preventDefault();\n    const title = document.getElementById(\"new-task-title\").value.trim();\n    const time = parseInt(document.getElementById(\"new-task-time\").value) || 10;\n\n    if (title) {\n      state.tasks.push({ title, status: \"todo\", time });\n      renderTasks();\n      updateProgress();\n      document.getElementById(\"new-task-title\").value = \"\";\n      document.getElementById(\"new-task-time\").value = \"\";\n      announce(`Task \"${title}\" added`);\n    }\n  });\n\n  // Font size\n  document.getElementById(\"font-size-select\").addEventListener(\"change\", (e) => {\n    setFontSize(e.target.value);\n  });\n\n  // OpenDyslexic font\n  document.getElementById(\"opendyslexic-font\").addEventListener(\"change\", (e) => {\n    state.useOpenDyslexic = e.target.checked;\n    document.body.classList.toggle(\"font-opendyslexic\", e.target.checked);\n    announce(e.target.checked ? \"OpenDyslexic font enabled\" : \"Default font restored\");\n  });\n\n  // Animation speed\n  document.getElementById(\"animation-speed\").addEventListener(\"input\", (e) => {\n    const value = e.target.value;\n    document.getElementById(\"animation-value\").textContent = value;\n    state.animationSpeed = value;\n    document.documentElement.style.setProperty(\"--animation-speed\", value / 100);\n\n    if (value === \"0\") {\n      document.body.classList.add(\"no-animations\");\n    } else {\n      document.body.classList.remove(\"no-animations\");\n    }\n  });\n\n  // Preset buttons\n  document.querySelectorAll(\"[data-preset]\").forEach((btn) => {\n    btn.addEventListener(\"click\", (e) => {\n      const preset = e.currentTarget.getAttribute(\"data-preset\");\n      applyPreset(preset);\n    });\n  });\n\n  // Esoteric info toggle\n  document.getElementById(\"toggle-esoteric\").addEventListener(\"click\", (e) => {\n    const info = document.getElementById(\"esoteric-info\");\n    const isVisible = info.style.display !== \"none\";\n    info.style.display = isVisible ? \"none\" : \"block\";\n    e.target.textContent = isVisible ? \"Show Influences\" : \"Hide Influences\";\n  });\n\n  // Voice command\n  document.getElementById(\"voice-fab\").addEventListener(\"click\", () => {\n    const panel = document.getElementById(\"voice-panel\");\n    panel.classList.toggle(\"active\");\n    if (panel.classList.contains(\"active\")) {\n      document.getElementById(\"voice-input\").focus();\n    }\n  });\n\n  document\n    .getElementById(\"voice-submit\")\n    .addEventListener(\"click\", processVoiceCommand);\n  document.getElementById(\"voice-input\").addEventListener(\"keypress\", (e) => {\n    if (e.key === \"Enter\") {\n      processVoiceCommand();\n    }\n  });\n\n  // Keyboard shortcuts\n  document.addEventListener(\"keydown\", (e) => {\n    if (e.target.tagName === \"INPUT\" || e.target.tagName === \"TEXTAREA\") return;\n\n    if (e.key === \"f\" || e.key === \"F\") {\n      toggleFocusMode();\n    } else if (e.key === \"r\" || e.key === \"R\") {\n      runCode();\n    } else if (e.key === \"Delete\" && state.selectedNode) {\n      deleteNode(state.selectedNode);\n    }\n  });\n\n  // Canvas interactions\n  const canvas = document.getElementById(\"canvas-content\");\n  canvas.addEventListener(\"mousedown\", handleCanvasMouseDown);\n  canvas.addEventListener(\"mousemove\", handleCanvasMouseMove);\n  canvas.addEventListener(\"mouseup\", handleCanvasMouseUp);\n}\n\n// ==================== NODE MANAGEMENT ====================\n\nfunction addNode(type, x, y) {\n  const node = {\n    id: state.nextNodeId++,\n    type,\n    x,\n    y,\n    data: {\n      name: `${type}_${state.nextNodeId}`,\n    },\n  };\n\n  state.nodes.push(node);\n  renderNodes();\n  updateCode();\n}\n\nfunction renderNodes() {\n  const container = document.getElementById(\"canvas-content\");\n  container.querySelectorAll(\".node\").forEach((el) => el.remove());\n\n  state.nodes.forEach((node) => {\n    const nodeEl = createNodeElement(node);\n    container.appendChild(nodeEl);\n  });\n\n  renderConnections();\n}\n\nfunction createNodeElement(node) {\n  const div = document.createElement(\"div\");\n  div.className = \"node\";\n  div.id = `node-${node.id}`;\n  div.style.left = `${node.x}px`;\n  div.style.top = `${node.y}px`;\n  div.style.borderColor = nodeTypes[node.type].color;\n  div.setAttribute(\"data-node-id\", node.id);\n  div.setAttribute(\"role\", \"button\");\n  div.setAttribute(\"tabindex\", \"0\");\n  div.setAttribute(\"aria-label\", `${nodeTypes[node.type].description} node`);\n\n  const typeInfo = nodeTypes[node.type];\n\n  div.innerHTML = `\n    <div class=\"node-header\">\n      <span class=\"node-icon\" style=\"color: ${typeInfo.color}\">${typeInfo.icon}</span>\n      <span class=\"node-title\">${node.data.name}</span>\n    </div>\n    <div class=\"node-content\">${typeInfo.description}</div>\n    <div class=\"node-code\">${typeInfo.codeTemplate.split(\"\\n\")[0]}</div>\n    <div class=\"node-ports\">\n      <div class=\"node-port input-port\" data-port=\"input\"></div>\n      <div class=\"node-port output-port\" data-port=\"output\"></div>\n    </div>\n  `;\n\n  // Node selection\n  div.addEventListener(\"click\", (e) => {\n    if (e.target.classList.contains(\"node-port\")) return;\n    selectNode(node.id);\n  });\n\n  // Port connections\n  div.querySelectorAll(\".node-port\").forEach((port) => {\n    port.addEventListener(\"click\", (e) => {\n      e.stopPropagation();\n      handlePortClick(node.id, e.target.getAttribute(\"data-port\"));\n    });\n  });\n\n  return div;\n}\n\nfunction selectNode(nodeId) {\n  state.selectedNode = nodeId;\n  document.querySelectorAll(\".node\").forEach((el) => {\n    el.classList.remove(\"selected\");\n  });\n  document.getElementById(`node-${nodeId}`)?.classList.add(\"selected\");\n}\n\nfunction deleteNode(nodeId) {\n  state.nodes = state.nodes.filter((n) => n.id !== nodeId);\n  state.connections = state.connections.filter(\n    (c) => c.from !== nodeId && c.to !== nodeId,\n  );\n  state.selectedNode = null;\n  renderNodes();\n  updateCode();\n  announce(\"Node deleted\");\n}\n\nfunction handlePortClick(nodeId, portType) {\n  if (portType === \"output\") {\n    state.connectingFrom = nodeId;\n    announce(\"Select an input port to connect to\");\n  } else if (portType === \"input\" && state.connectingFrom) {\n    addConnection(state.connectingFrom, nodeId);\n    state.connectingFrom = null;\n    announce(\"Nodes connected\");\n  }\n}\n\nfunction addConnection(fromId, toId) {\n  if (!state.connections.find((c) => c.from === fromId && c.to === toId)) {\n    state.connections.push({ from: fromId, to: toId });\n    renderConnections();\n    updateCode();\n  }\n}\n\nfunction renderConnections() {\n  const svg = document.getElementById(\"connections-svg\");\n  svg.innerHTML = \"\";\n\n  state.connections.forEach((conn) => {\n    const fromNode = document.getElementById(`node-${conn.from}`);\n    const toNode = document.getElementById(`node-${conn.to}`);\n\n    if (!fromNode || !toNode) return;\n\n    const fromRect = fromNode.getBoundingClientRect();\n    const toRect = toNode.getBoundingClientRect();\n    const canvasRect = document\n      .getElementById(\"canvas-content\")\n      .getBoundingClientRect();\n\n    const x1 = fromRect.left - canvasRect.left + fromRect.width;\n    const y1 = fromRect.top - canvasRect.top + fromRect.height / 2;\n    const x2 = toRect.left - canvasRect.left;\n    const y2 = toRect.top - canvasRect.top + toRect.height / 2;\n\n    const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    const midX = (x1 + x2) / 2;\n    const d = `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`;\n    path.setAttribute(\"d\", d);\n    path.setAttribute(\"class\", \"connection-line\");\n    svg.appendChild(path);\n  });\n}\n\n// ==================== DRAG AND DROP ====================\n\nfunction handleCanvasMouseDown(e) {\n  const nodeEl = e.target.closest(\".node\");\n  if (!nodeEl) return;\n\n  const nodeId = parseInt(nodeEl.getAttribute(\"data-node-id\"));\n  const node = state.nodes.find((n) => n.id === nodeId);\n  if (!node) return;\n\n  state.draggedNode = node;\n  const rect = nodeEl.getBoundingClientRect();\n  state.dragOffset = {\n    x: e.clientX - rect.left,\n    y: e.clientY - rect.top,\n  };\n\n  nodeEl.classList.add(\"dragging\");\n  e.preventDefault();\n}\n\nfunction handleCanvasMouseMove(e) {\n  if (!state.draggedNode) return;\n\n  const canvas = document.getElementById(\"canvas-content\");\n  const rect = canvas.getBoundingClientRect();\n\n  state.draggedNode.x = e.clientX - rect.left - state.dragOffset.x;\n  state.draggedNode.y = e.clientY - rect.top - state.dragOffset.y;\n\n  const nodeEl = document.getElementById(`node-${state.draggedNode.id}`);\n  nodeEl.style.left = `${state.draggedNode.x}px`;\n  nodeEl.style.top = `${state.draggedNode.y}px`;\n\n  renderConnections();\n}\n\nfunction handleCanvasMouseUp(e) {\n  if (state.draggedNode) {\n    const nodeEl = document.getElementById(`node-${state.draggedNode.id}`);\n    nodeEl?.classList.remove(\"dragging\");\n    state.draggedNode = null;\n  }\n}\n\n// ==================== CODE GENERATION ====================\n\nfunction updateCode() {\n  let code = \"# Generated Python Code\\n\\n\";\n\n  if (state.nodes.length === 0) {\n    code = \"# No nodes yet. Add nodes to generate code!\";\n  } else {\n    // Sort nodes by connections to create logical flow\n    const sorted = topologicalSort();\n\n    sorted.forEach((nodeId, index) => {\n      const node = state.nodes.find((n) => n.id === nodeId);\n      if (node) {\n        const typeInfo = nodeTypes[node.type];\n        code += `# ${node.data.name}\\n`;\n        code += typeInfo.codeTemplate + \"\\n\\n\";\n      }\n    });\n\n    if (state.connections.length > 0) {\n      code += \"# Connections:\\n\";\n      state.connections.forEach((conn) => {\n        const from = state.nodes.find((n) => n.id === conn.from);\n        const to = state.nodes.find((n) => n.id === conn.to);\n        if (from && to) {\n          code += `# ${from.data.name} -> ${to.data.name}\\n`;\n        }\n      });\n    }\n  }\n\n  document.getElementById(\"code-display\").textContent = code;\n}\n\nfunction topologicalSort() {\n  // Simple topological sort for node ordering\n  const visited = new Set();\n  const result = [];\n\n  function visit(nodeId) {\n    if (visited.has(nodeId)) return;\n    visited.add(nodeId);\n\n    // Visit children first\n    state.connections.filter((c) => c.from === nodeId).forEach((c) => visit(c.to));\n\n    result.unshift(nodeId);\n  }\n\n  state.nodes.forEach((node) => visit(node.id));\n  return result;\n}\n\nfunction runCode() {\n  const consoleEl = document.getElementById(\"console-output\");\n  consoleEl.innerHTML = \"\";\n\n  addConsoleLine(\"‚ñ∂Ô∏è Running code...\", \"info\");\n\n  setTimeout(() => {\n    if (state.nodes.length === 0) {\n      addConsoleLine(\"‚ö†Ô∏è No nodes to execute\", \"error\");\n      return;\n    }\n\n    addConsoleLine(\"‚úÖ Parsing nodes...\", \"success\");\n\n    state.nodes.forEach((node) => {\n      addConsoleLine(`  ‚Ä¢ Executing ${node.data.name} (${node.type})`, \"info\");\n    });\n\n    if (state.connections.length > 0) {\n      addConsoleLine(\"‚úÖ Processing connections...\", \"success\");\n      state.connections.forEach((conn) => {\n        const from = state.nodes.find((n) => n.id === conn.from);\n        const to = state.nodes.find((n) => n.id === conn.to);\n        if (from && to) {\n          addConsoleLine(`  ‚Ä¢ ${from.data.name} ‚Üí ${to.data.name}`, \"info\");\n        }\n      });\n    }\n\n    addConsoleLine(\"‚úÖ Execution complete!\", \"success\");\n    addConsoleLine(`Result: Generated ${state.nodes.length} operations`, \"success\");\n\n    announce(\"Code execution complete\");\n  }, 500);\n}\n\nfunction addConsoleLine(text, type = \"info\") {\n  const consoleEl = document.getElementById(\"console-output\");\n  const line = document.createElement(\"div\");\n  line.className = `console-line ${type}`;\n  line.textContent = text;\n  consoleEl.appendChild(line);\n  consoleEl.scrollTop = consoleEl.scrollHeight;\n}\n\n// ==================== TASK MANAGEMENT ====================\n\nfunction renderTasks() {\n  const container = document.getElementById(\"task-list\");\n  container.innerHTML = \"\";\n\n  state.tasks.forEach((task, index) => {\n    const taskEl = document.createElement(\"div\");\n    taskEl.className = \"task-item\";\n\n    taskEl.innerHTML = `\n      <div class=\"task-header\">\n        <span class=\"task-title\">${task.title}</span>\n        <span class=\"task-status status-${task.status}\">${task.status}</span>\n      </div>\n      <div class=\"task-time\">‚è±Ô∏è ${task.time} minutes</div>\n      <div class=\"task-actions\">\n        ${\n          task.status !== \"done\"\n            ? `<button class=\"btn btn-sm btn-primary\" data-task-index=\"${index}\" data-action=\"done\">‚úì Complete</button>`\n            : \"\"\n        }\n        ${\n          task.status === \"todo\"\n            ? `<button class=\"btn btn-sm\" data-task-index=\"${index}\" data-action=\"progress\">‚ñ∂Ô∏è Start</button>`\n            : \"\"\n        }\n        <button class=\"btn btn-sm\" data-task-index=\"${index}\" data-action=\"delete\">üóëÔ∏è</button>\n      </div>\n    `;\n\n    container.appendChild(taskEl);\n  });\n\n  // Task action buttons\n  container.querySelectorAll(\"[data-action]\").forEach((btn) => {\n    btn.addEventListener(\"click\", (e) => {\n      const index = parseInt(e.currentTarget.getAttribute(\"data-task-index\"));\n      const action = e.currentTarget.getAttribute(\"data-action\");\n      handleTaskAction(index, action);\n    });\n  });\n}\n\nfunction handleTaskAction(index, action) {\n  const task = state.tasks[index];\n\n  if (action === \"done\") {\n    task.status = \"done\";\n    renderTasks();\n    updateProgress();\n    celebrate();\n    announce(`Task \"${task.title}\" completed!`);\n  } else if (action === \"progress\") {\n    task.status = \"in-progress\";\n    renderTasks();\n    updateProgress();\n    announce(`Task \"${task.title}\" started`);\n  } else if (action === \"delete\") {\n    state.tasks.splice(index, 1);\n    renderTasks();\n    updateProgress();\n    announce(\"Task deleted\");\n  }\n}\n\nfunction updateProgress() {\n  const done = state.tasks.filter((t) => t.status === \"done\").length;\n  const total = state.tasks.length;\n  const percent = total > 0 ? (done / total) * 100 : 0;\n\n  document.getElementById(\"overall-progress\").style.width = `${percent}%`;\n}\n\nfunction celebrate() {\n  if (state.animationSpeed > 0) {\n    const taskList = document.getElementById(\"task-list\");\n    taskList.classList.add(\"celebrating\");\n    setTimeout(() => taskList.classList.remove(\"celebrating\"), 500);\n  }\n}\n\n// ==================== VOICE COMMANDS ====================\n\nfunction processVoiceCommand() {\n  const input = document.getElementById(\"voice-input\").value.toLowerCase().trim();\n  const feedback = document.getElementById(\"voice-feedback\");\n\n  if (!input) return;\n\n  let executed = false;\n  let message = \"\";\n\n  if (input.includes(\"create function\") || input.includes(\"add function\")) {\n    addNode(\"function\", Math.random() * 400 + 100, Math.random() * 300 + 100);\n    message = \"Function node created\";\n    executed = true;\n  } else if (input.includes(\"add loop\") || input.includes(\"create loop\")) {\n    addNode(\"loop\", Math.random() * 400 + 100, Math.random() * 300 + 100);\n    message = \"Loop node created\";\n    executed = true;\n  } else if (input.includes(\"add condition\") || input.includes(\"create condition\")) {\n    addNode(\"condition\", Math.random() * 400 + 100, Math.random() * 300 + 100);\n    message = \"Condition node created\";\n    executed = true;\n  } else if (input.includes(\"add data\") || input.includes(\"create data\")) {\n    addNode(\"data\", Math.random() * 400 + 100, Math.random() * 300 + 100);\n    message = \"Data node created\";\n    executed = true;\n  } else if (input.includes(\"add output\") || input.includes(\"create output\")) {\n    addNode(\"output\", Math.random() * 400 + 100, Math.random() * 300 + 100);\n    message = \"Output node created\";\n    executed = true;\n  } else if (input.includes(\"focus mode\") || input.includes(\"enable focus\")) {\n    toggleFocusMode();\n    message = state.focusMode ? \"Focus mode enabled\" : \"Focus mode disabled\";\n    executed = true;\n  } else if (input.includes(\"run code\") || input.includes(\"execute\")) {\n    runCode();\n    message = \"Running code\";\n    executed = true;\n  } else if (input.includes(\"clear canvas\") || input.includes(\"clear all\")) {\n    state.nodes = [];\n    state.connections = [];\n    renderNodes();\n    updateCode();\n    message = \"Canvas cleared\";\n    executed = true;\n  } else if (input.includes(\"connect nodes\")) {\n    if (state.nodes.length >= 2) {\n      addConnection(state.nodes[0].id, state.nodes[1].id);\n      message = \"Nodes connected\";\n      executed = true;\n    } else {\n      message = \"Need at least 2 nodes to connect\";\n      executed = true;\n    }\n  }\n\n  if (executed) {\n    feedback.textContent = `‚úì ${message}`;\n    feedback.classList.add(\"active\");\n    announce(message);\n\n    setTimeout(() => {\n      feedback.classList.remove(\"active\");\n    }, 3000);\n\n    document.getElementById(\"voice-input\").value = \"\";\n  } else {\n    feedback.textContent = \"‚ùå Command not recognized\";\n    feedback.style.borderColor = \"var(--color-error)\";\n    feedback.style.color = \"var(--color-error)\";\n    feedback.classList.add(\"active\");\n\n    setTimeout(() => {\n      feedback.classList.remove(\"active\");\n      feedback.style.borderColor = \"\";\n      feedback.style.color = \"\";\n    }, 3000);\n  }\n}\n\n// ==================== THEME & ACCESSIBILITY ====================\n\nfunction setTheme(theme) {\n  state.theme = theme;\n  document.documentElement.setAttribute(\"data-theme\", theme);\n\n  // Update active button\n  document.querySelectorAll('[id^=\"theme-\"]').forEach((btn) => {\n    btn.classList.remove(\"active\");\n  });\n  document.getElementById(`theme-${theme}`).classList.add(\"active\");\n\n  announce(`${theme} theme activated`);\n}\n\nfunction setFontSize(size) {\n  state.fontSize = size;\n  document.body.className = document.body.className.replace(/font-\\w+/g, \"\");\n  document.body.classList.add(`font-${size}`);\n  if (state.useOpenDyslexic) {\n    document.body.classList.add(\"font-opendyslexic\");\n  }\n  announce(`Font size set to ${size}`);\n}\n\nfunction toggleFocusMode() {\n  state.focusMode = !state.focusMode;\n  document.body.classList.toggle(\"focus-mode\", state.focusMode);\n  document.getElementById(\"focus-mode\").classList.toggle(\"active\", state.focusMode);\n  document.getElementById(\"focus-mode\").setAttribute(\"aria-pressed\", state.focusMode);\n  announce(state.focusMode ? \"Focus mode enabled\" : \"Focus mode disabled\");\n}\n\nfunction applyPreset(presetName) {\n  const preset = accessibilityPresets[presetName];\n  if (!preset) return;\n\n  // Apply theme\n  if (preset.theme) {\n    setTheme(preset.theme);\n  }\n\n  // Apply animations\n  if (preset.animations !== undefined) {\n    state.animationSpeed = preset.animations;\n    document.getElementById(\"animation-speed\").value = preset.animations;\n    document.getElementById(\"animation-value\").textContent = preset.animations;\n    document.documentElement.style.setProperty(\n      \"--animation-speed\",\n      preset.animations / 100,\n    );\n    document.body.classList.toggle(\"no-animations\", preset.animations === 0);\n  }\n\n  // Apply font size\n  if (preset.fontSize) {\n    setFontSize(preset.fontSize);\n    document.getElementById(\"font-size-select\").value = preset.fontSize;\n  }\n\n  // Apply font type\n  if (preset.font === \"opendyslexic\") {\n    state.useOpenDyslexic = true;\n    document.body.classList.add(\"font-opendyslexic\");\n    document.getElementById(\"opendyslexic-font\").checked = true;\n  }\n\n  announce(`${presetName.toUpperCase()}-friendly preset applied`);\n}\n\n// ==================== ACCESSIBILITY ====================\n\nfunction announce(message) {\n  const announcer = document.getElementById(\"sr-announcements\");\n  announcer.textContent = message;\n\n  // Clear after announcement\n  setTimeout(() => {\n    announcer.textContent = \"\";\n  }, 1000);\n}\n\n// ==================== START APPLICATION ====================\n\ndocument.addEventListener(\"DOMContentLoaded\", init);\n",
  "metadata": {},
  "relative_path": "src\\core\\hypercode-\\hypercode-proto\\app.js",
  "id": "0ffd2b9d5bec3a8204bafa45db891cce"
}