{
  "file_name": "document_processor.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\scripts\\document_processor.py",
  "file_size": 7555,
  "created": "2025-12-03T22:37:12.411597",
  "modified": "2025-12-03T22:37:24.820415",
  "file_type": "code",
  "content_hash": "8328d500589a18857229c0c1d0acd2c3",
  "content_type": "text",
  "content": "\"\"\"Document processing utilities for HyperCode knowledge base.\"\"\"\n\nfrom pathlib import Path\nfrom typing import Dict, Union\nimport PyPDF2\nimport docx\nimport markdown\nfrom bs4 import BeautifulSoup\nimport pandas as pd\nimport frontmatter\nimport hashlib\nfrom datetime import datetime\n\n\nclass DocumentProcessor:\n    \"\"\"Process various document types and extract content.\"\"\"\n\n    @staticmethod\n    def get_file_hash(file_path: Union[str, Path]) -> str:\n        \"\"\"Generate a hash for file content.\"\"\"\n        file_path = Path(file_path)\n        hasher = hashlib.md5()\n        with open(file_path, \"rb\") as f:\n            for chunk in iter(lambda: f.read(4096), b\"\"):\n                hasher.update(chunk)\n        return hasher.hexdigest()\n\n    @staticmethod\n    def extract_metadata(file_path: Union[str, Path]) -> Dict:\n        \"\"\"Extract basic metadata from any file.\"\"\"\n        path = Path(file_path)\n        return {\n            \"file_name\": path.name,\n            \"file_path\": str(path.absolute()),\n            \"file_size\": path.stat().st_size,\n            \"created\": datetime.fromtimestamp(path.stat().st_ctime).isoformat(),\n            \"modified\": datetime.fromtimestamp(path.stat().st_mtime).isoformat(),\n            \"file_type\": path.suffix.lower(),\n            \"content_hash\": DocumentProcessor.get_file_hash(path),\n        }\n\n    @staticmethod\n    def extract_pdf_content(file_path: Union[str, Path]) -> Dict:\n        \"\"\"Extract text content from PDF files.\"\"\"\n        content = {\"content_type\": \"text\", \"content\": \"\", \"pages\": 0, \"metadata\": {}}\n\n        try:\n            with open(file_path, \"rb\") as f:\n                pdf = PyPDF2.PdfReader(f)\n                content[\"pages\"] = len(pdf.pages)\n                content[\"content\"] = \"\\n\\n\".join(\n                    page.extract_text() for page in pdf.pages\n                )\n\n                # Extract metadata if available\n                if hasattr(pdf, \"metadata\") and pdf.metadata:\n                    content[\"metadata\"] = {\n                        \"title\": pdf.metadata.get(\"/Title\", \"\"),\n                        \"author\": pdf.metadata.get(\"/Author\", \"\"),\n                        \"subject\": pdf.metadata.get(\"/Subject\", \"\"),\n                        \"keywords\": pdf.metadata.get(\"/Keywords\", \"\"),\n                        \"creator\": pdf.metadata.get(\"/Creator\", \"\"),\n                        \"producer\": pdf.metadata.get(\"/Producer\", \"\"),\n                        \"creation_date\": pdf.metadata.get(\"/CreationDate\", \"\"),\n                        \"mod_date\": pdf.metadata.get(\"/ModDate\", \"\"),\n                    }\n\n        except Exception as e:\n            content[\"error\"] = f\"Error processing PDF: {str(e)}\"\n\n        return content\n\n    @staticmethod\n    def extract_markdown_content(file_path: Union[str, Path]) -> Dict:\n        \"\"\"Extract content from Markdown files with frontmatter support.\"\"\"\n        content = {\"content_type\": \"markdown\", \"content\": \"\", \"metadata\": {}}\n\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                # Parse frontmatter if exists\n                post = frontmatter.load(f)\n                content[\"metadata\"] = dict(post.metadata)\n                content[\"content\"] = post.content\n\n                # Extract headers for better search\n                soup = BeautifulSoup(markdown.markdown(post.content), \"html.parser\")\n                headers = [\n                    h.get_text() for h in soup.find_all([\"h1\", \"h2\", \"h3\", \"h4\"])\n                ]\n                if headers:\n                    content[\"metadata\"][\"headers\"] = headers\n\n        except Exception as e:\n            content[\"error\"] = f\"Error processing Markdown: {str(e)}\"\n\n        return content\n\n    @staticmethod\n    def extract_docx_content(file_path: Union[str, Path]) -> Dict:\n        \"\"\"Extract text content from DOCX files.\"\"\"\n        content = {\"content_type\": \"text\", \"content\": \"\", \"metadata\": {}}\n\n        try:\n            doc = docx.Document(file_path)\n            content[\"content\"] = \"\\n\".join(\n                paragraph.text for paragraph in doc.paragraphs\n            )\n\n            # Extract core properties\n            core_props = doc.core_properties\n            content[\"metadata\"] = {\n                \"title\": core_props.title,\n                \"author\": core_props.author,\n                \"subject\": core_props.subject,\n                \"keywords\": core_props.keywords,\n                \"category\": core_props.category,\n                \"comments\": core_props.comments,\n                \"created\": core_props.created.isoformat()\n                if core_props.created\n                else None,\n                \"modified\": core_props.modified.isoformat()\n                if core_props.modified\n                else None,\n                \"last_modified_by\": core_props.last_modified_by,\n            }\n\n        except Exception as e:\n            content[\"error\"] = f\"Error processing DOCX: {str(e)}\"\n\n        return content\n\n    @staticmethod\n    def extract_csv_content(file_path: Union[str, Path]) -> Dict:\n        \"\"\"Extract content from CSV files.\"\"\"\n        content = {\"content_type\": \"table\", \"content\": \"\", \"metadata\": {}}\n\n        try:\n            # Read CSV with pandas\n            df = pd.read_csv(file_path)\n\n            # Convert to a more JSON-serializable format\n            content[\"content\"] = {\n                \"columns\": df.columns.tolist(),\n                \"sample\": df.head(5).to_dict(orient=\"records\"),\n                \"row_count\": len(df),\n            }\n\n        except Exception as e:\n            content[\"error\"] = f\"Error processing CSV: {str(e)}\"\n\n        return content\n\n    @staticmethod\n    def extract_text_content(file_path: Union[str, Path]) -> Dict:\n        \"\"\"Extract content from plain text files.\"\"\"\n        content = {\"content_type\": \"text\", \"content\": \"\", \"metadata\": {}}\n\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n                content[\"content\"] = f.read()\n        except Exception as e:\n            content[\"error\"] = f\"Error reading text file: {str(e)}\"\n\n        return content\n\n    @classmethod\n    def process_document(cls, file_path: Union[str, Path]) -> Dict:\n        \"\"\"Process a document based on its file type.\"\"\"\n        path = Path(file_path)\n        if not path.exists():\n            return {\"error\": f\"File not found: {file_path}\"}\n\n        # Get basic metadata\n        result = cls.extract_metadata(path)\n\n        # Process based on file type\n        file_ext = path.suffix.lower()\n\n        if file_ext == \".pdf\":\n            result.update(cls.extract_pdf_content(path))\n        elif file_ext in (\".md\", \".markdown\"):\n            result.update(cls.extract_markdown_content(path))\n        elif file_ext == \".docx\":\n            result.update(cls.extract_docx_content(path))\n        elif file_ext == \".csv\":\n            result.update(cls.extract_csv_content(path))\n        elif file_ext in (\".txt\", \".py\", \".js\", \".ts\", \".html\", \".css\", \".json\"):\n            result.update(cls.extract_text_content(path))\n        else:\n            # Try to process as text by default\n            try:\n                result.update(cls.extract_text_content(path))\n                result[\"content_type\"] = \"text/unknown\"\n            except Exception as e:\n                result[\"error\"] = f\"Unsupported file type: {file_ext}. Error: {str(e)}\"\n\n        return result\n",
  "metadata": {},
  "relative_path": "scripts\\document_processor.py",
  "id": "471e38de8248f8946995cdd0eff468ab"
}