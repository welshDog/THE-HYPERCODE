{
  "file_name": "req_set.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\venv_new\\Lib\\site-packages\\pip\\_internal\\req\\req_set.py",
  "file_size": 2858,
  "created": "2025-12-01T01:58:31.275681",
  "modified": "2025-12-01T01:58:31.303703",
  "file_type": "code",
  "content_hash": "5e5ce95b24a278a3d7ce245c37ff960e",
  "content_type": "text",
  "content": "import logging\nfrom collections import OrderedDict\nfrom typing import Dict, List\n\nfrom pip._vendor.packaging.utils import canonicalize_name\n\nfrom pip._internal.req.req_install import InstallRequirement\n\nlogger = logging.getLogger(__name__)\n\n\nclass RequirementSet:\n    def __init__(self, check_supported_wheels: bool = True) -> None:\n        \"\"\"Create a RequirementSet.\"\"\"\n\n        self.requirements: Dict[str, InstallRequirement] = OrderedDict()\n        self.check_supported_wheels = check_supported_wheels\n\n        self.unnamed_requirements: List[InstallRequirement] = []\n\n    def __str__(self) -> str:\n        requirements = sorted(\n            (req for req in self.requirements.values() if not req.comes_from),\n            key=lambda req: canonicalize_name(req.name or \"\"),\n        )\n        return \" \".join(str(req.req) for req in requirements)\n\n    def __repr__(self) -> str:\n        requirements = sorted(\n            self.requirements.values(),\n            key=lambda req: canonicalize_name(req.name or \"\"),\n        )\n\n        format_string = \"<{classname} object; {count} requirement(s): {reqs}>\"\n        return format_string.format(\n            classname=self.__class__.__name__,\n            count=len(requirements),\n            reqs=\", \".join(str(req.req) for req in requirements),\n        )\n\n    def add_unnamed_requirement(self, install_req: InstallRequirement) -> None:\n        assert not install_req.name\n        self.unnamed_requirements.append(install_req)\n\n    def add_named_requirement(self, install_req: InstallRequirement) -> None:\n        assert install_req.name\n\n        project_name = canonicalize_name(install_req.name)\n        self.requirements[project_name] = install_req\n\n    def has_requirement(self, name: str) -> bool:\n        project_name = canonicalize_name(name)\n\n        return (\n            project_name in self.requirements\n            and not self.requirements[project_name].constraint\n        )\n\n    def get_requirement(self, name: str) -> InstallRequirement:\n        project_name = canonicalize_name(name)\n\n        if project_name in self.requirements:\n            return self.requirements[project_name]\n\n        raise KeyError(f\"No project with the name {name!r}\")\n\n    @property\n    def all_requirements(self) -> List[InstallRequirement]:\n        return self.unnamed_requirements + list(self.requirements.values())\n\n    @property\n    def requirements_to_install(self) -> List[InstallRequirement]:\n        \"\"\"Return the list of requirements that need to be installed.\n\n        TODO remove this property together with the legacy resolver, since the new\n             resolver only returns requirements that need to be installed.\n        \"\"\"\n        return [\n            install_req\n            for install_req in self.all_requirements\n            if not install_req.constraint and not install_req.satisfied_by\n        ]\n",
  "metadata": {},
  "relative_path": "venv_new\\Lib\\site-packages\\pip\\_internal\\req\\req_set.py",
  "id": "0422f9a2d1a308ec1287ab43ecc7b9fd"
}