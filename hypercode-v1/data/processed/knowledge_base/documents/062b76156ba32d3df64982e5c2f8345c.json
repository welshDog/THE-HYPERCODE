{
  "file_name": "_in_process.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\venv_new\\Lib\\site-packages\\pip\\_vendor\\pyproject_hooks\\_in_process\\_in_process.py",
  "file_size": 12216,
  "created": "2025-12-01T01:58:32.891977",
  "modified": "2025-12-01T01:58:32.893278",
  "file_type": "code",
  "content_hash": "fcbf3d8e0957f76062f67265b9783df0",
  "content_type": "text",
  "content": "\"\"\"This is invoked in a subprocess to call the build backend hooks.\n\nIt expects:\n- Command line args: hook_name, control_dir\n- Environment variables:\n      _PYPROJECT_HOOKS_BUILD_BACKEND=entry.point:spec\n      _PYPROJECT_HOOKS_BACKEND_PATH=paths (separated with os.pathsep)\n- control_dir/input.json:\n  - {\"kwargs\": {...}}\n\nResults:\n- control_dir/output.json\n  - {\"return_val\": ...}\n\"\"\"\nimport json\nimport os\nimport os.path\nimport re\nimport shutil\nimport sys\nimport traceback\nfrom glob import glob\nfrom importlib import import_module\nfrom importlib.machinery import PathFinder\nfrom os.path import join as pjoin\n\n# This file is run as a script, and `import wrappers` is not zip-safe, so we\n# include write_json() and read_json() from wrappers.py.\n\n\ndef write_json(obj, path, **kwargs):\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(obj, f, **kwargs)\n\n\ndef read_json(path):\n    with open(path, encoding=\"utf-8\") as f:\n        return json.load(f)\n\n\nclass BackendUnavailable(Exception):\n    \"\"\"Raised if we cannot import the backend\"\"\"\n\n    def __init__(self, message, traceback=None):\n        super().__init__(message)\n        self.message = message\n        self.traceback = traceback\n\n\nclass HookMissing(Exception):\n    \"\"\"Raised if a hook is missing and we are not executing the fallback\"\"\"\n\n    def __init__(self, hook_name=None):\n        super().__init__(hook_name)\n        self.hook_name = hook_name\n\n\ndef _build_backend():\n    \"\"\"Find and load the build backend\"\"\"\n    backend_path = os.environ.get(\"_PYPROJECT_HOOKS_BACKEND_PATH\")\n    ep = os.environ[\"_PYPROJECT_HOOKS_BUILD_BACKEND\"]\n    mod_path, _, obj_path = ep.partition(\":\")\n\n    if backend_path:\n        # Ensure in-tree backend directories have the highest priority when importing.\n        extra_pathitems = backend_path.split(os.pathsep)\n        sys.meta_path.insert(0, _BackendPathFinder(extra_pathitems, mod_path))\n\n    try:\n        obj = import_module(mod_path)\n    except ImportError:\n        msg = f\"Cannot import {mod_path!r}\"\n        raise BackendUnavailable(msg, traceback.format_exc())\n\n    if obj_path:\n        for path_part in obj_path.split(\".\"):\n            obj = getattr(obj, path_part)\n    return obj\n\n\nclass _BackendPathFinder:\n    \"\"\"Implements the MetaPathFinder interface to locate modules in ``backend-path``.\n\n    Since the environment provided by the frontend can contain all sorts of\n    MetaPathFinders, the only way to ensure the backend is loaded from the\n    right place is to prepend our own.\n    \"\"\"\n\n    def __init__(self, backend_path, backend_module):\n        self.backend_path = backend_path\n        self.backend_module = backend_module\n        self.backend_parent, _, _ = backend_module.partition(\".\")\n\n    def find_spec(self, fullname, _path, _target=None):\n        if \".\" in fullname:\n            # Rely on importlib to find nested modules based on parent's path\n            return None\n\n        # Ignore other items in _path or sys.path and use backend_path instead:\n        spec = PathFinder.find_spec(fullname, path=self.backend_path)\n        if spec is None and fullname == self.backend_parent:\n            # According to the spec, the backend MUST be loaded from backend-path.\n            # Therefore, we can halt the import machinery and raise a clean error.\n            msg = f\"Cannot find module {self.backend_module!r} in {self.backend_path!r}\"\n            raise BackendUnavailable(msg)\n\n        return spec\n\n    if sys.version_info >= (3, 8):\n\n        def find_distributions(self, context=None):\n            # Delayed import: Python 3.7 does not contain importlib.metadata\n            from importlib.metadata import DistributionFinder, MetadataPathFinder\n\n            context = DistributionFinder.Context(path=self.backend_path)\n            return MetadataPathFinder.find_distributions(context=context)\n\n\ndef _supported_features():\n    \"\"\"Return the list of options features supported by the backend.\n\n    Returns a list of strings.\n    The only possible value is 'build_editable'.\n    \"\"\"\n    backend = _build_backend()\n    features = []\n    if hasattr(backend, \"build_editable\"):\n        features.append(\"build_editable\")\n    return features\n\n\ndef get_requires_for_build_wheel(config_settings):\n    \"\"\"Invoke the optional get_requires_for_build_wheel hook\n\n    Returns [] if the hook is not defined.\n    \"\"\"\n    backend = _build_backend()\n    try:\n        hook = backend.get_requires_for_build_wheel\n    except AttributeError:\n        return []\n    else:\n        return hook(config_settings)\n\n\ndef get_requires_for_build_editable(config_settings):\n    \"\"\"Invoke the optional get_requires_for_build_editable hook\n\n    Returns [] if the hook is not defined.\n    \"\"\"\n    backend = _build_backend()\n    try:\n        hook = backend.get_requires_for_build_editable\n    except AttributeError:\n        return []\n    else:\n        return hook(config_settings)\n\n\ndef prepare_metadata_for_build_wheel(\n    metadata_directory, config_settings, _allow_fallback\n):\n    \"\"\"Invoke optional prepare_metadata_for_build_wheel\n\n    Implements a fallback by building a wheel if the hook isn't defined,\n    unless _allow_fallback is False in which case HookMissing is raised.\n    \"\"\"\n    backend = _build_backend()\n    try:\n        hook = backend.prepare_metadata_for_build_wheel\n    except AttributeError:\n        if not _allow_fallback:\n            raise HookMissing()\n    else:\n        return hook(metadata_directory, config_settings)\n    # fallback to build_wheel outside the try block to avoid exception chaining\n    # which can be confusing to users and is not relevant\n    whl_basename = backend.build_wheel(metadata_directory, config_settings)\n    return _get_wheel_metadata_from_wheel(\n        whl_basename, metadata_directory, config_settings\n    )\n\n\ndef prepare_metadata_for_build_editable(\n    metadata_directory, config_settings, _allow_fallback\n):\n    \"\"\"Invoke optional prepare_metadata_for_build_editable\n\n    Implements a fallback by building an editable wheel if the hook isn't\n    defined, unless _allow_fallback is False in which case HookMissing is\n    raised.\n    \"\"\"\n    backend = _build_backend()\n    try:\n        hook = backend.prepare_metadata_for_build_editable\n    except AttributeError:\n        if not _allow_fallback:\n            raise HookMissing()\n        try:\n            build_hook = backend.build_editable\n        except AttributeError:\n            raise HookMissing(hook_name=\"build_editable\")\n        else:\n            whl_basename = build_hook(metadata_directory, config_settings)\n            return _get_wheel_metadata_from_wheel(\n                whl_basename, metadata_directory, config_settings\n            )\n    else:\n        return hook(metadata_directory, config_settings)\n\n\nWHEEL_BUILT_MARKER = \"PYPROJECT_HOOKS_ALREADY_BUILT_WHEEL\"\n\n\ndef _dist_info_files(whl_zip):\n    \"\"\"Identify the .dist-info folder inside a wheel ZipFile.\"\"\"\n    res = []\n    for path in whl_zip.namelist():\n        m = re.match(r\"[^/\\\\]+-[^/\\\\]+\\.dist-info/\", path)\n        if m:\n            res.append(path)\n    if res:\n        return res\n    raise Exception(\"No .dist-info folder found in wheel\")\n\n\ndef _get_wheel_metadata_from_wheel(whl_basename, metadata_directory, config_settings):\n    \"\"\"Extract the metadata from a wheel.\n\n    Fallback for when the build backend does not\n    define the 'get_wheel_metadata' hook.\n    \"\"\"\n    from zipfile import ZipFile\n\n    with open(os.path.join(metadata_directory, WHEEL_BUILT_MARKER), \"wb\"):\n        pass  # Touch marker file\n\n    whl_file = os.path.join(metadata_directory, whl_basename)\n    with ZipFile(whl_file) as zipf:\n        dist_info = _dist_info_files(zipf)\n        zipf.extractall(path=metadata_directory, members=dist_info)\n    return dist_info[0].split(\"/\")[0]\n\n\ndef _find_already_built_wheel(metadata_directory):\n    \"\"\"Check for a wheel already built during the get_wheel_metadata hook.\"\"\"\n    if not metadata_directory:\n        return None\n    metadata_parent = os.path.dirname(metadata_directory)\n    if not os.path.isfile(pjoin(metadata_parent, WHEEL_BUILT_MARKER)):\n        return None\n\n    whl_files = glob(os.path.join(metadata_parent, \"*.whl\"))\n    if not whl_files:\n        print(\"Found wheel built marker, but no .whl files\")\n        return None\n    if len(whl_files) > 1:\n        print(\n            \"Found multiple .whl files; unspecified behaviour. \"\n            \"Will call build_wheel.\"\n        )\n        return None\n\n    # Exactly one .whl file\n    return whl_files[0]\n\n\ndef build_wheel(wheel_directory, config_settings, metadata_directory=None):\n    \"\"\"Invoke the mandatory build_wheel hook.\n\n    If a wheel was already built in the\n    prepare_metadata_for_build_wheel fallback, this\n    will copy it rather than rebuilding the wheel.\n    \"\"\"\n    prebuilt_whl = _find_already_built_wheel(metadata_directory)\n    if prebuilt_whl:\n        shutil.copy2(prebuilt_whl, wheel_directory)\n        return os.path.basename(prebuilt_whl)\n\n    return _build_backend().build_wheel(\n        wheel_directory, config_settings, metadata_directory\n    )\n\n\ndef build_editable(wheel_directory, config_settings, metadata_directory=None):\n    \"\"\"Invoke the optional build_editable hook.\n\n    If a wheel was already built in the\n    prepare_metadata_for_build_editable fallback, this\n    will copy it rather than rebuilding the wheel.\n    \"\"\"\n    backend = _build_backend()\n    try:\n        hook = backend.build_editable\n    except AttributeError:\n        raise HookMissing()\n    else:\n        prebuilt_whl = _find_already_built_wheel(metadata_directory)\n        if prebuilt_whl:\n            shutil.copy2(prebuilt_whl, wheel_directory)\n            return os.path.basename(prebuilt_whl)\n\n        return hook(wheel_directory, config_settings, metadata_directory)\n\n\ndef get_requires_for_build_sdist(config_settings):\n    \"\"\"Invoke the optional get_requires_for_build_wheel hook\n\n    Returns [] if the hook is not defined.\n    \"\"\"\n    backend = _build_backend()\n    try:\n        hook = backend.get_requires_for_build_sdist\n    except AttributeError:\n        return []\n    else:\n        return hook(config_settings)\n\n\nclass _DummyException(Exception):\n    \"\"\"Nothing should ever raise this exception\"\"\"\n\n\nclass GotUnsupportedOperation(Exception):\n    \"\"\"For internal use when backend raises UnsupportedOperation\"\"\"\n\n    def __init__(self, traceback):\n        self.traceback = traceback\n\n\ndef build_sdist(sdist_directory, config_settings):\n    \"\"\"Invoke the mandatory build_sdist hook.\"\"\"\n    backend = _build_backend()\n    try:\n        return backend.build_sdist(sdist_directory, config_settings)\n    except getattr(backend, \"UnsupportedOperation\", _DummyException):\n        raise GotUnsupportedOperation(traceback.format_exc())\n\n\nHOOK_NAMES = {\n    \"get_requires_for_build_wheel\",\n    \"prepare_metadata_for_build_wheel\",\n    \"build_wheel\",\n    \"get_requires_for_build_editable\",\n    \"prepare_metadata_for_build_editable\",\n    \"build_editable\",\n    \"get_requires_for_build_sdist\",\n    \"build_sdist\",\n    \"_supported_features\",\n}\n\n\ndef main():\n    if len(sys.argv) < 3:\n        sys.exit(\"Needs args: hook_name, control_dir\")\n    hook_name = sys.argv[1]\n    control_dir = sys.argv[2]\n    if hook_name not in HOOK_NAMES:\n        sys.exit(\"Unknown hook: %s\" % hook_name)\n\n    # Remove the parent directory from sys.path to avoid polluting the backend\n    # import namespace with this directory.\n    here = os.path.dirname(__file__)\n    if here in sys.path:\n        sys.path.remove(here)\n\n    hook = globals()[hook_name]\n\n    hook_input = read_json(pjoin(control_dir, \"input.json\"))\n\n    json_out = {\"unsupported\": False, \"return_val\": None}\n    try:\n        json_out[\"return_val\"] = hook(**hook_input[\"kwargs\"])\n    except BackendUnavailable as e:\n        json_out[\"no_backend\"] = True\n        json_out[\"traceback\"] = e.traceback\n        json_out[\"backend_error\"] = e.message\n    except GotUnsupportedOperation as e:\n        json_out[\"unsupported\"] = True\n        json_out[\"traceback\"] = e.traceback\n    except HookMissing as e:\n        json_out[\"hook_missing\"] = True\n        json_out[\"missing_hook_name\"] = e.hook_name or hook_name\n\n    write_json(json_out, pjoin(control_dir, \"output.json\"), indent=2)\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "metadata": {},
  "relative_path": "venv_new\\Lib\\site-packages\\pip\\_vendor\\pyproject_hooks\\_in_process\\_in_process.py",
  "id": "062b76156ba32d3df64982e5c2f8345c"
}