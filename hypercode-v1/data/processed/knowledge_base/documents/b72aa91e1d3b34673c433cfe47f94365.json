{
  "file_name": "wheel.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\venv_new\\Lib\\site-packages\\pip\\_internal\\models\\wheel.py",
  "file_size": 4539,
  "created": "2025-12-01T01:58:31.050890",
  "modified": "2025-12-01T01:58:31.051379",
  "file_type": "code",
  "content_hash": "971f83dc677bef7d5ae221efe15fbd8e",
  "content_type": "text",
  "content": "\"\"\"Represents a wheel file and provides access to the various parts of the\nname that have meaning.\n\"\"\"\n\nimport re\nfrom typing import Dict, Iterable, List\n\nfrom pip._vendor.packaging.tags import Tag\nfrom pip._vendor.packaging.utils import (\n    InvalidWheelFilename as PackagingInvalidWheelName,\n)\nfrom pip._vendor.packaging.utils import parse_wheel_filename\n\nfrom pip._internal.exceptions import InvalidWheelFilename\nfrom pip._internal.utils.deprecation import deprecated\n\n\nclass Wheel:\n    \"\"\"A wheel file\"\"\"\n\n    wheel_file_re = re.compile(\n        r\"\"\"^(?P<namever>(?P<name>[^\\s-]+?)-(?P<ver>[^\\s-]*?))\n        ((-(?P<build>\\d[^-]*?))?-(?P<pyver>[^\\s-]+?)-(?P<abi>[^\\s-]+?)-(?P<plat>[^\\s-]+?)\n        \\.whl|\\.dist-info)$\"\"\",\n        re.VERBOSE,\n    )\n\n    def __init__(self, filename: str) -> None:\n        \"\"\"\n        :raises InvalidWheelFilename: when the filename is invalid for a wheel\n        \"\"\"\n        wheel_info = self.wheel_file_re.match(filename)\n        if not wheel_info:\n            raise InvalidWheelFilename(f\"{filename} is not a valid wheel filename.\")\n        self.filename = filename\n        self.name = wheel_info.group(\"name\").replace(\"_\", \"-\")\n        _version = wheel_info.group(\"ver\")\n        if \"_\" in _version:\n            try:\n                parse_wheel_filename(filename)\n            except PackagingInvalidWheelName as e:\n                deprecated(\n                    reason=(\n                        f\"Wheel filename {filename!r} is not correctly normalised. \"\n                        \"Future versions of pip will raise the following error:\\n\"\n                        f\"{e.args[0]}\\n\\n\"\n                    ),\n                    replacement=(\n                        \"to rename the wheel to use a correctly normalised \"\n                        \"name (this may require updating the version in \"\n                        \"the project metadata)\"\n                    ),\n                    gone_in=\"25.1\",\n                    issue=12938,\n                )\n\n            _version = _version.replace(\"_\", \"-\")\n\n        self.version = _version\n        self.build_tag = wheel_info.group(\"build\")\n        self.pyversions = wheel_info.group(\"pyver\").split(\".\")\n        self.abis = wheel_info.group(\"abi\").split(\".\")\n        self.plats = wheel_info.group(\"plat\").split(\".\")\n\n        # All the tag combinations from this file\n        self.file_tags = {\n            Tag(x, y, z) for x in self.pyversions for y in self.abis for z in self.plats\n        }\n\n    def get_formatted_file_tags(self) -> List[str]:\n        \"\"\"Return the wheel's tags as a sorted list of strings.\"\"\"\n        return sorted(str(tag) for tag in self.file_tags)\n\n    def support_index_min(self, tags: List[Tag]) -> int:\n        \"\"\"Return the lowest index that one of the wheel's file_tag combinations\n        achieves in the given list of supported tags.\n\n        For example, if there are 8 supported tags and one of the file tags\n        is first in the list, then return 0.\n\n        :param tags: the PEP 425 tags to check the wheel against, in order\n            with most preferred first.\n\n        :raises ValueError: If none of the wheel's file tags match one of\n            the supported tags.\n        \"\"\"\n        try:\n            return next(i for i, t in enumerate(tags) if t in self.file_tags)\n        except StopIteration:\n            raise ValueError()\n\n    def find_most_preferred_tag(\n        self, tags: List[Tag], tag_to_priority: Dict[Tag, int]\n    ) -> int:\n        \"\"\"Return the priority of the most preferred tag that one of the wheel's file\n        tag combinations achieves in the given list of supported tags using the given\n        tag_to_priority mapping, where lower priorities are more-preferred.\n\n        This is used in place of support_index_min in some cases in order to avoid\n        an expensive linear scan of a large list of tags.\n\n        :param tags: the PEP 425 tags to check the wheel against.\n        :param tag_to_priority: a mapping from tag to priority of that tag, where\n            lower is more preferred.\n\n        :raises ValueError: If none of the wheel's file tags match one of\n            the supported tags.\n        \"\"\"\n        return min(\n            tag_to_priority[tag] for tag in self.file_tags if tag in tag_to_priority\n        )\n\n    def supported(self, tags: Iterable[Tag]) -> bool:\n        \"\"\"Return whether the wheel is compatible with one of the given tags.\n\n        :param tags: the PEP 425 tags to check the wheel against.\n        \"\"\"\n        return not self.file_tags.isdisjoint(tags)\n",
  "metadata": {},
  "relative_path": "venv_new\\Lib\\site-packages\\pip\\_internal\\models\\wheel.py",
  "id": "b72aa91e1d3b34673c433cfe47f94365"
}