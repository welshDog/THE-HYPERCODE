{
  "file_name": "interpreter.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\src\\hypercode\\core\\interpreter.py",
  "file_size": 8328,
  "created": "2025-11-25T18:30:25.279436",
  "modified": "2025-12-03T02:15:47.251209",
  "file_type": "code",
  "content_hash": "64b7d587b0e0b4e60372525f7e131dd2",
  "content_type": "text",
  "content": "from .ast import *\nfrom .tokens import TokenType, Token\nfrom .visitor import Visitor  # Add this import\n\n\nclass Return(Exception):\n    def __init__(self, value):\n        self.value = value\n\n\nclass HyperCodeFunction:\n    def __init__(self, declaration: Fun, closure: \"Environment\"):\n        self.declaration = declaration\n        self.closure = closure\n\n    def __str__(self):\n        return f\"<fn {self.declaration.name.lexeme}>\"\n\n    def arity(self):\n        return len(self.declaration.params)\n\n    def call(self, interpreter, arguments):\n        environment = Environment(self.closure)\n        for i, param in enumerate(self.declaration.params):\n            environment.define(param.lexeme, arguments[i])\n\n        try:\n            interpreter.execute_block(self.declaration.body, environment)\n        except Return as return_value:\n            return return_value.value\n\n        return None\n\n\nclass Environment:\n    def __init__(self, enclosing=None):\n        self.values = {}\n        self.enclosing = enclosing\n\n    def define(self, name: str, value):\n        self.values[name] = value\n\n    def get(self, name: Token):\n        if name.lexeme in self.values:\n            return self.values[name.lexeme]\n        if self.enclosing is not None:\n            return self.enclosing.get(name)\n        raise RuntimeError(f\"Undefined variable '{name.lexeme}'.\")\n\n    def assign(self, name: Token, value):\n        if name.lexeme in self.values:\n            self.values[name.lexeme] = value\n            return\n        if self.enclosing is not None:\n            self.enclosing.assign(name, value)\n            return\n        raise RuntimeError(f\"Undefined variable '{name.lexeme}'.\")\n\n\nclass Interpreter(Visitor):\n    def __init__(self):\n        self.globals = Environment()\n        self.environment = self.globals\n\n    def interpret(self, statements: List[Stmt]):\n        try:\n            for statement in statements:\n                self.execute(statement)\n        except Exception as e:\n            print(f\"Runtime error: {e}\")\n\n    def execute(self, stmt: Stmt):\n        stmt.accept(self)\n\n    def execute_block(self, statements: List[Stmt], environment: Environment):\n        previous = self.environment\n        try:\n            self.environment = environment\n            for statement in statements:\n                self.execute(statement)\n        finally:\n            self.environment = previous\n\n    def evaluate(self, expr: Expr):\n        return expr.accept(self)\n\n    def visit_Expression(self, stmt: Expression):\n        self.evaluate(stmt.expression)\n\n    def visit_Print(self, stmt: Print):\n        value = self.evaluate(stmt.expression)\n        print(value)\n\n    def visit_Var(self, stmt: Var):\n        value = None\n        if stmt.initializer is not None:\n            value = self.evaluate(stmt.initializer)\n        self.environment.define(stmt.name.lexeme, value)\n\n    def visit_Block(self, stmt: Block):\n        self.execute_block(stmt.statements, Environment(self.environment))\n\n    def visit_Assign(self, expr: Assign):\n        value = self.evaluate(expr.value)\n        self.environment.assign(expr.name, value)\n        return value\n\n    def visit_Binary(self, expr: Binary):\n        left = self.evaluate(expr.left)\n        right = self.evaluate(expr.right)\n\n        op_type = expr.operator.type\n\n        if op_type == TokenType.PLUS:\n            if isinstance(left, (int, float)) and isinstance(right, (int, float)):\n                return left + right\n            if isinstance(left, str) and isinstance(right, str):\n                return left + right\n            raise RuntimeError(\"Operands must be two numbers or two strings.\")\n        if op_type == TokenType.MINUS:\n            if isinstance(left, (int, float)) and isinstance(right, (int, float)):\n                return left - right\n            raise RuntimeError(\"Operands must be numbers.\")\n        if op_type == TokenType.STAR:\n            if isinstance(left, (int, float)) and isinstance(right, (int, float)):\n                return left * right\n            raise RuntimeError(\"Operands must be numbers.\")\n        if op_type == TokenType.SLASH:\n            if isinstance(left, (int, float)) and isinstance(right, (int, float)):\n                if right == 0:\n                    raise RuntimeError(\"Division by zero.\")\n                return left / right\n            raise RuntimeError(\"Operands must be numbers.\")\n\n        if op_type == TokenType.GREATER:\n            return left > right\n        if op_type == TokenType.GREATER_EQUAL:\n            return left >= right\n        if op_type == TokenType.LESS:\n            return left < right\n        if op_type == TokenType.LESS_EQUAL:\n            return left <= right\n\n        if op_type == TokenType.BANG_EQUAL:\n            return left != right\n        if op_type == TokenType.EQUAL_EQUAL:\n            return left == right\n\n        return None  # Should not happen\n\n    def visit_Grouping(self, expr: Grouping):\n        return self.evaluate(expr.expression)\n\n    def visit_Literal(self, expr: Literal):\n        return expr.value\n\n    def visit_Unary(self, expr: Unary):\n        right = self.evaluate(expr.right)\n\n        op_type = expr.operator.type\n        if op_type == TokenType.MINUS:\n            if isinstance(right, (int, float)):\n                return -right\n            raise RuntimeError(\"Operand must be a number.\")\n        if op_type == TokenType.BANG:\n            return not self.is_truthy(right)\n\n        return None  # Should not happen\n\n    def visit_Variable(self, expr: Variable):\n        return self.environment.get(expr.name)\n\n    def visit_If(self, stmt: If):\n        if self.is_truthy(self.evaluate(stmt.condition)):\n            self.execute(stmt.then_branch)\n        elif stmt.else_branch is not None:\n            self.execute(stmt.else_branch)\n\n    def is_truthy(self, obj):\n        if obj is None:\n            return False\n        if isinstance(obj, bool):\n            return obj\n        return True\n\n    def visit_Fun(self, stmt: Fun):\n        function = HyperCodeFunction(stmt, self.environment)\n        self.environment.define(stmt.name.lexeme, function)\n\n    def visit_Return(self, stmt: Return):\n        value = None\n        if stmt.value is not None:\n            value = self.evaluate(stmt.value)\n        raise Return(value)\n\n    def visit_Call(self, expr: Call):\n        callee = self.evaluate(expr.callee)\n\n        arguments = []\n        for argument in expr.arguments:\n            arguments.append(self.evaluate(argument))\n\n        if not self.is_callable(callee):\n            raise RuntimeError(\"Can only call functions and classes.\")\n\n        function = callee\n        if len(arguments) != function.arity():\n            raise RuntimeError(\n                f\"Expected {function.arity()} arguments but got {len(arguments)}.\"\n            )\n\n        return function.call(self, arguments)\n\n    def is_callable(self, obj):\n        return isinstance(obj, HyperCodeFunction)\n\n\n# The Visitor pattern boilerplate\nclass Visitor:\n    def visit_Expression(self, stmt: \"Expression\"):\n        raise NotImplementedError\n\n    def visit_Print(self, stmt: \"Print\"):\n        raise NotImplementedError\n\n    def visit_Var(self, stmt: \"Var\"):\n        raise NotImplementedError\n\n    def visit_Block(self, stmt: \"Block\"):\n        raise NotImplementedError\n\n    def visit_If(self, stmt: \"If\"):\n        raise NotImplementedError\n\n    def visit_Fun(self, stmt: \"Fun\"):\n        raise NotImplementedError\n\n    def visit_Return(self, stmt: \"Return\"):\n        raise NotImplementedError\n\n    def visit_Assign(self, expr: \"Assign\"):\n        raise NotImplementedError\n\n    def visit_Binary(self, expr: \"Binary\"):\n        raise NotImplementedError\n\n    def visit_Grouping(self, expr: \"Grouping\"):\n        raise NotImplementedError\n\n    def visit_Literal(self, expr: \"Literal\"):\n        raise NotImplementedError\n\n    def visit_Unary(self, expr: \"Unary\"):\n        raise NotImplementedError\n\n    def visit_Variable(self, expr: \"Variable\"):\n        raise NotImplementedError\n\n    def visit_Call(self, expr: \"Call\"):\n        raise NotImplementedError\n",
  "metadata": {},
  "relative_path": "src\\hypercode\\core\\interpreter.py",
  "id": "0cc604400534f72bb32af1f5f3c77d51"
}