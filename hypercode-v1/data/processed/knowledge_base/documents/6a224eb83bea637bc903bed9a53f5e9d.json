{
  "file_name": "cells.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\venv_new\\Lib\\site-packages\\pip\\_vendor\\rich\\cells.py",
  "file_size": 5130,
  "created": "2025-12-01T01:58:33.250054",
  "modified": "2025-12-01T01:58:33.251228",
  "file_type": "code",
  "content_hash": "811f5d5eaa1c4a05755944b6ac9e6ab6",
  "content_type": "text",
  "content": "from __future__ import annotations\n\nfrom functools import lru_cache\nfrom typing import Callable\n\nfrom ._cell_widths import CELL_WIDTHS\n\n# Ranges of unicode ordinals that produce a 1-cell wide character\n# This is non-exhaustive, but covers most common Western characters\n_SINGLE_CELL_UNICODE_RANGES: list[tuple[int, int]] = [\n    (0x20, 0x7E),  # Latin (excluding non-printable)\n    (0xA0, 0xAC),\n    (0xAE, 0x002FF),\n    (0x00370, 0x00482),  # Greek / Cyrillic\n    (0x02500, 0x025FC),  # Box drawing, box elements, geometric shapes\n    (0x02800, 0x028FF),  # Braille\n]\n\n# A set of characters that are a single cell wide\n_SINGLE_CELLS = frozenset(\n    [\n        character\n        for _start, _end in _SINGLE_CELL_UNICODE_RANGES\n        for character in map(chr, range(_start, _end + 1))\n    ]\n)\n\n# When called with a string this will return True if all\n# characters are single-cell, otherwise False\n_is_single_cell_widths: Callable[[str], bool] = _SINGLE_CELLS.issuperset\n\n\n@lru_cache(4096)\ndef cached_cell_len(text: str) -> int:\n    \"\"\"Get the number of cells required to display text.\n\n    This method always caches, which may use up a lot of memory. It is recommended to use\n    `cell_len` over this method.\n\n    Args:\n        text (str): Text to display.\n\n    Returns:\n        int: Get the number of cells required to display text.\n    \"\"\"\n    if _is_single_cell_widths(text):\n        return len(text)\n    return sum(map(get_character_cell_size, text))\n\n\ndef cell_len(text: str, _cell_len: Callable[[str], int] = cached_cell_len) -> int:\n    \"\"\"Get the number of cells required to display text.\n\n    Args:\n        text (str): Text to display.\n\n    Returns:\n        int: Get the number of cells required to display text.\n    \"\"\"\n    if len(text) < 512:\n        return _cell_len(text)\n    if _is_single_cell_widths(text):\n        return len(text)\n    return sum(map(get_character_cell_size, text))\n\n\n@lru_cache(maxsize=4096)\ndef get_character_cell_size(character: str) -> int:\n    \"\"\"Get the cell size of a character.\n\n    Args:\n        character (str): A single character.\n\n    Returns:\n        int: Number of cells (0, 1 or 2) occupied by that character.\n    \"\"\"\n    codepoint = ord(character)\n    _table = CELL_WIDTHS\n    lower_bound = 0\n    upper_bound = len(_table) - 1\n    index = (lower_bound + upper_bound) // 2\n    while True:\n        start, end, width = _table[index]\n        if codepoint < start:\n            upper_bound = index - 1\n        elif codepoint > end:\n            lower_bound = index + 1\n        else:\n            return 0 if width == -1 else width\n        if upper_bound < lower_bound:\n            break\n        index = (lower_bound + upper_bound) // 2\n    return 1\n\n\ndef set_cell_size(text: str, total: int) -> str:\n    \"\"\"Set the length of a string to fit within given number of cells.\"\"\"\n\n    if _is_single_cell_widths(text):\n        size = len(text)\n        if size < total:\n            return text + \" \" * (total - size)\n        return text[:total]\n\n    if total <= 0:\n        return \"\"\n    cell_size = cell_len(text)\n    if cell_size == total:\n        return text\n    if cell_size < total:\n        return text + \" \" * (total - cell_size)\n\n    start = 0\n    end = len(text)\n\n    # Binary search until we find the right size\n    while True:\n        pos = (start + end) // 2\n        before = text[: pos + 1]\n        before_len = cell_len(before)\n        if before_len == total + 1 and cell_len(before[-1]) == 2:\n            return before[:-1] + \" \"\n        if before_len == total:\n            return before\n        if before_len > total:\n            end = pos\n        else:\n            start = pos\n\n\ndef chop_cells(\n    text: str,\n    width: int,\n) -> list[str]:\n    \"\"\"Split text into lines such that each line fits within the available (cell) width.\n\n    Args:\n        text: The text to fold such that it fits in the given width.\n        width: The width available (number of cells).\n\n    Returns:\n        A list of strings such that each string in the list has cell width\n        less than or equal to the available width.\n    \"\"\"\n    _get_character_cell_size = get_character_cell_size\n    lines: list[list[str]] = [[]]\n\n    append_new_line = lines.append\n    append_to_last_line = lines[-1].append\n\n    total_width = 0\n\n    for character in text:\n        cell_width = _get_character_cell_size(character)\n        char_doesnt_fit = total_width + cell_width > width\n\n        if char_doesnt_fit:\n            append_new_line([character])\n            append_to_last_line = lines[-1].append\n            total_width = cell_width\n        else:\n            append_to_last_line(character)\n            total_width += cell_width\n\n    return [\"\".join(line) for line in lines]\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    print(get_character_cell_size(\"ğŸ˜½\"))\n    for line in chop_cells(\"\"\"è¿™æ˜¯å¯¹äºšæ´²è¯­è¨€æ”¯æŒçš„æµ‹è¯•ã€‚é¢å¯¹æ¨¡æ£±ä¸¤å¯çš„æƒ³æ³•ï¼Œæ‹’ç»çŒœæµ‹çš„è¯±æƒ‘ã€‚\"\"\", 8):\n        print(line)\n    for n in range(80, 1, -1):\n        print(set_cell_size(\"\"\"è¿™æ˜¯å¯¹äºšæ´²è¯­è¨€æ”¯æŒçš„æµ‹è¯•ã€‚é¢å¯¹æ¨¡æ£±ä¸¤å¯çš„æƒ³æ³•ï¼Œæ‹’ç»çŒœæµ‹çš„è¯±æƒ‘ã€‚\"\"\", n) + \"|\")\n        print(\"x\" * n)\n",
  "metadata": {},
  "relative_path": "venv_new\\Lib\\site-packages\\pip\\_vendor\\rich\\cells.py",
  "id": "6a224eb83bea637bc903bed9a53f5e9d"
}