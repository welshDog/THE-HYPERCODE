{
  "file_name": "req_command.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\venv_new\\Lib\\site-packages\\pip\\_internal\\cli\\req_command.py",
  "file_size": 12250,
  "created": "2025-12-01T01:58:30.270178",
  "modified": "2025-12-01T01:58:30.273330",
  "file_type": "code",
  "content_hash": "5845b6afe6aec0ead2d60af44eec2721",
  "content_type": "text",
  "content": "\"\"\"Contains the RequirementCommand base class.\n\nThis class is in a separate module so the commands that do not always\nneed PackageFinder capability don't unnecessarily import the\nPackageFinder machinery and all its vendored dependencies, etc.\n\"\"\"\n\nimport logging\nfrom functools import partial\nfrom optparse import Values\nfrom typing import Any, List, Optional, Tuple\n\nfrom pip._internal.cache import WheelCache\nfrom pip._internal.cli import cmdoptions\nfrom pip._internal.cli.index_command import IndexGroupCommand\nfrom pip._internal.cli.index_command import SessionCommandMixin as SessionCommandMixin\nfrom pip._internal.exceptions import CommandError, PreviousBuildDirError\nfrom pip._internal.index.collector import LinkCollector\nfrom pip._internal.index.package_finder import PackageFinder\nfrom pip._internal.models.selection_prefs import SelectionPreferences\nfrom pip._internal.models.target_python import TargetPython\nfrom pip._internal.network.session import PipSession\nfrom pip._internal.operations.build.build_tracker import BuildTracker\nfrom pip._internal.operations.prepare import RequirementPreparer\nfrom pip._internal.req.constructors import (\n    install_req_from_editable,\n    install_req_from_line,\n    install_req_from_parsed_requirement,\n    install_req_from_req_string,\n)\nfrom pip._internal.req.req_file import parse_requirements\nfrom pip._internal.req.req_install import InstallRequirement\nfrom pip._internal.resolution.base import BaseResolver\nfrom pip._internal.utils.temp_dir import (\n    TempDirectory,\n    TempDirectoryTypeRegistry,\n    tempdir_kinds,\n)\n\nlogger = logging.getLogger(__name__)\n\n\nKEEPABLE_TEMPDIR_TYPES = [\n    tempdir_kinds.BUILD_ENV,\n    tempdir_kinds.EPHEM_WHEEL_CACHE,\n    tempdir_kinds.REQ_BUILD,\n]\n\n\ndef with_cleanup(func: Any) -> Any:\n    \"\"\"Decorator for common logic related to managing temporary\n    directories.\n    \"\"\"\n\n    def configure_tempdir_registry(registry: TempDirectoryTypeRegistry) -> None:\n        for t in KEEPABLE_TEMPDIR_TYPES:\n            registry.set_delete(t, False)\n\n    def wrapper(\n        self: RequirementCommand, options: Values, args: List[Any]\n    ) -> Optional[int]:\n        assert self.tempdir_registry is not None\n        if options.no_clean:\n            configure_tempdir_registry(self.tempdir_registry)\n\n        try:\n            return func(self, options, args)\n        except PreviousBuildDirError:\n            # This kind of conflict can occur when the user passes an explicit\n            # build directory with a pre-existing folder. In that case we do\n            # not want to accidentally remove it.\n            configure_tempdir_registry(self.tempdir_registry)\n            raise\n\n    return wrapper\n\n\nclass RequirementCommand(IndexGroupCommand):\n    def __init__(self, *args: Any, **kw: Any) -> None:\n        super().__init__(*args, **kw)\n\n        self.cmd_opts.add_option(cmdoptions.no_clean())\n\n    @staticmethod\n    def determine_resolver_variant(options: Values) -> str:\n        \"\"\"Determines which resolver should be used, based on the given options.\"\"\"\n        if \"legacy-resolver\" in options.deprecated_features_enabled:\n            return \"legacy\"\n\n        return \"resolvelib\"\n\n    @classmethod\n    def make_requirement_preparer(\n        cls,\n        temp_build_dir: TempDirectory,\n        options: Values,\n        build_tracker: BuildTracker,\n        session: PipSession,\n        finder: PackageFinder,\n        use_user_site: bool,\n        download_dir: Optional[str] = None,\n        verbosity: int = 0,\n    ) -> RequirementPreparer:\n        \"\"\"\n        Create a RequirementPreparer instance for the given parameters.\n        \"\"\"\n        temp_build_dir_path = temp_build_dir.path\n        assert temp_build_dir_path is not None\n        legacy_resolver = False\n\n        resolver_variant = cls.determine_resolver_variant(options)\n        if resolver_variant == \"resolvelib\":\n            lazy_wheel = \"fast-deps\" in options.features_enabled\n            if lazy_wheel:\n                logger.warning(\n                    \"pip is using lazily downloaded wheels using HTTP \"\n                    \"range requests to obtain dependency information. \"\n                    \"This experimental feature is enabled through \"\n                    \"--use-feature=fast-deps and it is not ready for \"\n                    \"production.\"\n                )\n        else:\n            legacy_resolver = True\n            lazy_wheel = False\n            if \"fast-deps\" in options.features_enabled:\n                logger.warning(\n                    \"fast-deps has no effect when used with the legacy resolver.\"\n                )\n\n        return RequirementPreparer(\n            build_dir=temp_build_dir_path,\n            src_dir=options.src_dir,\n            download_dir=download_dir,\n            build_isolation=options.build_isolation,\n            check_build_deps=options.check_build_deps,\n            build_tracker=build_tracker,\n            session=session,\n            progress_bar=options.progress_bar,\n            finder=finder,\n            require_hashes=options.require_hashes,\n            use_user_site=use_user_site,\n            lazy_wheel=lazy_wheel,\n            verbosity=verbosity,\n            legacy_resolver=legacy_resolver,\n        )\n\n    @classmethod\n    def make_resolver(\n        cls,\n        preparer: RequirementPreparer,\n        finder: PackageFinder,\n        options: Values,\n        wheel_cache: Optional[WheelCache] = None,\n        use_user_site: bool = False,\n        ignore_installed: bool = True,\n        ignore_requires_python: bool = False,\n        force_reinstall: bool = False,\n        upgrade_strategy: str = \"to-satisfy-only\",\n        use_pep517: Optional[bool] = None,\n        py_version_info: Optional[Tuple[int, ...]] = None,\n    ) -> BaseResolver:\n        \"\"\"\n        Create a Resolver instance for the given parameters.\n        \"\"\"\n        make_install_req = partial(\n            install_req_from_req_string,\n            isolated=options.isolated_mode,\n            use_pep517=use_pep517,\n        )\n        resolver_variant = cls.determine_resolver_variant(options)\n        # The long import name and duplicated invocation is needed to convince\n        # Mypy into correctly typechecking. Otherwise it would complain the\n        # \"Resolver\" class being redefined.\n        if resolver_variant == \"resolvelib\":\n            import pip._internal.resolution.resolvelib.resolver\n\n            return pip._internal.resolution.resolvelib.resolver.Resolver(\n                preparer=preparer,\n                finder=finder,\n                wheel_cache=wheel_cache,\n                make_install_req=make_install_req,\n                use_user_site=use_user_site,\n                ignore_dependencies=options.ignore_dependencies,\n                ignore_installed=ignore_installed,\n                ignore_requires_python=ignore_requires_python,\n                force_reinstall=force_reinstall,\n                upgrade_strategy=upgrade_strategy,\n                py_version_info=py_version_info,\n            )\n        import pip._internal.resolution.legacy.resolver\n\n        return pip._internal.resolution.legacy.resolver.Resolver(\n            preparer=preparer,\n            finder=finder,\n            wheel_cache=wheel_cache,\n            make_install_req=make_install_req,\n            use_user_site=use_user_site,\n            ignore_dependencies=options.ignore_dependencies,\n            ignore_installed=ignore_installed,\n            ignore_requires_python=ignore_requires_python,\n            force_reinstall=force_reinstall,\n            upgrade_strategy=upgrade_strategy,\n            py_version_info=py_version_info,\n        )\n\n    def get_requirements(\n        self,\n        args: List[str],\n        options: Values,\n        finder: PackageFinder,\n        session: PipSession,\n    ) -> List[InstallRequirement]:\n        \"\"\"\n        Parse command-line arguments into the corresponding requirements.\n        \"\"\"\n        requirements: List[InstallRequirement] = []\n        for filename in options.constraints:\n            for parsed_req in parse_requirements(\n                filename,\n                constraint=True,\n                finder=finder,\n                options=options,\n                session=session,\n            ):\n                req_to_add = install_req_from_parsed_requirement(\n                    parsed_req,\n                    isolated=options.isolated_mode,\n                    user_supplied=False,\n                )\n                requirements.append(req_to_add)\n\n        for req in args:\n            req_to_add = install_req_from_line(\n                req,\n                comes_from=None,\n                isolated=options.isolated_mode,\n                use_pep517=options.use_pep517,\n                user_supplied=True,\n                config_settings=getattr(options, \"config_settings\", None),\n            )\n            requirements.append(req_to_add)\n\n        for req in options.editables:\n            req_to_add = install_req_from_editable(\n                req,\n                user_supplied=True,\n                isolated=options.isolated_mode,\n                use_pep517=options.use_pep517,\n                config_settings=getattr(options, \"config_settings\", None),\n            )\n            requirements.append(req_to_add)\n\n        # NOTE: options.require_hashes may be set if --require-hashes is True\n        for filename in options.requirements:\n            for parsed_req in parse_requirements(\n                filename, finder=finder, options=options, session=session\n            ):\n                req_to_add = install_req_from_parsed_requirement(\n                    parsed_req,\n                    isolated=options.isolated_mode,\n                    use_pep517=options.use_pep517,\n                    user_supplied=True,\n                    config_settings=(\n                        parsed_req.options.get(\"config_settings\")\n                        if parsed_req.options\n                        else None\n                    ),\n                )\n                requirements.append(req_to_add)\n\n        # If any requirement has hash options, enable hash checking.\n        if any(req.has_hash_options for req in requirements):\n            options.require_hashes = True\n\n        if not (args or options.editables or options.requirements):\n            opts = {\"name\": self.name}\n            if options.find_links:\n                raise CommandError(\n                    \"You must give at least one requirement to {name} \"\n                    '(maybe you meant \"pip {name} {links}\"?)'.format(\n                        **dict(opts, links=\" \".join(options.find_links))\n                    )\n                )\n            else:\n                raise CommandError(\n                    \"You must give at least one requirement to {name} \"\n                    '(see \"pip help {name}\")'.format(**opts)\n                )\n\n        return requirements\n\n    @staticmethod\n    def trace_basic_info(finder: PackageFinder) -> None:\n        \"\"\"\n        Trace basic information about the provided objects.\n        \"\"\"\n        # Display where finder is looking for packages\n        search_scope = finder.search_scope\n        locations = search_scope.get_formatted_locations()\n        if locations:\n            logger.info(locations)\n\n    def _build_package_finder(\n        self,\n        options: Values,\n        session: PipSession,\n        target_python: Optional[TargetPython] = None,\n        ignore_requires_python: Optional[bool] = None,\n    ) -> PackageFinder:\n        \"\"\"\n        Create a package finder appropriate to this requirement command.\n\n        :param ignore_requires_python: Whether to ignore incompatible\n            \"Requires-Python\" values in links. Defaults to False.\n        \"\"\"\n        link_collector = LinkCollector.create(session, options=options)\n        selection_prefs = SelectionPreferences(\n            allow_yanked=True,\n            format_control=options.format_control,\n            allow_all_prereleases=options.pre,\n            prefer_binary=options.prefer_binary,\n            ignore_requires_python=ignore_requires_python,\n        )\n\n        return PackageFinder.create(\n            link_collector=link_collector,\n            selection_prefs=selection_prefs,\n            target_python=target_python,\n        )\n",
  "metadata": {},
  "relative_path": "venv_new\\Lib\\site-packages\\pip\\_internal\\cli\\req_command.py",
  "id": "9ae69850c1b9fb37aa27ca57b9673d5c"
}