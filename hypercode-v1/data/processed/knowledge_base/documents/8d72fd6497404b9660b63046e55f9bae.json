{
  "file_name": "version.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\venv_new\\Lib\\site-packages\\pip\\_vendor\\packaging\\version.py",
  "file_size": 16688,
  "created": "2025-12-01T01:58:32.246860",
  "modified": "2025-12-01T01:58:32.248620",
  "file_type": "code",
  "content_hash": "ae4ab2671139e954281fc08ae5845559",
  "content_type": "text",
  "content": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\"\"\"\n.. testsetup::\n\n    from pip._vendor.packaging.version import parse, Version\n\"\"\"\n\nfrom __future__ import annotations\n\nimport itertools\nimport re\nfrom typing import Any, Callable, NamedTuple, SupportsInt, Tuple, Union\n\nfrom ._structures import Infinity, InfinityType, NegativeInfinity, NegativeInfinityType\n\n__all__ = [\"VERSION_PATTERN\", \"InvalidVersion\", \"Version\", \"parse\"]\n\nLocalType = Tuple[Union[int, str], ...]\n\nCmpPrePostDevType = Union[InfinityType, NegativeInfinityType, Tuple[str, int]]\nCmpLocalType = Union[\n    NegativeInfinityType,\n    Tuple[Union[Tuple[int, str], Tuple[NegativeInfinityType, Union[int, str]]], ...],\n]\nCmpKey = Tuple[\n    int,\n    Tuple[int, ...],\n    CmpPrePostDevType,\n    CmpPrePostDevType,\n    CmpPrePostDevType,\n    CmpLocalType,\n]\nVersionComparisonMethod = Callable[[CmpKey, CmpKey], bool]\n\n\nclass _Version(NamedTuple):\n    epoch: int\n    release: tuple[int, ...]\n    dev: tuple[str, int] | None\n    pre: tuple[str, int] | None\n    post: tuple[str, int] | None\n    local: LocalType | None\n\n\ndef parse(version: str) -> Version:\n    \"\"\"Parse the given version string.\n\n    >>> parse('1.0.dev1')\n    <Version('1.0.dev1')>\n\n    :param version: The version string to parse.\n    :raises InvalidVersion: When the version string is not a valid version.\n    \"\"\"\n    return Version(version)\n\n\nclass InvalidVersion(ValueError):\n    \"\"\"Raised when a version string is not a valid version.\n\n    >>> Version(\"invalid\")\n    Traceback (most recent call last):\n        ...\n    packaging.version.InvalidVersion: Invalid version: 'invalid'\n    \"\"\"\n\n\nclass _BaseVersion:\n    _key: tuple[Any, ...]\n\n    def __hash__(self) -> int:\n        return hash(self._key)\n\n    # Please keep the duplicated `isinstance` check\n    # in the six comparisons hereunder\n    # unless you find a way to avoid adding overhead function calls.\n    def __lt__(self, other: _BaseVersion) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key < other._key\n\n    def __le__(self, other: _BaseVersion) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key <= other._key\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key == other._key\n\n    def __ge__(self, other: _BaseVersion) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key >= other._key\n\n    def __gt__(self, other: _BaseVersion) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key > other._key\n\n    def __ne__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key != other._key\n\n\n# Deliberately not anchored to the start and end of the string, to make it\n# easier for 3rd party code to reuse\n_VERSION_PATTERN = r\"\"\"\n    v?\n    (?:\n        (?:(?P<epoch>[0-9]+)!)?                           # epoch\n        (?P<release>[0-9]+(?:\\.[0-9]+)*)                  # release segment\n        (?P<pre>                                          # pre-release\n            [-_\\.]?\n            (?P<pre_l>alpha|a|beta|b|preview|pre|c|rc)\n            [-_\\.]?\n            (?P<pre_n>[0-9]+)?\n        )?\n        (?P<post>                                         # post release\n            (?:-(?P<post_n1>[0-9]+))\n            |\n            (?:\n                [-_\\.]?\n                (?P<post_l>post|rev|r)\n                [-_\\.]?\n                (?P<post_n2>[0-9]+)?\n            )\n        )?\n        (?P<dev>                                          # dev release\n            [-_\\.]?\n            (?P<dev_l>dev)\n            [-_\\.]?\n            (?P<dev_n>[0-9]+)?\n        )?\n    )\n    (?:\\+(?P<local>[a-z0-9]+(?:[-_\\.][a-z0-9]+)*))?       # local version\n\"\"\"\n\nVERSION_PATTERN = _VERSION_PATTERN\n\"\"\"\nA string containing the regular expression used to match a valid version.\n\nThe pattern is not anchored at either end, and is intended for embedding in larger\nexpressions (for example, matching a version number as part of a file name). The\nregular expression should be compiled with the ``re.VERBOSE`` and ``re.IGNORECASE``\nflags set.\n\n:meta hide-value:\n\"\"\"\n\n\nclass Version(_BaseVersion):\n    \"\"\"This class abstracts handling of a project's versions.\n\n    A :class:`Version` instance is comparison aware and can be compared and\n    sorted using the standard Python interfaces.\n\n    >>> v1 = Version(\"1.0a5\")\n    >>> v2 = Version(\"1.0\")\n    >>> v1\n    <Version('1.0a5')>\n    >>> v2\n    <Version('1.0')>\n    >>> v1 < v2\n    True\n    >>> v1 == v2\n    False\n    >>> v1 > v2\n    False\n    >>> v1 >= v2\n    False\n    >>> v1 <= v2\n    True\n    \"\"\"\n\n    _regex = re.compile(r\"^\\s*\" + VERSION_PATTERN + r\"\\s*$\", re.VERBOSE | re.IGNORECASE)\n    _key: CmpKey\n\n    def __init__(self, version: str) -> None:\n        \"\"\"Initialize a Version object.\n\n        :param version:\n            The string representation of a version which will be parsed and normalized\n            before use.\n        :raises InvalidVersion:\n            If the ``version`` does not conform to PEP 440 in any way then this\n            exception will be raised.\n        \"\"\"\n\n        # Validate the version and parse it into pieces\n        match = self._regex.search(version)\n        if not match:\n            raise InvalidVersion(f\"Invalid version: {version!r}\")\n\n        # Store the parsed out pieces of the version\n        self._version = _Version(\n            epoch=int(match.group(\"epoch\")) if match.group(\"epoch\") else 0,\n            release=tuple(int(i) for i in match.group(\"release\").split(\".\")),\n            pre=_parse_letter_version(match.group(\"pre_l\"), match.group(\"pre_n\")),\n            post=_parse_letter_version(\n                match.group(\"post_l\"), match.group(\"post_n1\") or match.group(\"post_n2\")\n            ),\n            dev=_parse_letter_version(match.group(\"dev_l\"), match.group(\"dev_n\")),\n            local=_parse_local_version(match.group(\"local\")),\n        )\n\n        # Generate a key which will be used for sorting\n        self._key = _cmpkey(\n            self._version.epoch,\n            self._version.release,\n            self._version.pre,\n            self._version.post,\n            self._version.dev,\n            self._version.local,\n        )\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the Version that shows all internal state.\n\n        >>> Version('1.0.0')\n        <Version('1.0.0')>\n        \"\"\"\n        return f\"<Version('{self}')>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the version that can be round-tripped.\n\n        >>> str(Version(\"1.0a5\"))\n        '1.0a5'\n        \"\"\"\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        # Pre-release\n        if self.pre is not None:\n            parts.append(\"\".join(str(x) for x in self.pre))\n\n        # Post-release\n        if self.post is not None:\n            parts.append(f\".post{self.post}\")\n\n        # Development release\n        if self.dev is not None:\n            parts.append(f\".dev{self.dev}\")\n\n        # Local version segment\n        if self.local is not None:\n            parts.append(f\"+{self.local}\")\n\n        return \"\".join(parts)\n\n    @property\n    def epoch(self) -> int:\n        \"\"\"The epoch of the version.\n\n        >>> Version(\"2.0.0\").epoch\n        0\n        >>> Version(\"1!2.0.0\").epoch\n        1\n        \"\"\"\n        return self._version.epoch\n\n    @property\n    def release(self) -> tuple[int, ...]:\n        \"\"\"The components of the \"release\" segment of the version.\n\n        >>> Version(\"1.2.3\").release\n        (1, 2, 3)\n        >>> Version(\"2.0.0\").release\n        (2, 0, 0)\n        >>> Version(\"1!2.0.0.post0\").release\n        (2, 0, 0)\n\n        Includes trailing zeroes but not the epoch or any pre-release / development /\n        post-release suffixes.\n        \"\"\"\n        return self._version.release\n\n    @property\n    def pre(self) -> tuple[str, int] | None:\n        \"\"\"The pre-release segment of the version.\n\n        >>> print(Version(\"1.2.3\").pre)\n        None\n        >>> Version(\"1.2.3a1\").pre\n        ('a', 1)\n        >>> Version(\"1.2.3b1\").pre\n        ('b', 1)\n        >>> Version(\"1.2.3rc1\").pre\n        ('rc', 1)\n        \"\"\"\n        return self._version.pre\n\n    @property\n    def post(self) -> int | None:\n        \"\"\"The post-release number of the version.\n\n        >>> print(Version(\"1.2.3\").post)\n        None\n        >>> Version(\"1.2.3.post1\").post\n        1\n        \"\"\"\n        return self._version.post[1] if self._version.post else None\n\n    @property\n    def dev(self) -> int | None:\n        \"\"\"The development number of the version.\n\n        >>> print(Version(\"1.2.3\").dev)\n        None\n        >>> Version(\"1.2.3.dev1\").dev\n        1\n        \"\"\"\n        return self._version.dev[1] if self._version.dev else None\n\n    @property\n    def local(self) -> str | None:\n        \"\"\"The local version segment of the version.\n\n        >>> print(Version(\"1.2.3\").local)\n        None\n        >>> Version(\"1.2.3+abc\").local\n        'abc'\n        \"\"\"\n        if self._version.local:\n            return \".\".join(str(x) for x in self._version.local)\n        else:\n            return None\n\n    @property\n    def public(self) -> str:\n        \"\"\"The public portion of the version.\n\n        >>> Version(\"1.2.3\").public\n        '1.2.3'\n        >>> Version(\"1.2.3+abc\").public\n        '1.2.3'\n        >>> Version(\"1!1.2.3dev1+abc\").public\n        '1!1.2.3.dev1'\n        \"\"\"\n        return str(self).split(\"+\", 1)[0]\n\n    @property\n    def base_version(self) -> str:\n        \"\"\"The \"base version\" of the version.\n\n        >>> Version(\"1.2.3\").base_version\n        '1.2.3'\n        >>> Version(\"1.2.3+abc\").base_version\n        '1.2.3'\n        >>> Version(\"1!1.2.3dev1+abc\").base_version\n        '1!1.2.3'\n\n        The \"base version\" is the public version of the project without any pre or post\n        release markers.\n        \"\"\"\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        return \"\".join(parts)\n\n    @property\n    def is_prerelease(self) -> bool:\n        \"\"\"Whether this version is a pre-release.\n\n        >>> Version(\"1.2.3\").is_prerelease\n        False\n        >>> Version(\"1.2.3a1\").is_prerelease\n        True\n        >>> Version(\"1.2.3b1\").is_prerelease\n        True\n        >>> Version(\"1.2.3rc1\").is_prerelease\n        True\n        >>> Version(\"1.2.3dev1\").is_prerelease\n        True\n        \"\"\"\n        return self.dev is not None or self.pre is not None\n\n    @property\n    def is_postrelease(self) -> bool:\n        \"\"\"Whether this version is a post-release.\n\n        >>> Version(\"1.2.3\").is_postrelease\n        False\n        >>> Version(\"1.2.3.post1\").is_postrelease\n        True\n        \"\"\"\n        return self.post is not None\n\n    @property\n    def is_devrelease(self) -> bool:\n        \"\"\"Whether this version is a development release.\n\n        >>> Version(\"1.2.3\").is_devrelease\n        False\n        >>> Version(\"1.2.3.dev1\").is_devrelease\n        True\n        \"\"\"\n        return self.dev is not None\n\n    @property\n    def major(self) -> int:\n        \"\"\"The first item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").major\n        1\n        \"\"\"\n        return self.release[0] if len(self.release) >= 1 else 0\n\n    @property\n    def minor(self) -> int:\n        \"\"\"The second item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").minor\n        2\n        >>> Version(\"1\").minor\n        0\n        \"\"\"\n        return self.release[1] if len(self.release) >= 2 else 0\n\n    @property\n    def micro(self) -> int:\n        \"\"\"The third item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").micro\n        3\n        >>> Version(\"1\").micro\n        0\n        \"\"\"\n        return self.release[2] if len(self.release) >= 3 else 0\n\n\nclass _TrimmedRelease(Version):\n    @property\n    def release(self) -> tuple[int, ...]:\n        \"\"\"\n        Release segment without any trailing zeros.\n\n        >>> _TrimmedRelease('1.0.0').release\n        (1,)\n        >>> _TrimmedRelease('0.0').release\n        (0,)\n        \"\"\"\n        rel = super().release\n        nonzeros = (index for index, val in enumerate(rel) if val)\n        last_nonzero = max(nonzeros, default=0)\n        return rel[: last_nonzero + 1]\n\n\ndef _parse_letter_version(\n    letter: str | None, number: str | bytes | SupportsInt | None\n) -> tuple[str, int] | None:\n    if letter:\n        # We consider there to be an implicit 0 in a pre-release if there is\n        # not a numeral associated with it.\n        if number is None:\n            number = 0\n\n        # We normalize any letters to their lower case form\n        letter = letter.lower()\n\n        # We consider some words to be alternate spellings of other words and\n        # in those cases we want to normalize the spellings to our preferred\n        # spelling.\n        if letter == \"alpha\":\n            letter = \"a\"\n        elif letter == \"beta\":\n            letter = \"b\"\n        elif letter in [\"c\", \"pre\", \"preview\"]:\n            letter = \"rc\"\n        elif letter in [\"rev\", \"r\"]:\n            letter = \"post\"\n\n        return letter, int(number)\n\n    assert not letter\n    if number:\n        # We assume if we are given a number, but we are not given a letter\n        # then this is using the implicit post release syntax (e.g. 1.0-1)\n        letter = \"post\"\n\n        return letter, int(number)\n\n    return None\n\n\n_local_version_separators = re.compile(r\"[\\._-]\")\n\n\ndef _parse_local_version(local: str | None) -> LocalType | None:\n    \"\"\"\n    Takes a string like abc.1.twelve and turns it into (\"abc\", 1, \"twelve\").\n    \"\"\"\n    if local is not None:\n        return tuple(\n            part.lower() if not part.isdigit() else int(part)\n            for part in _local_version_separators.split(local)\n        )\n    return None\n\n\ndef _cmpkey(\n    epoch: int,\n    release: tuple[int, ...],\n    pre: tuple[str, int] | None,\n    post: tuple[str, int] | None,\n    dev: tuple[str, int] | None,\n    local: LocalType | None,\n) -> CmpKey:\n    # When we compare a release version, we want to compare it with all of the\n    # trailing zeros removed. So we'll use a reverse the list, drop all the now\n    # leading zeros until we come to something non zero, then take the rest\n    # re-reverse it back into the correct order and make it a tuple and use\n    # that for our sorting key.\n    _release = tuple(\n        reversed(list(itertools.dropwhile(lambda x: x == 0, reversed(release))))\n    )\n\n    # We need to \"trick\" the sorting algorithm to put 1.0.dev0 before 1.0a0.\n    # We'll do this by abusing the pre segment, but we _only_ want to do this\n    # if there is not a pre or a post segment. If we have one of those then\n    # the normal sorting rules will handle this case correctly.\n    if pre is None and post is None and dev is not None:\n        _pre: CmpPrePostDevType = NegativeInfinity\n    # Versions without a pre-release (except as noted above) should sort after\n    # those with one.\n    elif pre is None:\n        _pre = Infinity\n    else:\n        _pre = pre\n\n    # Versions without a post segment should sort before those with one.\n    if post is None:\n        _post: CmpPrePostDevType = NegativeInfinity\n\n    else:\n        _post = post\n\n    # Versions without a development segment should sort after those with one.\n    if dev is None:\n        _dev: CmpPrePostDevType = Infinity\n\n    else:\n        _dev = dev\n\n    if local is None:\n        # Versions without a local segment should sort before those with one.\n        _local: CmpLocalType = NegativeInfinity\n    else:\n        # Versions with a local segment need that segment parsed to implement\n        # the sorting rules in PEP440.\n        # - Alpha numeric segments sort before numeric segments\n        # - Alpha numeric segments sort lexicographically\n        # - Numeric segments sort numerically\n        # - Shorter versions sort before longer versions when the prefixes\n        #   match exactly\n        _local = tuple(\n            (i, \"\") if isinstance(i, int) else (NegativeInfinity, i) for i in local\n        )\n\n    return epoch, _release, _pre, _post, _dev, _local\n",
  "metadata": {},
  "relative_path": "venv_new\\Lib\\site-packages\\pip\\_vendor\\packaging\\version.py",
  "id": "8d72fd6497404b9660b63046e55f9bae"
}