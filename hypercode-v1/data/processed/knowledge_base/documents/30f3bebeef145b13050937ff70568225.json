{
  "file_name": "rtf.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\venv_new\\Lib\\site-packages\\pip\\_vendor\\pygments\\formatters\\rtf.py",
  "file_size": 11957,
  "created": "2025-12-01T01:58:32.830670",
  "modified": "2025-12-01T01:58:32.836527",
  "file_type": "code",
  "content_hash": "584f0c7ee04420aa8e32d8ba5428c887",
  "content_type": "text",
  "content": "\"\"\"\n    pygments.formatters.rtf\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    A formatter that generates RTF files.\n\n    :copyright: Copyright 2006-2024 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n\"\"\"\n\nfrom collections import OrderedDict\nfrom pip._vendor.pygments.formatter import Formatter\nfrom pip._vendor.pygments.style import _ansimap\nfrom pip._vendor.pygments.util import get_bool_opt, get_int_opt, get_list_opt, surrogatepair\n\n\n__all__ = ['RtfFormatter']\n\n\nclass RtfFormatter(Formatter):\n    \"\"\"\n    Format tokens as RTF markup. This formatter automatically outputs full RTF\n    documents with color information and other useful stuff. Perfect for Copy and\n    Paste into Microsoft(R) Word(R) documents.\n\n    Please note that ``encoding`` and ``outencoding`` options are ignored.\n    The RTF format is ASCII natively, but handles unicode characters correctly\n    thanks to escape sequences.\n\n    .. versionadded:: 0.6\n\n    Additional options accepted:\n\n    `style`\n        The style to use, can be a string or a Style subclass (default:\n        ``'default'``).\n\n    `fontface`\n        The used font family, for example ``Bitstream Vera Sans``. Defaults to\n        some generic font which is supposed to have fixed width.\n\n    `fontsize`\n        Size of the font used. Size is specified in half points. The\n        default is 24 half-points, giving a size 12 font.\n\n        .. versionadded:: 2.0\n\n    `linenos`\n        Turn on line numbering (default: ``False``).\n\n        .. versionadded:: 2.18\n\n    `lineno_fontsize`\n        Font size for line numbers. Size is specified in half points\n        (default: `fontsize`). \n\n        .. versionadded:: 2.18\n\n    `lineno_padding`\n        Number of spaces between the (inline) line numbers and the\n        source code (default: ``2``).\n\n        .. versionadded:: 2.18\n\n    `linenostart`\n        The line number for the first line (default: ``1``).\n\n        .. versionadded:: 2.18\n\n    `linenostep`\n        If set to a number n > 1, only every nth line number is printed.\n\n        .. versionadded:: 2.18\n\n    `lineno_color`\n        Color for line numbers specified as a hex triplet, e.g. ``'5e5e5e'``. \n        Defaults to the style's line number color if it is a hex triplet, \n        otherwise ansi bright black.\n\n        .. versionadded:: 2.18\n\n    `hl_lines`\n        Specify a list of lines to be highlighted, as line numbers separated by\n        spaces, e.g. ``'3 7 8'``. The line numbers are relative to the input \n        (i.e. the first line is line 1) unless `hl_linenostart` is set.\n\n        .. versionadded:: 2.18\n\n    `hl_color`\n        Color for highlighting the lines specified in `hl_lines`, specified as \n        a hex triplet (default: style's `highlight_color`).\n\n        .. versionadded:: 2.18\n\n    `hl_linenostart`\n        If set to ``True`` line numbers in `hl_lines` are specified\n        relative to `linenostart` (default ``False``).\n\n        .. versionadded:: 2.18\n    \"\"\"\n    name = 'RTF'\n    aliases = ['rtf']\n    filenames = ['*.rtf']\n\n    def __init__(self, **options):\n        r\"\"\"\n        Additional options accepted:\n\n        ``fontface``\n            Name of the font used. Could for example be ``'Courier New'``\n            to further specify the default which is ``'\\fmodern'``. The RTF\n            specification claims that ``\\fmodern`` are \"Fixed-pitch serif\n            and sans serif fonts\". Hope every RTF implementation thinks\n            the same about modern...\n\n        \"\"\"\n        Formatter.__init__(self, **options)\n        self.fontface = options.get('fontface') or ''\n        self.fontsize = get_int_opt(options, 'fontsize', 0)\n        self.linenos = get_bool_opt(options, 'linenos', False)\n        self.lineno_fontsize = get_int_opt(options, 'lineno_fontsize',\n                                           self.fontsize)\n        self.lineno_padding = get_int_opt(options, 'lineno_padding', 2)\n        self.linenostart = abs(get_int_opt(options, 'linenostart', 1))\n        self.linenostep = abs(get_int_opt(options, 'linenostep', 1))\n        self.hl_linenostart = get_bool_opt(options, 'hl_linenostart', False)\n\n        self.hl_color = options.get('hl_color', '')\n        if not self.hl_color:\n            self.hl_color = self.style.highlight_color\n\n        self.hl_lines = []\n        for lineno in get_list_opt(options, 'hl_lines', []):\n            try:\n                lineno = int(lineno)\n                if self.hl_linenostart:\n                    lineno = lineno - self.linenostart + 1\n                self.hl_lines.append(lineno)\n            except ValueError:\n                pass\n\n        self.lineno_color = options.get('lineno_color', '')\n        if not self.lineno_color:\n            if  self.style.line_number_color == 'inherit':\n                # style color is the css value 'inherit'\n                # default to ansi bright-black\n                self.lineno_color = _ansimap['ansibrightblack']\n            else:\n                # style color is assumed to be a hex triplet as other\n                # colors in pygments/style.py\n                self.lineno_color = self.style.line_number_color\n\n        self.color_mapping = self._create_color_mapping()\n\n    def _escape(self, text):\n        return text.replace('\\\\', '\\\\\\\\') \\\n                   .replace('{', '\\\\{') \\\n                   .replace('}', '\\\\}')\n\n    def _escape_text(self, text):\n        # empty strings, should give a small performance improvement\n        if not text:\n            return ''\n\n        # escape text\n        text = self._escape(text)\n\n        buf = []\n        for c in text:\n            cn = ord(c)\n            if cn < (2**7):\n                # ASCII character\n                buf.append(str(c))\n            elif (2**7) <= cn < (2**16):\n                # single unicode escape sequence\n                buf.append('{\\\\u%d}' % cn)\n            elif (2**16) <= cn:\n                # RTF limits unicode to 16 bits.\n                # Force surrogate pairs\n                buf.append('{\\\\u%d}{\\\\u%d}' % surrogatepair(cn))\n\n        return ''.join(buf).replace('\\n', '\\\\par')\n\n    @staticmethod\n    def hex_to_rtf_color(hex_color):\n        if hex_color[0] == \"#\":\n            hex_color = hex_color[1:]\n\n        return '\\\\red%d\\\\green%d\\\\blue%d;' % (\n                        int(hex_color[0:2], 16),\n                        int(hex_color[2:4], 16),\n                        int(hex_color[4:6], 16)\n                    )\n\n    def _split_tokens_on_newlines(self, tokensource):\n        \"\"\"\n        Split tokens containing newline characters into multiple token\n        each representing a line of the input file. Needed for numbering\n        lines of e.g. multiline comments.\n        \"\"\"\n        for ttype, value in tokensource:\n            if value == '\\n':\n                yield (ttype, value)\n            elif \"\\n\" in value:\n                lines = value.split(\"\\n\")\n                for line in lines[:-1]:\n                    yield (ttype, line+\"\\n\")\n                if lines[-1]:\n                    yield (ttype, lines[-1])\n            else:\n                yield (ttype, value)\n\n    def _create_color_mapping(self):\n        \"\"\"\n        Create a mapping of style hex colors to index/offset in\n        the RTF color table.\n        \"\"\"\n        color_mapping = OrderedDict()\n        offset = 1\n\n        if self.linenos:\n            color_mapping[self.lineno_color] = offset\n            offset += 1\n\n        if self.hl_lines:\n            color_mapping[self.hl_color] = offset\n            offset += 1\n\n        for _, style in self.style:\n            for color in style['color'], style['bgcolor'], style['border']:\n                if color and color not in color_mapping:\n                    color_mapping[color] = offset\n                    offset += 1\n\n        return color_mapping\n\n    @property\n    def _lineno_template(self):\n        if self.lineno_fontsize != self.fontsize:\n            return '{{\\\\fs{} \\\\cf{} %s{}}}'.format(self.lineno_fontsize,\n                          self.color_mapping[self.lineno_color],\n                          \" \" * self.lineno_padding)\n\n        return '{{\\\\cf{} %s{}}}'.format(self.color_mapping[self.lineno_color],\n                      \" \" * self.lineno_padding)\n\n    @property\n    def _hl_open_str(self):\n        return rf'{{\\highlight{self.color_mapping[self.hl_color]} '\n\n    @property\n    def _rtf_header(self):\n        lines = []\n        # rtf 1.8 header\n        lines.append('{\\\\rtf1\\\\ansi\\\\uc0\\\\deff0'\n                     '{\\\\fonttbl{\\\\f0\\\\fmodern\\\\fprq1\\\\fcharset0%s;}}'\n                     % (self.fontface and ' '\n                        + self._escape(self.fontface) or ''))\n\n        # color table\n        lines.append('{\\\\colortbl;')\n        for color, _ in self.color_mapping.items():\n            lines.append(self.hex_to_rtf_color(color))\n        lines.append('}')\n\n        # font and fontsize\n        lines.append('\\\\f0\\\\sa0')\n        if self.fontsize:\n            lines.append('\\\\fs%d' % self.fontsize)\n\n        # ensure Libre Office Writer imports and renders consecutive\n        # space characters the same width, needed for line numbering.\n        # https://bugs.documentfoundation.org/show_bug.cgi?id=144050\n        lines.append('\\\\dntblnsbdb')\n\n        return lines\n\n    def format_unencoded(self, tokensource, outfile):\n        for line in self._rtf_header:\n            outfile.write(line + \"\\n\")\n\n        tokensource = self._split_tokens_on_newlines(tokensource)\n\n        # first pass of tokens to count lines, needed for line numbering\n        if self.linenos:\n            line_count = 0\n            tokens = [] # for copying the token source generator\n            for ttype, value in tokensource:\n                tokens.append((ttype, value))\n                if value.endswith(\"\\n\"):\n                    line_count += 1\n\n            # width of line number strings (for padding with spaces)\n            linenos_width = len(str(line_count+self.linenostart-1))\n\n            tokensource = tokens\n\n        # highlight stream\n        lineno = 1\n        start_new_line = True\n        for ttype, value in tokensource:\n            if start_new_line and lineno in self.hl_lines:\n                outfile.write(self._hl_open_str)\n\n            if start_new_line and self.linenos:\n                if (lineno-self.linenostart+1)%self.linenostep == 0:\n                    current_lineno = lineno + self.linenostart - 1\n                    lineno_str = str(current_lineno).rjust(linenos_width)\n                else:\n                    lineno_str = \"\".rjust(linenos_width)\n                outfile.write(self._lineno_template % lineno_str)\n\n            while not self.style.styles_token(ttype) and ttype.parent:\n                ttype = ttype.parent\n            style = self.style.style_for_token(ttype)\n            buf = []\n            if style['bgcolor']:\n                buf.append('\\\\cb%d' % self.color_mapping[style['bgcolor']])\n            if style['color']:\n                buf.append('\\\\cf%d' % self.color_mapping[style['color']])\n            if style['bold']:\n                buf.append('\\\\b')\n            if style['italic']:\n                buf.append('\\\\i')\n            if style['underline']:\n                buf.append('\\\\ul')\n            if style['border']:\n                buf.append('\\\\chbrdr\\\\chcfpat%d' %\n                           self.color_mapping[style['border']])\n            start = ''.join(buf)\n            if start:\n                outfile.write(f'{{{start} ')\n            outfile.write(self._escape_text(value))\n            if start:\n                outfile.write('}')\n            start_new_line = False\n\n            # complete line of input\n            if value.endswith(\"\\n\"):\n                # close line highlighting\n                if lineno in self.hl_lines:\n                    outfile.write('}')\n                # newline in RTF file after closing }\n                outfile.write(\"\\n\")\n\n                start_new_line = True\n                lineno += 1\n\n        outfile.write('}\\n')\n",
  "metadata": {},
  "relative_path": "venv_new\\Lib\\site-packages\\pip\\_vendor\\pygments\\formatters\\rtf.py",
  "id": "30f3bebeef145b13050937ff70568225"
}