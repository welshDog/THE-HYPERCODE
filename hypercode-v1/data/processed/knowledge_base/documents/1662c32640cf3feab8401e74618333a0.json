{
  "file_name": "unpacking.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\venv_new\\Lib\\site-packages\\pip\\_internal\\utils\\unpacking.py",
  "file_size": 11967,
  "created": "2025-12-01T01:58:31.619187",
  "modified": "2025-12-01T01:58:31.620742",
  "file_type": "code",
  "content_hash": "491504c0696ddc34bd8a63e6c88ebad3",
  "content_type": "text",
  "content": "\"\"\"Utilities related archives.\n\"\"\"\n\nimport logging\nimport os\nimport shutil\nimport stat\nimport sys\nimport tarfile\nimport zipfile\nfrom typing import Iterable, List, Optional\nfrom zipfile import ZipInfo\n\nfrom pip._internal.exceptions import InstallationError\nfrom pip._internal.utils.filetypes import (\n    BZ2_EXTENSIONS,\n    TAR_EXTENSIONS,\n    XZ_EXTENSIONS,\n    ZIP_EXTENSIONS,\n)\nfrom pip._internal.utils.misc import ensure_dir\n\nlogger = logging.getLogger(__name__)\n\n\nSUPPORTED_EXTENSIONS = ZIP_EXTENSIONS + TAR_EXTENSIONS\n\ntry:\n    import bz2  # noqa\n\n    SUPPORTED_EXTENSIONS += BZ2_EXTENSIONS\nexcept ImportError:\n    logger.debug(\"bz2 module is not available\")\n\ntry:\n    # Only for Python 3.3+\n    import lzma  # noqa\n\n    SUPPORTED_EXTENSIONS += XZ_EXTENSIONS\nexcept ImportError:\n    logger.debug(\"lzma module is not available\")\n\n\ndef current_umask() -> int:\n    \"\"\"Get the current umask which involves having to set it temporarily.\"\"\"\n    mask = os.umask(0)\n    os.umask(mask)\n    return mask\n\n\ndef split_leading_dir(path: str) -> List[str]:\n    path = path.lstrip(\"/\").lstrip(\"\\\\\")\n    if \"/\" in path and (\n        (\"\\\\\" in path and path.find(\"/\") < path.find(\"\\\\\")) or \"\\\\\" not in path\n    ):\n        return path.split(\"/\", 1)\n    elif \"\\\\\" in path:\n        return path.split(\"\\\\\", 1)\n    else:\n        return [path, \"\"]\n\n\ndef has_leading_dir(paths: Iterable[str]) -> bool:\n    \"\"\"Returns true if all the paths have the same leading path name\n    (i.e., everything is in one subdirectory in an archive)\"\"\"\n    common_prefix = None\n    for path in paths:\n        prefix, rest = split_leading_dir(path)\n        if not prefix:\n            return False\n        elif common_prefix is None:\n            common_prefix = prefix\n        elif prefix != common_prefix:\n            return False\n    return True\n\n\ndef is_within_directory(directory: str, target: str) -> bool:\n    \"\"\"\n    Return true if the absolute path of target is within the directory\n    \"\"\"\n    abs_directory = os.path.abspath(directory)\n    abs_target = os.path.abspath(target)\n\n    prefix = os.path.commonprefix([abs_directory, abs_target])\n    return prefix == abs_directory\n\n\ndef _get_default_mode_plus_executable() -> int:\n    return 0o777 & ~current_umask() | 0o111\n\n\ndef set_extracted_file_to_default_mode_plus_executable(path: str) -> None:\n    \"\"\"\n    Make file present at path have execute for user/group/world\n    (chmod +x) is no-op on windows per python docs\n    \"\"\"\n    os.chmod(path, _get_default_mode_plus_executable())\n\n\ndef zip_item_is_executable(info: ZipInfo) -> bool:\n    mode = info.external_attr >> 16\n    # if mode and regular file and any execute permissions for\n    # user/group/world?\n    return bool(mode and stat.S_ISREG(mode) and mode & 0o111)\n\n\ndef unzip_file(filename: str, location: str, flatten: bool = True) -> None:\n    \"\"\"\n    Unzip the file (with path `filename`) to the destination `location`.  All\n    files are written based on system defaults and umask (i.e. permissions are\n    not preserved), except that regular file members with any execute\n    permissions (user, group, or world) have \"chmod +x\" applied after being\n    written. Note that for windows, any execute changes using os.chmod are\n    no-ops per the python docs.\n    \"\"\"\n    ensure_dir(location)\n    zipfp = open(filename, \"rb\")\n    try:\n        zip = zipfile.ZipFile(zipfp, allowZip64=True)\n        leading = has_leading_dir(zip.namelist()) and flatten\n        for info in zip.infolist():\n            name = info.filename\n            fn = name\n            if leading:\n                fn = split_leading_dir(name)[1]\n            fn = os.path.join(location, fn)\n            dir = os.path.dirname(fn)\n            if not is_within_directory(location, fn):\n                message = (\n                    \"The zip file ({}) has a file ({}) trying to install \"\n                    \"outside target directory ({})\"\n                )\n                raise InstallationError(message.format(filename, fn, location))\n            if fn.endswith(\"/\") or fn.endswith(\"\\\\\"):\n                # A directory\n                ensure_dir(fn)\n            else:\n                ensure_dir(dir)\n                # Don't use read() to avoid allocating an arbitrarily large\n                # chunk of memory for the file's content\n                fp = zip.open(name)\n                try:\n                    with open(fn, \"wb\") as destfp:\n                        shutil.copyfileobj(fp, destfp)\n                finally:\n                    fp.close()\n                    if zip_item_is_executable(info):\n                        set_extracted_file_to_default_mode_plus_executable(fn)\n    finally:\n        zipfp.close()\n\n\ndef untar_file(filename: str, location: str) -> None:\n    \"\"\"\n    Untar the file (with path `filename`) to the destination `location`.\n    All files are written based on system defaults and umask (i.e. permissions\n    are not preserved), except that regular file members with any execute\n    permissions (user, group, or world) have \"chmod +x\" applied on top of the\n    default.  Note that for windows, any execute changes using os.chmod are\n    no-ops per the python docs.\n    \"\"\"\n    ensure_dir(location)\n    if filename.lower().endswith(\".gz\") or filename.lower().endswith(\".tgz\"):\n        mode = \"r:gz\"\n    elif filename.lower().endswith(BZ2_EXTENSIONS):\n        mode = \"r:bz2\"\n    elif filename.lower().endswith(XZ_EXTENSIONS):\n        mode = \"r:xz\"\n    elif filename.lower().endswith(\".tar\"):\n        mode = \"r\"\n    else:\n        logger.warning(\n            \"Cannot determine compression type for file %s\",\n            filename,\n        )\n        mode = \"r:*\"\n\n    tar = tarfile.open(filename, mode, encoding=\"utf-8\")  # type: ignore\n    try:\n        leading = has_leading_dir([member.name for member in tar.getmembers()])\n\n        # PEP 706 added `tarfile.data_filter`, and made some other changes to\n        # Python's tarfile module (see below). The features were backported to\n        # security releases.\n        try:\n            data_filter = tarfile.data_filter\n        except AttributeError:\n            _untar_without_filter(filename, location, tar, leading)\n        else:\n            default_mode_plus_executable = _get_default_mode_plus_executable()\n\n            if leading:\n                # Strip the leading directory from all files in the archive,\n                # including hardlink targets (which are relative to the\n                # unpack location).\n                for member in tar.getmembers():\n                    name_lead, name_rest = split_leading_dir(member.name)\n                    member.name = name_rest\n                    if member.islnk():\n                        lnk_lead, lnk_rest = split_leading_dir(member.linkname)\n                        if lnk_lead == name_lead:\n                            member.linkname = lnk_rest\n\n            def pip_filter(member: tarfile.TarInfo, path: str) -> tarfile.TarInfo:\n                orig_mode = member.mode\n                try:\n                    try:\n                        member = data_filter(member, location)\n                    except tarfile.LinkOutsideDestinationError:\n                        if sys.version_info[:3] in {\n                            (3, 8, 17),\n                            (3, 9, 17),\n                            (3, 10, 12),\n                            (3, 11, 4),\n                        }:\n                            # The tarfile filter in specific Python versions\n                            # raises LinkOutsideDestinationError on valid input\n                            # (https://github.com/python/cpython/issues/107845)\n                            # Ignore the error there, but do use the\n                            # more lax `tar_filter`\n                            member = tarfile.tar_filter(member, location)\n                        else:\n                            raise\n                except tarfile.TarError as exc:\n                    message = \"Invalid member in the tar file {}: {}\"\n                    # Filter error messages mention the member name.\n                    # No need to add it here.\n                    raise InstallationError(\n                        message.format(\n                            filename,\n                            exc,\n                        )\n                    )\n                if member.isfile() and orig_mode & 0o111:\n                    member.mode = default_mode_plus_executable\n                else:\n                    # See PEP 706 note above.\n                    # The PEP changed this from `int` to `Optional[int]`,\n                    # where None means \"use the default\". Mypy doesn't\n                    # know this yet.\n                    member.mode = None  # type: ignore [assignment]\n                return member\n\n            tar.extractall(location, filter=pip_filter)\n\n    finally:\n        tar.close()\n\n\ndef _untar_without_filter(\n    filename: str,\n    location: str,\n    tar: tarfile.TarFile,\n    leading: bool,\n) -> None:\n    \"\"\"Fallback for Python without tarfile.data_filter\"\"\"\n    for member in tar.getmembers():\n        fn = member.name\n        if leading:\n            fn = split_leading_dir(fn)[1]\n        path = os.path.join(location, fn)\n        if not is_within_directory(location, path):\n            message = (\n                \"The tar file ({}) has a file ({}) trying to install \"\n                \"outside target directory ({})\"\n            )\n            raise InstallationError(message.format(filename, path, location))\n        if member.isdir():\n            ensure_dir(path)\n        elif member.issym():\n            try:\n                tar._extract_member(member, path)\n            except Exception as exc:\n                # Some corrupt tar files seem to produce this\n                # (specifically bad symlinks)\n                logger.warning(\n                    \"In the tar file %s the member %s is invalid: %s\",\n                    filename,\n                    member.name,\n                    exc,\n                )\n                continue\n        else:\n            try:\n                fp = tar.extractfile(member)\n            except (KeyError, AttributeError) as exc:\n                # Some corrupt tar files seem to produce this\n                # (specifically bad symlinks)\n                logger.warning(\n                    \"In the tar file %s the member %s is invalid: %s\",\n                    filename,\n                    member.name,\n                    exc,\n                )\n                continue\n            ensure_dir(os.path.dirname(path))\n            assert fp is not None\n            with open(path, \"wb\") as destfp:\n                shutil.copyfileobj(fp, destfp)\n            fp.close()\n            # Update the timestamp (useful for cython compiled files)\n            tar.utime(member, path)\n            # member have any execute permissions for user/group/world?\n            if member.mode & 0o111:\n                set_extracted_file_to_default_mode_plus_executable(path)\n\n\ndef unpack_file(\n    filename: str,\n    location: str,\n    content_type: Optional[str] = None,\n) -> None:\n    filename = os.path.realpath(filename)\n    if (\n        content_type == \"application/zip\"\n        or filename.lower().endswith(ZIP_EXTENSIONS)\n        or zipfile.is_zipfile(filename)\n    ):\n        unzip_file(filename, location, flatten=not filename.endswith(\".whl\"))\n    elif (\n        content_type == \"application/x-gzip\"\n        or tarfile.is_tarfile(filename)\n        or filename.lower().endswith(TAR_EXTENSIONS + BZ2_EXTENSIONS + XZ_EXTENSIONS)\n    ):\n        untar_file(filename, location)\n    else:\n        # FIXME: handle?\n        # FIXME: magic signatures?\n        logger.critical(\n            \"Cannot unpack file %s (downloaded from %s, content-type: %s); \"\n            \"cannot detect archive format\",\n            filename,\n            location,\n            content_type,\n        )\n        raise InstallationError(f\"Cannot determine archive format of {location}\")\n",
  "metadata": {},
  "relative_path": "venv_new\\Lib\\site-packages\\pip\\_internal\\utils\\unpacking.py",
  "id": "1662c32640cf3feab8401e74618333a0"
}