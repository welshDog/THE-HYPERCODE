{
  "file_name": "validate_duelcode.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\src\\duelcode\\validate_duelcode.py",
  "file_size": 3444,
  "created": "2025-11-23T11:56:45.664280",
  "modified": "2025-11-23T11:56:45.664280",
  "file_type": "code",
  "content_hash": "3afa946b5909155a00e8ecf16207f7f6",
  "content_type": "text",
  "content": "\"\"\"\nDuelCode Documentation Validator\n\nThis script validates that Markdown files follow the DuelCode documentation standards.\nIt checks for required sections, formatting, and structure.\n\"\"\"\n\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import List, Tuple\n\n# Required sections and their validation patterns\nREQUIRED_SECTIONS = {\n    \"Learning Objectives\": r\"## üéØ Learning Objective[s]?\\n\\n(?:- \\[ \\].+\\n)+\",\n    \"Before You Start\": r\"## üìã Before You Start \\(Checklist\\)\\n\\n(?:- \\[ \\].+\\n)+\",\n    \"Concept Explanation\": r\"## Part \\d+: .+\\n\\n### üß† Concept:\",\n    \"Visual Representation\": r\"### üìä Visual Representation\\n\\n```\",\n    \"Code Example\": r\"### üíª Code Example\\n\\n```\",\n}\n\n\nclass DuelCodeValidator:\n    def __init__(self, file_path: str):\n        self.file_path = Path(file_path)\n        self.content = self.file_path.read_text(encoding=\"utf-8\")\n        self.errors: List[str] = []\n        self.warnings: List[str] = []\n\n    def validate_sections(self) -> bool:\n        \"\"\"Check if all required sections are present.\"\"\"\n        all_valid = True\n        for section, pattern in REQUIRED_SECTIONS.items():\n            if not re.search(pattern, self.content, re.MULTILINE | re.DOTALL):\n                self.errors.append(f\"Missing or malformed section: {section}\")\n                all_valid = False\n        return all_valid\n\n    def check_formatting(self) -> None:\n        \"\"\"Check for common formatting issues.\"\"\"\n        # Check for proper heading levels\n        headings = re.findall(r\"^(#{1,6})\\s+(.+)$\", self.content, re.MULTILINE)\n        for i, (hashes, text) in enumerate(headings):\n            if i > 0 and len(hashes) > len(headings[i - 1][0]) + 1:\n                self.warnings.append(f\"Heading level jump: '{text}' (skipped a level)\")\n\n        # Check for long paragraphs\n        paragraphs = re.split(r\"\\n{2,}\", self.content)\n        for para in paragraphs:\n            if len(para) > 500 and not para.startswith(\"```\") and \"http\" not in para:\n                self.warnings.append(\n                    f\"Long paragraph detected (>{len(para)} chars). Consider breaking it down.\"\n                )\n\n    def check_visual_aids(self) -> None:\n        \"\"\"Check for presence of visual aids.\"\"\"\n        if self.content.count(\"```\") < 3:  # At least one code block and one diagram\n            self.warnings.append(\"Consider adding more visual aids or code examples\")\n\n    def validate(self) -> Tuple[bool, List[str], List[str]]:\n        \"\"\"Run all validations and return results.\"\"\"\n        self.validate_sections()\n        self.check_formatting()\n        self.check_visual_aids()\n        return (not bool(self.errors), self.errors, self.warnings)\n\n\ndef main():\n    if len(sys.argv) != 2:\n        print(\"Usage: python validate_duelcode.py <markdown_file.md>\")\n        sys.exit(1)\n\n    validator = DuelCodeValidator(sys.argv[1])\n    is_valid, errors, warnings = validator.validate()\n\n    if warnings:\n        print(\"\\n‚ö†Ô∏è  Warnings:\")\n        for warning in warnings:\n            print(f\"  - {warning}\")\n\n    if errors:\n        print(\"\\n‚ùå Errors:\")\n        for error in errors:\n            print(f\"  - {error}\")\n        print(\"\\nDocumentation does not meet DuelCode standards!\")\n        sys.exit(1)\n\n    print(\"\\n‚úÖ Documentation meets DuelCode standards!\")\n    sys.exit(0)\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "metadata": {},
  "relative_path": "src\\duelcode\\validate_duelcode.py",
  "id": "6959fa5158e44da0d4870cabefba11c1"
}