{
  "file_name": "_dists.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\venv_new\\Lib\\site-packages\\pip\\_internal\\metadata\\importlib\\_dists.py",
  "file_size": 8279,
  "created": "2025-12-01T01:58:30.972501",
  "modified": "2025-12-01T01:58:30.973754",
  "file_type": "code",
  "content_hash": "a9239bd524f9db60e5c54d0f2c631585",
  "content_type": "text",
  "content": "import email.message\nimport importlib.metadata\nimport pathlib\nimport zipfile\nfrom os import PathLike\nfrom typing import (\n    Collection,\n    Dict,\n    Iterable,\n    Iterator,\n    Mapping,\n    Optional,\n    Sequence,\n    Union,\n    cast,\n)\n\nfrom pip._vendor.packaging.requirements import Requirement\nfrom pip._vendor.packaging.utils import NormalizedName, canonicalize_name\nfrom pip._vendor.packaging.version import Version\nfrom pip._vendor.packaging.version import parse as parse_version\n\nfrom pip._internal.exceptions import InvalidWheel, UnsupportedWheel\nfrom pip._internal.metadata.base import (\n    BaseDistribution,\n    BaseEntryPoint,\n    InfoPath,\n    Wheel,\n)\nfrom pip._internal.utils.misc import normalize_path\nfrom pip._internal.utils.packaging import get_requirement\nfrom pip._internal.utils.temp_dir import TempDirectory\nfrom pip._internal.utils.wheel import parse_wheel, read_wheel_metadata_file\n\nfrom ._compat import (\n    BasePath,\n    get_dist_canonical_name,\n    parse_name_and_version_from_info_directory,\n)\n\n\nclass WheelDistribution(importlib.metadata.Distribution):\n    \"\"\"An ``importlib.metadata.Distribution`` read from a wheel.\n\n    Although ``importlib.metadata.PathDistribution`` accepts ``zipfile.Path``,\n    its implementation is too \"lazy\" for pip's needs (we can't keep the ZipFile\n    handle open for the entire lifetime of the distribution object).\n\n    This implementation eagerly reads the entire metadata directory into the\n    memory instead, and operates from that.\n    \"\"\"\n\n    def __init__(\n        self,\n        files: Mapping[pathlib.PurePosixPath, bytes],\n        info_location: pathlib.PurePosixPath,\n    ) -> None:\n        self._files = files\n        self.info_location = info_location\n\n    @classmethod\n    def from_zipfile(\n        cls,\n        zf: zipfile.ZipFile,\n        name: str,\n        location: str,\n    ) -> \"WheelDistribution\":\n        info_dir, _ = parse_wheel(zf, name)\n        paths = (\n            (name, pathlib.PurePosixPath(name.split(\"/\", 1)[-1]))\n            for name in zf.namelist()\n            if name.startswith(f\"{info_dir}/\")\n        )\n        files = {\n            relpath: read_wheel_metadata_file(zf, fullpath)\n            for fullpath, relpath in paths\n        }\n        info_location = pathlib.PurePosixPath(location, info_dir)\n        return cls(files, info_location)\n\n    def iterdir(self, path: InfoPath) -> Iterator[pathlib.PurePosixPath]:\n        # Only allow iterating through the metadata directory.\n        if pathlib.PurePosixPath(str(path)) in self._files:\n            return iter(self._files)\n        raise FileNotFoundError(path)\n\n    def read_text(self, filename: str) -> Optional[str]:\n        try:\n            data = self._files[pathlib.PurePosixPath(filename)]\n        except KeyError:\n            return None\n        try:\n            text = data.decode(\"utf-8\")\n        except UnicodeDecodeError as e:\n            wheel = self.info_location.parent\n            error = f\"Error decoding metadata for {wheel}: {e} in {filename} file\"\n            raise UnsupportedWheel(error)\n        return text\n\n    def locate_file(self, path: Union[str, \"PathLike[str]\"]) -> pathlib.Path:\n        # This method doesn't make sense for our in-memory wheel, but the API\n        # requires us to define it.\n        raise NotImplementedError\n\n\nclass Distribution(BaseDistribution):\n    def __init__(\n        self,\n        dist: importlib.metadata.Distribution,\n        info_location: Optional[BasePath],\n        installed_location: Optional[BasePath],\n    ) -> None:\n        self._dist = dist\n        self._info_location = info_location\n        self._installed_location = installed_location\n\n    @classmethod\n    def from_directory(cls, directory: str) -> BaseDistribution:\n        info_location = pathlib.Path(directory)\n        dist = importlib.metadata.Distribution.at(info_location)\n        return cls(dist, info_location, info_location.parent)\n\n    @classmethod\n    def from_metadata_file_contents(\n        cls,\n        metadata_contents: bytes,\n        filename: str,\n        project_name: str,\n    ) -> BaseDistribution:\n        # Generate temp dir to contain the metadata file, and write the file contents.\n        temp_dir = pathlib.Path(\n            TempDirectory(kind=\"metadata\", globally_managed=True).path\n        )\n        metadata_path = temp_dir / \"METADATA\"\n        metadata_path.write_bytes(metadata_contents)\n        # Construct dist pointing to the newly created directory.\n        dist = importlib.metadata.Distribution.at(metadata_path.parent)\n        return cls(dist, metadata_path.parent, None)\n\n    @classmethod\n    def from_wheel(cls, wheel: Wheel, name: str) -> BaseDistribution:\n        try:\n            with wheel.as_zipfile() as zf:\n                dist = WheelDistribution.from_zipfile(zf, name, wheel.location)\n        except zipfile.BadZipFile as e:\n            raise InvalidWheel(wheel.location, name) from e\n        return cls(dist, dist.info_location, pathlib.PurePosixPath(wheel.location))\n\n    @property\n    def location(self) -> Optional[str]:\n        if self._info_location is None:\n            return None\n        return str(self._info_location.parent)\n\n    @property\n    def info_location(self) -> Optional[str]:\n        if self._info_location is None:\n            return None\n        return str(self._info_location)\n\n    @property\n    def installed_location(self) -> Optional[str]:\n        if self._installed_location is None:\n            return None\n        return normalize_path(str(self._installed_location))\n\n    @property\n    def canonical_name(self) -> NormalizedName:\n        return get_dist_canonical_name(self._dist)\n\n    @property\n    def version(self) -> Version:\n        if version := parse_name_and_version_from_info_directory(self._dist)[1]:\n            return parse_version(version)\n        return parse_version(self._dist.version)\n\n    @property\n    def raw_version(self) -> str:\n        return self._dist.version\n\n    def is_file(self, path: InfoPath) -> bool:\n        return self._dist.read_text(str(path)) is not None\n\n    def iter_distutils_script_names(self) -> Iterator[str]:\n        # A distutils installation is always \"flat\" (not in e.g. egg form), so\n        # if this distribution's info location is NOT a pathlib.Path (but e.g.\n        # zipfile.Path), it can never contain any distutils scripts.\n        if not isinstance(self._info_location, pathlib.Path):\n            return\n        for child in self._info_location.joinpath(\"scripts\").iterdir():\n            yield child.name\n\n    def read_text(self, path: InfoPath) -> str:\n        content = self._dist.read_text(str(path))\n        if content is None:\n            raise FileNotFoundError(path)\n        return content\n\n    def iter_entry_points(self) -> Iterable[BaseEntryPoint]:\n        # importlib.metadata's EntryPoint structure satisfies BaseEntryPoint.\n        return self._dist.entry_points\n\n    def _metadata_impl(self) -> email.message.Message:\n        # From Python 3.10+, importlib.metadata declares PackageMetadata as the\n        # return type. This protocol is unfortunately a disaster now and misses\n        # a ton of fields that we need, including get() and get_payload(). We\n        # rely on the implementation that the object is actually a Message now,\n        # until upstream can improve the protocol. (python/cpython#94952)\n        return cast(email.message.Message, self._dist.metadata)\n\n    def iter_provided_extras(self) -> Iterable[NormalizedName]:\n        return [\n            canonicalize_name(extra)\n            for extra in self.metadata.get_all(\"Provides-Extra\", [])\n        ]\n\n    def iter_dependencies(self, extras: Collection[str] = ()) -> Iterable[Requirement]:\n        contexts: Sequence[Dict[str, str]] = [{\"extra\": e} for e in extras]\n        for req_string in self.metadata.get_all(\"Requires-Dist\", []):\n            # strip() because email.message.Message.get_all() may return a leading \\n\n            # in case a long header was wrapped.\n            req = get_requirement(req_string.strip())\n            if not req.marker:\n                yield req\n            elif not extras and req.marker.evaluate({\"extra\": \"\"}):\n                yield req\n            elif any(req.marker.evaluate(context) for context in contexts):\n                yield req\n",
  "metadata": {},
  "relative_path": "venv_new\\Lib\\site-packages\\pip\\_internal\\metadata\\importlib\\_dists.py",
  "id": "c263c6b1abbae648448925f1d4671a85"
}