{
  "file_name": "hypercode_lexer_fixed.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\src\\hypercode_lexer_fixed.py",
  "file_size": 10395,
  "created": "2025-11-23T12:01:48.562207",
  "modified": "2025-11-24T23:05:15.566229",
  "file_type": "code",
  "content_hash": "b8ada5fa47c49113b4efc04c6f58fbfe",
  "content_type": "text",
  "content": "HyperCode Lexer - Enhanced Version\nSupports numbers, identifiers, and basic expressions\n\"\"\"\n\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import List, Dict, Optional\nimport sys\n\nclass TokenType(Enum):\n    # Core operations\n    PUSH = \"PUSH\"        # >\n    POP = \"POP\"          # <\n    INCR = \"INCR\"        # +\n    DECR = \"DECR\"        # -\n    OUTPUT = \"OUTPUT\"    # .\n    INPUT = \"INPUT\"      # ,\n    LOOP_START = \"LOOP_START\"  # [\n    LOOP_END = \"LOOP_END\"      # ]\n    STRING = \"STRING\"    # \"...\" or '...'\n    COMMENT = \"COMMENT\"  # ;\n    \n    # New token types\n    NUMBER = \"NUMBER\"        # 123, 3.14, etc.\n    IDENTIFIER = \"IDENTIFIER\" # variable names\n    ASSIGN = \"ASSIGN\"        # =\n    PLUS = \"PLUS\"            # +\n    MINUS = \"MINUS\"          # -\n    MULTIPLY = \"MULTIPLY\"    # *\n    DIVIDE = \"DIVIDE\"        # /\n    LPAREN = \"LPAREN\"        # (\n    RPAREN = \"RPAREN\"        # )\n    \n    # Control flow\n    IF = \"IF\"\n    ELSE = \"ELSE\"\n    WHILE = \"WHILE\"\n    FUNC = \"FUNC\"\n    RETURN = \"RETURN\"\n    \n    # Literals\n    TRUE = \"TRUE\"\n    FALSE = \"FALSE\"\n    NULL = \"NULL\"\n    \n    # Special\n    EOF = \"EOF\"\n    UNKNOWN = \"UNKNOWN\"\n\n@dataclass\nclass Token:\n    type: TokenType\n    value: str\n    raw_value: str\n    position: int\n    line: int\n    column: int\n\n    def __repr__(self) -> str:\n        return f\"Token({self.type.value}, '{self.value}')\"\n\nclass HyperCodeLexer:\n    def __init__(self, text: str):\n        self.text = text\n        self.position = 0\n        self.line = 1\n        self.column = 1\n        self.current_char = self.text[0] if text else None\n        \n        # Keywords mapping\n        self.KEYWORDS = {\n            'if': TokenType.IF,\n            'else': TokenType.ELSE,\n            'while': TokenType.WHILE,\n            'func': TokenType.FUNC,\n            'return': TokenType.RETURN,\n            'true': TokenType.TRUE,\n            'false': TokenType.FALSE,\n            'null': TokenType.NULL,\n        }\n\n    def _error(self, message: str):\n        raise Exception(f\"Lexer error at {self.line}:{self.column}: {message}\")\n\n    def _advance(self):\n        self.position += 1\n        if self.position < len(self.text):\n            self.current_char = self.text[self.position]\n            self.column += 1\n        else:\n            self.current_char = None\n\n    def _skip_whitespace(self):\n        while self.current_char is not None and self.current_char.isspace():\n            if self.current_char == '\\n':\n                self.line += 1\n                self.column = 0\n            self._advance()\n\n    def _is_digit(self, char: str) -> bool:\n        return char is not None and '0' <= char <= '9'\n\n    def _is_alpha(self, char: str) -> bool:\n        return char is not None and (char.isalpha() or char == '_')\n\n    def _is_alnum(self, char: str) -> bool:\n        return char is not None and (char.isalnum() or char == '_')\n\n    def _read_number(self) -> Token:\n        start_pos = self.position\n        start_line = self.line\n        start_col = self.column\n        \n        value = ''\n        has_decimal = False\n        \n        while self.current_char is not None:\n            if self._is_digit(self.current_char):\n                value += self.current_char\n                self._advance()\n            elif self.current_char == '.' and not has_decimal:\n                has_decimal = True\n                value += self.current_char\n                self._advance()\n                if self.current_char is None or not self._is_digit(self.current_char):\n                    self._error(\"Invalid number format\")\n            else:\n                break\n        \n        if value.endswith('.'):\n            self._error(\"Invalid number format\")\n        \n        return Token(\n            type=TokenType.NUMBER,\n            value=value,\n            raw_value=value,\n            position=start_pos,\n            line=start_line,\n            column=start_col\n        )\n\n    def _read_identifier(self) -> Token:\n        start_pos = self.position\n        start_line = self.line\n        start_col = self.column\n        \n        value = self.current_char\n        self._advance()\n        \n        while self.current_char is not None and self._is_alnum(self.current_char):\n            value += self.current_char\n            self._advance()\n        \n        token_type = self.KEYWORDS.get(value.lower(), TokenType.IDENTIFIER)\n        \n        return Token(\n            type=token_type,\n            value=value,\n            raw_value=value,\n            position=start_pos,\n            line=start_line,\n            column=start_col\n        )\n\n    def _read_string(self) -> Token:\n        start_pos = self.position\n        start_line = self.line\n        start_col = self.column\n        \n        quote = self.current_char\n        self._advance()\n        \n        value = ''\n        raw_value = quote\n        \n        while self.current_char is not None and self.current_char != quote:\n            if self.current_char == '\\\\':\n                self._advance()\n                if self.current_char is None:\n                    self._error(\"Unterminated string literal\")\n                # Handle escape sequences here if needed\n                value += self.current_char\n                raw_value += '\\\\' + self.current_char\n            else:\n                value += self.current_char\n                raw_value += self.current_char\n            self._advance()\n        \n        if self.current_char != quote:\n            self._error(\"Unterminated string literal\")\n        \n        self._advance()  # Skip the closing quote\n        raw_value += quote\n        \n        return Token(\n            type=TokenType.STRING,\n            value=value,\n            raw_value=raw_value,\n            position=start_pos,\n            line=start_line,\n            column=start_col\n        )\n\n    def _read_comment(self) -> Token:\n        start_pos = self.position\n        start_line = self.line\n        start_col = self.column\n        \n        value = ''\n        self._advance()  # Skip the semicolon\n        \n        while self.current_char is not None and self.current_char != '\\n':\n            value += self.current_char\n            self._advance()\n        \n        return Token(\n            type=TokenType.COMMENT,\n            value=value,\n            raw_value=';' + value,\n            position=start_pos,\n            line=start_line,\n            column=start_col\n        )\n\n    def get_next_token(self) -> Token:\n        while self.current_char is not None:\n            if self.current_char.isspace():\n                self._skip_whitespace()\n                continue\n                \n            if self._is_digit(self.current_char):\n                return self._read_number()\n                \n            if self._is_alpha(self.current_char):\n                return self._read_identifier()\n                \n            if self.current_char in ('\"', \"'\"):\n                return self._read_string()\n                \n            if self.current_char == ';':\n                return self._read_comment()\n                \n            # Handle operators and punctuation\n            if self.current_char == '=':\n                self._advance()\n                return Token(\n                    type=TokenType.ASSIGN,\n                    value='=',\n                    raw_value='=',\n                    position=self.position-1,\n                    line=self.line,\n                    column=self.column-1\n                )\n                \n            # Handle other single-character tokens\n            token_type = None\n            if self.current_char == '+':\n                token_type = TokenType.PLUS\n            elif self.current_char == '-':\n                token_type = TokenType.MINUS\n            elif self.current_char == '*':\n                token_type = TokenType.MULTIPLY\n            elif self.current_char == '/':\n                token_type = TokenType.DIVIDE\n            elif self.current_char == '(':\n                token_type = TokenType.LPAREN\n            elif self.current_char == ')':\n                token_type = TokenType.RPAREN\n            elif self.current_char == '>':\n                token_type = TokenType.PUSH\n            elif self.current_char == '<':\n                token_type = TokenType.POP\n            elif self.current_char == '[':\n                token_type = TokenType.LOOP_START\n            elif self.current_char == ']':\n                token_type = TokenType.LOOP_END\n            elif self.current_char == '.':\n                token_type = TokenType.OUTPUT\n            elif self.current_char == ',':\n                token_type = TokenType.INPUT\n                \n            if token_type is not None:\n                char = self.current_char\n                self._advance()\n                return Token(\n                    type=token_type,\n                    value=char,\n                    raw_value=char,\n                    position=self.position-1,\n                    line=self.line,\n                    column=self.column-1\n                )\n                \n            self._error(f\"Unknown character: '{self.current_char}'\")\n        \n        return Token(\n            type=TokenType.EOF,\n            value='',\n            raw_value='',\n            position=self.position,\n            line=self.line,\n            column=self.column\n        )\n\ndef test_lexer():\n    \"\"\"Test the enhanced lexer\"\"\"\n    code = \"\"\"\n    // Simple variable assignments\n    x = 42\n    y = 3.14\n    name = \"HyperCode\"\n    \n    // Control flow\n    if x > 10 {\n        print(\"x is greater than 10\")\n    } else {\n        print(\"x is 10 or less\")\n    }\n    \n    // Function definition\n    func add(a, b) {\n        return a + b\n    }\n    \n    // Function call\n    result = add(5, 3.5)\n    \"\"\"\n    \n    lexer = HyperCodeLexer(code)\n    tokens = []\n    \n    while True:\n        token = lexer.get_next_token()\n        tokens.append(token)\n        if token.type == TokenType.EOF:\n            break\n    \n    print(\"Tokens:\")\n    for token in tokens:\n        print(f\"  {token}\")\n\nif __name__ == \"__main__\":\n    test_lexer()",
  "metadata": {},
  "relative_path": "src\\hypercode_lexer_fixed.py",
  "id": "7085d8da0f4fe62a17fe59908fa49349"
}