{
  "file_name": "valkey_service.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\mcp\\servers\\valkey_service.py",
  "file_size": 5484,
  "created": "2025-11-23T12:01:48.514367",
  "modified": "2025-11-23T12:01:48.514367",
  "file_type": "code",
  "content_hash": "c5df003baeb1f8233e882b928bb81e5c",
  "content_type": "text",
  "content": "# mcp/servers/valkey_service.py\n\nimport os\nimport uvicorn\nfrom fastapi import FastAPI, HTTPException\nfrom redis import Redis, ConnectionError as RedisConnectionError\nimport json\n\n# --- Configuration ---\nREDIS_HOST = os.environ.get(\"REDIS_HOST\", \"localhost\")\nREDIS_PORT = int(os.environ.get(\"REDIS_PORT\", 6379))\nSERVER_HOST = \"127.0.0.1\"\nSERVER_PORT = 8001\n\n# --- FastAPI Application ---\napp = FastAPI(\n    title=\"Valkey Service\",\n    description=\"A simple MCP server to interact with a Valkey/Redis data store.\",\n    version=\"1.0.0\",\n)\n\n# --- Redis Connection ---\ntry:\n    # The decode_responses=True argument ensures that we get strings from Redis, not bytes.\n    redis_client = Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)\n    # Check the connection\n    redis_client.ping()\n    print(f\"Successfully connected to Redis at {REDIS_HOST}:{REDIS_PORT}\")\nexcept RedisConnectionError as e:\n    print(f\"Error: Could not connect to Redis at {REDIS_HOST}:{REDIS_PORT}. Please ensure it is running.\")\n    print(f\"Details: {e}\")\n    # We don't exit here, to allow for the server to start and report the error via HTTP\n    redis_client = None\n\n# --- Middleware for Connection Check ---\n@app.middleware(\"http\")\nasync def check_redis_connection(request, call_next):\n    if redis_client is None:\n        return HTTPException(status_code=503, detail=\"Service Unavailable: Could not connect to Redis.\")\n    try:\n        redis_client.ping()\n    except RedisConnectionError:\n         return HTTPException(status_code=503, detail=\"Service Unavailable: Lost connection to Redis.\")\n    response = await call_next(request)\n    return response\n\n# --- API Endpoints ---\n\n@app.get(\"/\", summary=\"Health Check\")\nasync def health_check():\n    \"\"\"\n    Health check endpoint to verify that the service is running.\n    \"\"\"\n    return {\"status\": \"ok\", \"message\": \"Valkey Service is running.\"}\n\n@app.post(\"/set/{key}\", summary=\"Set a key-value pair\")\nasync def set_key(key: str, value: dict):\n    \"\"\"\n    Set a value for a given key. The value should be a JSON object.\n    \"\"\"\n    try:\n        # Redis can only store strings, so we serialize the JSON dict\n        redis_client.set(key, json.dumps(value))\n        return {\"status\": \"ok\", \"key\": key, \"value\": value}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/get/{key}\", summary=\"Get a value by key\")\nasync def get_key(key: str):\n    \"\"\"\n    Get the value for a given key.\n    \"\"\"\n    try:\n        value_str = redis_client.get(key)\n        if value_str is None:\n            raise HTTPException(status_code=404, detail=\"Key not found\")\n        # Deserialize the JSON string back into a dict\n        return {\"status\": \"ok\", \"key\": key, \"value\": json.loads(value_str)}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post(\"/hset/{name}/{key}\", summary=\"Set a field in a hash\")\nasync def hset_key(name: str, key: str, value: dict):\n    \"\"\"\n    Set a field (key) in a hash (name). The value should be a JSON object.\n    \"\"\"\n    try:\n        redis_client.hset(name, key, json.dumps(value))\n        return {\"status\": \"ok\", \"name\": name, \"key\": key, \"value\": value}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/hget/{name}/{key}\", summary=\"Get a field from a hash\")\nasync def hget_key(name: str, key: str):\n    \"\"\"\n    Get a field (key) from a hash (name).\n    \"\"\"\n    try:\n        value_str = redis_client.hget(name, key)\n        if value_str is None:\n            raise HTTPException(status_code=404, detail=\"Hash name or key not found\")\n        return {\"status\": \"ok\", \"name\": name, \"key\": key, \"value\": json.loads(value_str)}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/hgetall/{name}\", summary=\"Get all fields and values from a hash\")\nasync def hgetall_hash(name: str):\n    \"\"\"\n    Get all fields and values for a given hash name.\n    \"\"\"\n    try:\n        all_values = redis_client.hgetall(name)\n        if not all_values:\n            raise HTTPException(status_code=404, detail=\"Hash not found\")\n        \n        # Deserialize all values from JSON strings\n        deserialized_values = {k: json.loads(v) for k, v in all_values.items()}\n        \n        return {\"status\": \"ok\", \"name\": name, \"values\": deserialized_values}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n# --- Main entry point for running the server ---\ndef main():\n    \"\"\"\n\n    Main function to run the Valkey Service MCP Server.\n    This function is called when the script is executed directly.\n    It starts the Uvicorn server, which in turn runs the FastAPI application.\n    \"\"\"\n    print(f\"Starting Valkey Service MCP Server on http://{SERVER_HOST}:{SERVER_PORT}\")\n    print(\"Press Ctrl+C to stop.\")\n    \n    # Check if Redis is available before starting the server\n    if redis_client is None:\n        print(\"\\nFATAL: Could not connect to Redis. The server will not be able to serve requests.\")\n        print(\"Please ensure Redis/Valkey is running and accessible at the configured host and port.\")\n        # We still run the server to provide HTTP error messages, but log a fatal warning.\n    \n    uvicorn.run(app, host=SERVER_HOST, port=SERVER_PORT)\n\nif __name__ == \"__main__\":\n    main()",
  "metadata": {},
  "relative_path": "mcp\\servers\\valkey_service.py",
  "id": "64836dfacba370ef93d763a9542417c4"
}