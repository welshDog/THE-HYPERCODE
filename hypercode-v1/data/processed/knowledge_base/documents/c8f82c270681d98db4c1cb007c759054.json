{
  "file_name": "ultra_validator.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\src\\ultra_validator.py",
  "file_size": 19644,
  "created": "2025-11-23T12:01:48.282485",
  "modified": "2025-11-23T12:01:48.282485",
  "file_type": "code",
  "content_hash": "66cc3bde72643a7ac5c59d18b6b86c1c",
  "content_type": "text",
  "content": "\"\"\"\nUltra-Enhanced DuelCode Validator with advanced validation rules.\n\"\"\"\n\nimport re\nfrom dataclasses import dataclass\nfrom enum import Enum, auto\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple\n\n\nclass Severity(Enum):\n    ERROR = auto()\n    WARNING = auto()\n    INFO = auto()\n    SUGGESTION = auto()\n\n\n@dataclass\nclass ValidationResult:\n    message: str\n    severity: Severity\n    line: Optional[int] = None\n    col: Optional[int] = None\n    suggestion: Optional[str] = None\n\n\nclass DuelCodeUltraValidator:\n    \"\"\"Ultra-enhanced validator with comprehensive rules for DuelCode documentation.\"\"\"\n\n    SUPPORTED_LANGUAGES = {\n        \"python\",\n        \"javascript\",\n        \"typescript\",\n        \"java\",\n        \"c\",\n        \"cpp\",\n        \"csharp\",\n        \"go\",\n        \"rust\",\n        \"ruby\",\n        \"php\",\n        \"swift\",\n        \"kotlin\",\n        \"dart\",\n        \"html\",\n        \"css\",\n        \"sql\",\n        \"json\",\n        \"yaml\",\n        \"markdown\",\n        \"mermaid\",\n        \"hypercode\",\n        \"bash\",\n        \"text\",\n        \"ascii\",\n        \"shell\",\n        \"dockerfile\",\n        \"makefile\",\n        \"ini\",\n        \"toml\",\n        \"xml\",\n    }\n\n    # Required sections for complete tutorials\n    REQUIRED_SECTIONS = {\n        \"objective\",\n        \"checklist\",\n        \"learning objectives\",\n        \"visual representation\",\n        \"code examples\",\n        \"exercises\",\n        \"conclusion\",\n        \"what's next\",\n    }\n\n    # Recommended sections\n    RECOMMENDED_SECTIONS = {\n        \"faq\",\n        \"see also\",\n        \"glossary\",\n        \"acknowledgments\",\n        \"troubleshooting\",\n        \"resources\",\n        \"prerequisites\",\n    }\n\n    def __init__(self, file_path: str):\n        self.file_path = Path(file_path)\n        self.content = self.file_path.read_text(encoding=\"utf-8\")\n        self.lines = self.content.split(\"\\n\")\n        self.results: List[ValidationResult] = []\n        self._line_cache: Dict[str, List[Tuple[int, str]]] = {}\n\n    def _add_result(\n        self,\n        message: str,\n        severity: Severity,\n        line: Optional[int] = None,\n        suggestion: Optional[str] = None,\n    ) -> None:\n        self.results.append(\n            ValidationResult(message, severity, line, suggestion=suggestion)\n        )\n\n    def _find_lines(self, pattern: str) -> List[Tuple[int, str]]:\n        if pattern in self._line_cache:\n            return self._line_cache[pattern]\n\n        matches = []\n        for i, line in enumerate(self.lines, 1):\n            if re.search(pattern, line, re.IGNORECASE):\n                matches.append((i, line))\n\n        self._line_cache[pattern] = matches\n        return matches\n\n    def validate_code_blocks_have_language(self) -> None:\n        \"\"\"Validate all code blocks have language specifications.\"\"\"\n        # code_block_pattern = r\"^```(\\w+)?$\"  # Not used - for reference only\n        in_code_block = False\n\n        for i, line in enumerate(self.lines, 1):\n            if line.strip().startswith(\"```\"):\n                if not in_code_block:\n                    # Start of code block\n                    lang_match = re.match(r\"^```(\\w+)$\", line.strip())\n                    if not lang_match or not lang_match.group(1):\n                        self._add_result(\n                            \"Code block is missing a language specification\",\n                            Severity.ERROR,\n                            i,\n                            suggestion=(\n                                \"Add a language identifier after the opening ``` \"\n                                \"(e.g., ```python)\"\n                            ),\n                        )\n                    elif lang_match.group(1).lower() not in self.SUPPORTED_LANGUAGES:\n                        self._add_result(\n                            f\"Unsupported language '{lang_match.group(1)}'\",\n                            Severity.WARNING,\n                            i,\n                            f\"Unsupported language '{lang_match.group(1)}'. \"\n                            f\"Supported: {', '.join(sorted(self.SUPPORTED_LANGUAGES))}\",\n                        )\n                    # block_start_line = i  # Not used in this validation\n                    in_code_block = True\n                else:\n                    # End of code block\n                    in_code_block = False\n\n    def validate_has_visual_representation(self) -> None:\n        \"\"\"Check for visual elements like diagrams, charts, or ASCII art.\"\"\"\n        visual_patterns = [\n            r\"```mermaid\",\n            r\"```ascii\",\n            r\"â”Œ|â””|â”|â”˜|â”€|â”‚\",  # Box drawing characters\n            r\"â–„|â–ˆ|â–€|â–‘\",  # Block characters\n            r\"â†’|â†|â†‘|â†“\",  # Arrows\n        ]\n\n        has_visual = any(self._find_lines(pattern) for pattern in visual_patterns)\n\n        if not has_visual:\n            self._add_result(\n                \"Consider adding visual representations (diagrams, charts, ASCII art)\",\n                Severity.INFO,\n                suggestion=\"Add visual elements to improve understanding\",\n            )\n\n    def validate_has_practical_exercise(self) -> None:\n        \"\"\"Check for practical exercises or challenges.\"\"\"\n        exercise_patterns = [\n            r\"###\\s+challenge\",\n            r\"###\\s+exercise\",\n            r\"###\\s+try\\s+it\\s+yourself\",\n            r\"##\\s+exercise\",\n            r\"##\\s+practice\",\n            r\"\\*\\*challenge\\*\\*\",\n            r\"\\*\\*exercise\\*\\*\",\n        ]\n\n        has_exercise = any(self._find_lines(pattern) for pattern in exercise_patterns)\n\n        if not has_exercise:\n            self._add_result(\n                \"Consider adding practical exercises for better engagement\",\n                Severity.INFO,\n                suggestion=\"Add hands-on exercises or challenges\",\n            )\n\n    def validate_has_learning_objectives(self) -> None:\n        \"\"\"Check for learning objectives section.\"\"\"\n        objective_patterns = [\n            r\"##\\s+ðŸŽ¯\\s+learning\\s+objectives\",\n            r\"##\\s+learning\\s+objectives\",\n            r\"##\\s+objectives\",\n            r\"##\\s+what\\s+you'll\\s+learn\",\n            r\"###\\s+ðŸŽ¯\\s+learning\\s+objectives\",\n            r\"###\\s+learning\\s+objectives\",\n            r\"###\\s+objectives\",\n        ]\n\n        has_objectives = any(\n            self._find_lines(pattern) for pattern in objective_patterns\n        )\n\n        if not has_objectives:\n            self._add_result(\n                \"Consider adding learning objectives\",\n                Severity.INFO,\n                suggestion=\"Add a section outlining what readers will learn\",\n            )\n\n    def validate_has_checklist(self) -> None:\n        \"\"\"Check for checklist elements.\"\"\"\n        checklist_patterns = [\n            r\"-\\s*\\[.*?\\]\",  # Markdown checkbox\n            r\"â˜|â˜‘|â˜’\",  # Unicode checkboxes\n            r\"âœ“|âœ—\",  # Check marks\n            r\"checklist\",\n            r\"prerequisites\",\n        ]\n\n        has_checklist = any(self._find_lines(pattern) for pattern in checklist_patterns)\n\n        if not has_checklist:\n            self._add_result(\n                \"Consider adding a checklist for prerequisites or objectives\",\n                Severity.INFO,\n                suggestion=\"Add checkboxes or checklist elements\",\n            )\n\n    def validate_has_conclusion(self) -> None:\n        \"\"\"Check for conclusion section.\"\"\"\n        conclusion_patterns = [\n            r\"##\\s+ðŸŽ‰\\s+conclusion\",\n            r\"##\\s+conclusion\",\n            r\"##\\s+summary\",\n            r\"##\\s+wrap\\s+up\",\n            r\"###\\s+ðŸŽ‰\\s+conclusion\",\n            r\"###\\s+conclusion\",\n            r\"###\\s+summary\",\n        ]\n\n        has_conclusion = any(\n            self._find_lines(pattern) for pattern in conclusion_patterns\n        )\n\n        if not has_conclusion:\n            self._add_result(\n                \"Consider adding a 'Conclusion' section to summarize key points\",\n                Severity.INFO,\n                suggestion=\"Add a conclusion to reinforce learning\",\n            )\n\n    def validate_has_whats_next(self) -> None:\n        \"\"\"Check for 'What's Next' section.\"\"\"\n        next_patterns = [\n            r\"##\\s+ðŸš€\\s+what's\\s+next\",\n            r\"##\\s+what's\\s+next\",\n            r\"##\\s+next\\s+steps\",\n            r\"##\\s+continue\\s+learning\",\n            r\"###\\s+ðŸš€\\s+what's\\s+next\",\n            r\"###\\s+what's\\s+next\",\n            r\"###\\s+next\\s+steps\",\n        ]\n\n        has_next = any(self._find_lines(pattern) for pattern in next_patterns)\n\n        if not has_next:\n            self._add_result(\n                \"Consider adding a 'What's Next' section to guide readers\",\n                Severity.INFO,\n                suggestion=\"Add next steps for continued learning\",\n            )\n\n    def validate_code_quality(self) -> None:\n        \"\"\"Validate code block quality and best practices.\"\"\"\n        in_code_block = False\n        current_lang = None\n        block_start_line = None\n        current_block_lines: List[Tuple[int, str]] = []\n\n        for i, line in enumerate(self.lines, 1):\n            if line.strip().startswith(\"```\"):\n                if not in_code_block:\n                    # Start of code block\n                    lang_match = re.match(r\"^```(\\w+)$\", line.strip())\n                    current_lang = lang_match.group(1).lower() if lang_match else None\n                    # block_start_line = i  # Not used in this validation\n                    in_code_block = True\n                    current_block_lines = []\n                else:\n                    # End of code block - validate\n                    if current_lang and current_block_lines:\n                        self._validate_code_block_content(\n                            current_block_lines, current_lang, block_start_line or 0\n                        )\n                    in_code_block = False\n                    current_lang = None\n            elif in_code_block:\n                current_block_lines.append((i, line))\n\n    def _validate_code_block_content(\n        self, block_lines: List[Tuple[int, str]], lang: str, start_line: int\n    ) -> None:\n        \"\"\"Validate specific code block content based on language.\"\"\"\n        content = \"\\n\".join(line for _, line in block_lines)\n\n        # Language-specific validations\n        if lang == \"python\":\n            # Check for common Python patterns\n            if \"print(\" in content and not re.search(r'print\\s*\\(\\s*[\"\\']', content):\n                self._add_result(\n                    \"Consider using f-strings or formatted output\",\n                    Severity.SUGGESTION,\n                    start_line,\n                    suggestion=\"Use f-strings for better readability: \"\n                    \"print(f'Value: {variable}')\",\n                )\n\n        elif lang == \"hypercode\" and content.count(\".\") > content.count(\"+\"):\n            self._add_result(\n                \"More output commands than increments - possible logic error\",\n                Severity.WARNING,\n                start_line,\n                suggestion=\"Ensure memory cells are properly initialized before output\",\n            )\n\n        # General code quality checks\n        if len(content.split(\"\\n\")) > 20:\n            self._add_result(\n                \"Large code block - consider breaking into smaller examples\",\n                Severity.SUGGESTION,\n                start_line,\n                suggestion=\"Split complex code into multiple smaller examples\",\n            )\n\n    def validate_has_glossary(self) -> None:\n        \"\"\"Check for glossary section.\"\"\"\n        glossary_patterns = [\n            r\"##\\s+ðŸŽ“\\s+glossary\",\n            r\"##\\s+glossary\",\n            r\"##\\s+terminology\",\n            r\"###\\s+ðŸŽ“\\s+glossary\",\n            r\"###\\s+glossary\",\n            r\"###\\s+terminology\",\n        ]\n\n        has_glossary = any(self._find_lines(pattern) for pattern in glossary_patterns)\n\n        if not has_glossary:\n            self._add_result(\n                \"Consider adding a glossary for technical terms\",\n                Severity.INFO,\n                suggestion=\"Define key terms in a glossary section\",\n            )\n\n    def validate_has_see_also(self) -> None:\n        \"\"\"Check for 'See Also' section.\"\"\"\n        see_also_patterns = [\n            r\"##\\s+ðŸ“š\\s+see\\s+also\",\n            r\"##\\s+see\\s+also\",\n            r\"##\\s+related\\s+resources\",\n            r\"##\\s+further\\s+reading\",\n            r\"###\\s+ðŸ“š\\s+see\\s+also\",\n            r\"###\\s+see\\s+also\",\n        ]\n\n        has_see_also = any(self._find_lines(pattern) for pattern in see_also_patterns)\n\n        if not has_see_also:\n            self._add_result(\n                \"Consider adding a 'See Also' section with links to related resources\",\n                Severity.INFO,\n                suggestion=\"Add references to related tutorials or documentation\",\n            )\n\n    def validate_has_faq(self) -> None:\n        \"\"\"Check for FAQ section.\"\"\"\n        faq_patterns = [\n            r\"##\\s+â“\\s+faq\",\n            r\"##\\s+faq\",\n            r\"##\\s+frequently\\s+asked\\s+questions\",\n            r\"###\\s+â“\\s+faq\",\n            r\"###\\s+faq\",\n            r\"\\?\\s+\",  # Question patterns\n        ]\n\n        has_faq = any(self._find_lines(pattern) for pattern in faq_patterns)\n\n        # Also check for question marks in headings\n        question_headings = self._find_lines(r\"\\?\\s*$\")\n        if not has_faq and not question_headings:\n            self._add_result(\n                \"Document contains questions. Consider adding an FAQ section\",\n                Severity.INFO,\n                suggestion=\"Add FAQ for common questions\",\n            )\n\n    def validate_has_acknowledgments(self) -> None:\n        \"\"\"Check for acknowledgments section.\"\"\"\n        ack_patterns = [\n            r\"##\\s+ðŸ™\\s+acknowledgments?\",\n            r\"##\\s+acknowledgments?\",\n            r\"##\\s+credits?\",\n            r\"##\\s+thanks?\",\n            r\"###\\s+ðŸ™\\s+acknowledgments?\",\n            r\"###\\s+acknowledgments?\",\n        ]\n\n        has_ack = any(self._find_lines(pattern) for pattern in ack_patterns)\n\n        if not has_ack:\n            self._add_result(\n                \"Consider adding an Acknowledgments section to credit contributors\",\n                Severity.INFO,\n                suggestion=\"Acknowledge contributors and references\",\n            )\n\n    def validate_accessibility(self) -> None:\n        \"\"\"Check for accessibility features.\"\"\"\n        # Check for alt text in images\n        img_patterns = self._find_lines(r\"!\\[.*?\\]\\(.*?\\)\")\n        for line_no, line in img_patterns:\n            if not re.match(r\"!\\[.*?\\].*?\\(.*?\\)\", line) or line.startswith(\"![](\"):\n                self._add_result(\n                    \"Image missing alt text\",\n                    Severity.WARNING,\n                    line_no,\n                    suggestion=\"Add descriptive alt text for accessibility\",\n                )\n\n        # Check for color-blind friendly indicators\n        if \"red\" in self.content.lower() or \"green\" in self.content.lower():\n            self._add_result(\n                \"Consider using patterns/shapes instead of just colors for indicators\",\n                Severity.SUGGESTION,\n                suggestion=\"Use icons or patterns in addition to colors\",\n            )\n\n    def validate_interactive_elements(self) -> None:\n        \"\"\"Check for interactive elements.\"\"\"\n        interactive_patterns = [\n            r\"<details>\",\n            r\"<summary>\",\n            r\"```{.*,.*}\",  # Jupyter notebook cells\n            r\"\\[.*\\]\\(#.*\\)\",  # Internal links\n        ]\n\n        has_interactive = any(\n            self._find_lines(pattern) for pattern in interactive_patterns\n        )\n\n        if not has_interactive:\n            self._add_result(\n                \"Consider adding interactive elements (collapsible sections, links)\",\n                Severity.SUGGESTION,\n                suggestion=\"Add interactive elements to improve engagement\",\n            )\n\n    def validate_all(self) -> List[ValidationResult]:\n        \"\"\"Run all validations and return results.\"\"\"\n        self.results = []\n\n        # Core validations\n        self.validate_code_blocks_have_language()\n        self.validate_has_visual_representation()\n        self.validate_has_practical_exercise()\n        self.validate_has_learning_objectives()\n        self.validate_has_checklist()\n        self.validate_has_conclusion()\n        self.validate_has_whats_next()\n        self.validate_code_quality()\n\n        # Enhanced validations\n        self.validate_has_glossary()\n        self.validate_has_see_also()\n        self.validate_has_faq()\n        self.validate_has_acknowledgments()\n        self.validate_accessibility()\n        self.validate_interactive_elements()\n\n        return self.results\n\n    def print_results(self) -> None:\n        \"\"\"Print validation results in a formatted way.\"\"\"\n        if not self.results:\n            print(\"âœ… All validations passed!\")\n            return\n\n        # Group by severity\n        by_severity: Dict[Severity, List[ValidationResult]] = {}\n        for result in self.results:\n            if result.severity not in by_severity:\n                by_severity[result.severity] = []\n            by_severity[result.severity].append(result)\n\n        # Print in order of severity\n        severity_order = [\n            Severity.ERROR,\n            Severity.WARNING,\n            Severity.INFO,\n            Severity.SUGGESTION,\n        ]\n        severity_names = {\n            Severity.ERROR: \"ERRORS\",\n            Severity.WARNING: \"WARNINGS\",\n            Severity.INFO: \"INFOS\",\n            Severity.SUGGESTION: \"SUGGESTIONS\",\n        }\n\n        for severity in severity_order:\n            if severity in by_severity:\n                print(f\"\\n{severity_names[severity]} ({len(by_severity[severity])}):\")\n                print(\"=\" * (len(severity_names[severity]) + 5))\n                for result in by_severity[severity]:\n                    location = f\" (at line {result.line})\" if result.line else \"\"\n                    print(f\"â€¢ {result.message}{location}\")\n                    if result.suggestion:\n                        print(f\"  ðŸ’¡ {result.suggestion}\")\n\n        # Summary\n        total_issues = len(self.results)\n        errors = len(by_severity.get(Severity.ERROR, []))\n        warnings = len(by_severity.get(Severity.WARNING, []))\n\n        if errors > 0:\n            print(f\"\\nâŒ Validation failed with {errors} error(s)\")\n        elif warnings > 0:\n            print(f\"\\nâš ï¸  Validation passed with {warnings} warning(s)\")\n        else:\n            print(f\"\\nâœ… Validation passed with {total_issues} info/suggestion(s)\")\n\n\ndef main() -> None:\n    import sys\n\n    if len(sys.argv) != 2:\n        print(\"Usage: python ultra_validator.py <markdown_file>\")\n        sys.exit(1)\n\n    file_path = sys.argv[1]\n    validator = DuelCodeUltraValidator(file_path)\n    results = validator.validate_all()\n    validator.print_results()\n\n    # Exit with error code if there are errors\n    errors = sum(1 for r in results if r.severity == Severity.ERROR)\n    sys.exit(1 if errors > 0 else 0)\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "metadata": {},
  "relative_path": "src\\ultra_validator.py",
  "id": "c8f82c270681d98db4c1cb007c759054"
}