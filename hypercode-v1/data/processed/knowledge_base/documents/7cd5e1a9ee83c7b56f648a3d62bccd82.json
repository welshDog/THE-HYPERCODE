{
  "file_name": "app.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\live_research\\web\\app.py",
  "file_size": 7704,
  "created": "2025-12-04T12:45:36.646967",
  "modified": "2025-12-04T14:09:16.059633",
  "file_type": "code",
  "content_hash": "29564b577257030c195962e3a5e984dc",
  "content_type": "text",
  "content": "\"\"\"\nFlask web application for browsing research data.\n\"\"\"\n\nimport os\nfrom flask import Flask, render_template, request, redirect, url_for, flash, jsonify\nfrom pathlib import Path\nimport sqlite3\nfrom datetime import datetime\nfrom typing import Dict, List, Any, Optional, Union, Tuple\nfrom flask import (\n    Flask,\n    render_template,\n    request,\n    redirect,\n    url_for,\n    flash,\n    jsonify,\n    Response,\n)\n\n# Initialize Flask app\napp = Flask(__name__)\napp.secret_key = os.environ.get(\"SECRET_KEY\", \"dev-key-for-research-app\")\n\n# Configuration\nBASE_DIR = Path(__file__).parent.parent.parent\nDATA_DIR = BASE_DIR / \"data\"\nDB_PATH = DATA_DIR / \"research.db\"\n\n# Ensure data directory exists\nDATA_DIR.mkdir(parents=True, exist_ok=True)\n\n\ndef get_db_connection() -> sqlite3.Connection:\n    \"\"\"Create and return a database connection.\"\"\"\n    conn = sqlite3.connect(DB_PATH)\n    conn.row_factory = sqlite3.Row\n    return conn\n\n\n@app.route(\"/\")\ndef index() -> str:\n    \"\"\"Home page showing recent research entries.\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n\n    cursor.execute(\"\"\"\n    SELECT re.*, GROUP_CONCAT(t.name, ', ') as tag_list\n    FROM research_entries re\n    LEFT JOIN research_entry_tags ret ON re.id = ret.entry_id\n    LEFT JOIN tags t ON ret.tag_id = t.id\n    GROUP BY re.id\n    ORDER BY re.date DESC, re.updated_at DESC\n    LIMIT 10\n    \"\"\")\n\n    entries = [dict(row) for row in cursor.fetchall()]\n\n    # Convert tag strings to lists\n    for entry in entries:\n        if entry[\"tag_list\"]:\n            entry[\"tags\"] = [\n                tag.strip() for tag in entry[\"tag_list\"].split(\",\") if tag.strip()\n            ]\n        else:\n            entry[\"tags\"] = []\n        del entry[\"tag_list\"]\n\n    # Get all unique tags for the sidebar\n    cursor.execute(\"SELECT DISTINCT name FROM tags ORDER BY name\")\n    all_tags = [row[0] for row in cursor.fetchall()]\n\n    conn.close()\n    return render_template(\"index.html\", entries=entries, all_tags=all_tags)\n\n\n@app.route(\"/entry/<entry_id>\")\ndef view_entry(entry_id: str) -> str:\n    \"\"\"View a specific research entry.\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n\n    cursor.execute(\n        \"\"\"\n    SELECT re.*, GROUP_CONCAT(t.name, ', ') as tag_list\n    FROM research_entries re\n    LEFT JOIN research_entry_tags ret ON re.id = ret.entry_id\n    LEFT JOIN tags t ON ret.tag_id = t.id\n    WHERE re.id = ?\n    GROUP BY re.id\n    \"\"\",\n        (entry_id,),\n    )\n\n    entry = cursor.fetchone()\n\n    if not entry:\n        flash(\"Entry not found\", \"error\")\n        return redirect(url_for(\"index\"))\n\n    # Convert to dict and process tags\n    entry = dict(entry)\n    if entry[\"tag_list\"]:\n        entry[\"tags\"] = [\n            tag.strip() for tag in entry[\"tag_list\"].split(\",\") if tag.strip()\n        ]\n    else:\n        entry[\"tags\"] = []\n    del entry[\"tag_list\"]\n\n    # Get all unique tags for the sidebar\n    cursor.execute(\"SELECT DISTINCT name FROM tags ORDER BY name\")\n    all_tags = [row[0] for row in cursor.fetchall()]\n\n    conn.close()\n    return render_template(\"entry.html\", entry=entry, all_tags=all_tags)\n\n\n@app.route(\"/search\")\ndef search() -> str:\n    \"\"\"Search for research entries.\"\"\"\n    query = request.args.get(\"q\", \"\").strip()\n    tag = request.args.get(\"tag\", \"\").strip()\n\n    if not query and not tag:\n        return redirect(url_for(\"index\"))\n\n    conn = get_db_connection()\n    cursor = conn.cursor()\n\n    # Build the query\n    sql = \"\"\"\n    SELECT DISTINCT re.*, GROUP_CONCAT(t.name, ', ') as tag_list\n    FROM research_entries re\n    LEFT JOIN research_entry_tags ret ON re.id = ret.entry_id\n    LEFT JOIN tags t ON ret.tag_id = t.id\n    \"\"\"\n\n    params = []\n    conditions = []\n\n    if query:\n        conditions.append(\"\"\"\n        (re.topic LIKE ? OR re.summary LIKE ? OR re.details LIKE ?)\n        \"\"\")\n        search_term = f\"%{query}%\"\n        params.extend([search_term, search_term, search_term])\n\n    if tag:\n        conditions.append(\"\"\"\n        re.id IN (\n            SELECT ret.entry_id FROM research_entry_tags ret\n            JOIN tags t ON ret.tag_id = t.id\n            WHERE t.name = ?\n        )\n        \"\"\")\n        params.append(tag)\n\n    if conditions:\n        sql += \" WHERE \" + \" AND \".join(conditions)\n\n    sql += \" GROUP BY re.id ORDER BY re.date DESC, re.updated_at DESC\"\n\n    cursor.execute(sql, params)\n    entries = [dict(row) for row in cursor.fetchall()]\n\n    # Convert tag strings to lists\n    for entry in entries:\n        if entry[\"tag_list\"]:\n            entry[\"tags\"] = [\n                tag.strip() for tag in entry[\"tag_list\"].split(\",\") if tag.strip()\n            ]\n        else:\n            entry[\"tags\"] = []\n        del entry[\"tag_list\"]\n\n    # Get all unique tags for the sidebar\n    cursor.execute(\"SELECT DISTINCT name FROM tags ORDER BY name\")\n    all_tags = [row[0] for row in cursor.fetchall()]\n\n    conn.close()\n\n    return render_template(\n        \"search.html\",\n        entries=entries,\n        all_tags=all_tags,\n        search_query=query,\n        selected_tag=tag,\n    )\n\n\n@app.route(\"/tags\")\ndef list_tags() -> str:\n    \"\"\"List all tags with counts.\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n\n    # Get tags with counts\n    cursor.execute(\"\"\"\n    SELECT t.name, COUNT(ret.entry_id) as count\n    FROM tags t\n    LEFT JOIN research_entry_tags ret ON t.id = ret.tag_id\n    GROUP BY t.name\n    ORDER BY count DESC, t.name\n    \"\"\")\n\n    tags = [{\"name\": row[0], \"count\": row[1]} for row in cursor.fetchall()]\n\n    # Get all unique tags for the sidebar\n    cursor.execute(\"SELECT DISTINCT name FROM tags ORDER BY name\")\n    all_tags = [row[0] for row in cursor.fetchall()]\n\n    conn.close()\n    return render_template(\"tags.html\", tags=tags, all_tags=all_tags)\n\n\n@app.route(\"/api/entries\")\ndef api_entries() -> jsonify:\n    \"\"\"API endpoint to get all entries in JSON format.\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n\n    cursor.execute(\"\"\"\n    SELECT re.*, GROUP_CONCAT(t.name, ',') as tags\n    FROM research_entries re\n    LEFT JOIN research_entry_tags ret ON re.id = ret.entry_id\n    LEFT JOIN tags t ON ret.tag_id = t.id\n    GROUP BY re.id\n    ORDER BY re.date DESC, re.updated_at DESC\n    \"\"\")\n\n    entries = []\n    for row in cursor.fetchall():\n        entry = dict(row)\n        entry[\"tags\"] = (\n            [tag for tag in entry[\"tags\"].split(\",\") if tag] if entry[\"tags\"] else []\n        )\n        entries.append(entry)\n\n    conn.close()\n    return jsonify(entries)\n\n\n@app.errorhandler(404)\ndef page_not_found(e: Exception) -> tuple[str, int]:\n    \"\"\"Handle 404 errors.\"\"\"\n    return render_template(\"404.html\"), 404\n\n\n@app.errorhandler(500)\ndef server_error(e: Exception) -> tuple[str, int]:\n    \"\"\"Handle 500 errors.\"\"\"\n    return render_template(\"500.html\"), 500\n\n\n@app.template_filter(\"format_date\")\ndef format_date_filter(date_str: str, format: str = \"%B %d, %Y\") -> str:\n    \"\"\"Format a date string.\"\"\"\n    if not date_str:\n        return \"\"\n    try:\n        date_obj = datetime.strptime(date_str, \"%Y-%m-%d\")\n        return date_obj.strftime(format)\n    except (ValueError, TypeError):\n        return date_str\n\n\nif __name__ == \"__main__\":\n    # Create necessary directories\n    templates_dir = Path(__file__).parent / \"templates\"\n    templates_dir.mkdir(exist_ok=True)\n\n    static_dir = Path(__file__).parent / \"static\"\n    static_dir.mkdir(exist_ok=True)\n\n    # Run the app\n    app.run(debug=True, port=5000)\n",
  "metadata": {},
  "relative_path": "live_research\\web\\app.py",
  "id": "7cd5e1a9ee83c7b56f648a3d62bccd82"
}