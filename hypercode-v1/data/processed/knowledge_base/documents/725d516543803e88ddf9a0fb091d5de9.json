{
  "file_name": "style_guide_collector.py",
  "file_path": "C:\\Users\\lyndz\\Downloads\\hypercode PROJECT\\hypercode\\scripts\\style_guide_collector.py",
  "file_size": 20965,
  "created": "2025-11-23T12:01:48.529128",
  "modified": "2025-11-23T12:01:48.529128",
  "file_type": "code",
  "content_hash": "bb0ea1cb00ca5dec8d99cdd1dcbba1f2",
  "content_type": "text",
  "content": "#!/usr/bin/env python3\n\"\"\"\nğŸ¨ HyperCode Style Guide Feedback Collector\n\nThis script collects and analyzes feedback from the community to help shape\nHyperCode's official style guide, with a focus on neurodivergent accessibility.\n\"\"\"\n\nimport json\nimport os\nimport sys\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, List, Any\nimport argparse\n\nclass StyleGuideCollector:\n    \"\"\"ğŸ¨ Collects and analyzes style guide feedback from the community\"\"\"\n    \n    def __init__(self, repo_path: str = \".\"):\n        self.repo_path = Path(repo_path)\n        self.feedback_file = self.repo_path / \"data\" / \"style_feedback.json\"\n        self.analysis_file = self.repo_path / \"data\" / \"style_analysis.json\"\n        \n        # ğŸ“Š Ensure data directory exists\n        self.feedback_file.parent.mkdir(exist_ok=True)\n        \n        # ğŸ§  Initialize feedback storage\n        self.feedback_data = self._load_feedback()\n    \n    def _load_feedback(self) -> Dict[str, Any]:\n        \"\"\"ğŸ“‚ Load existing feedback data\"\"\"\n        if self.feedback_file.exists():\n            with open(self.feedback_file, 'r', encoding='utf-8') as f:\n                return json.load(f)\n        else:\n            return {\n                \"version\": \"1.0.0\",\n                \"created_at\": datetime.now().isoformat(),\n                \"feedback_entries\": [],\n                \"analysis\": {\n                    \"total_entries\": 0,\n                    \"common_patterns\": {},\n                    \"accessibility_insights\": {},\n                    \"naming_preferences\": {},\n                    \"formatting_preferences\": {}\n                }\n            }\n    \n    def _save_feedback(self):\n        \"\"\"ğŸ’¾ Save feedback data\"\"\"\n        self.feedback_data[\"updated_at\"] = datetime.now().isoformat()\n        \n        with open(self.feedback_file, 'w', encoding='utf-8') as f:\n            json.dump(self.feedback_data, f, indent=2, ensure_ascii=False)\n        \n        print(f\"âœ… Feedback saved to {self.feedback_file}\")\n    \n    def add_feedback(self, feedback: Dict[str, Any]) -> bool:\n        \"\"\"\n        ğŸ“ Add new feedback entry\n        \n        Args:\n            feedback: Dictionary containing feedback data\n            \n        Returns:\n            bool: True if feedback was added successfully\n        \"\"\"\n        try:\n            # ğŸ§  Validate required fields\n            required_fields = [\"feedback_type\", \"examples\", \"user_experience\"]\n            for field in required_fields:\n                if field not in feedback:\n                    print(f\"âŒ Missing required field: {field}\")\n                    return False\n            \n            # ğŸ“Š Create feedback entry\n            entry = {\n                \"id\": len(self.feedback_data[\"feedback_entries\"]) + 1,\n                \"timestamp\": datetime.now().isoformat(),\n                \"feedback\": feedback,\n                \"processed\": False\n            }\n            \n            # â• Add to feedback list\n            self.feedback_data[\"feedback_entries\"].append(entry)\n            \n            # ğŸ”„ Update analysis\n            self._update_analysis(entry)\n            \n            # ğŸ’¾ Save changes\n            self._save_feedback()\n            \n            print(f\"âœ… Feedback entry #{entry['id']} added successfully\")\n            return True\n            \n        except Exception as e:\n            print(f\"âŒ Error adding feedback: {e}\")\n            return False\n    \n    def _update_analysis(self, entry: Dict[str, Any]):\n        \"\"\"\n        ğŸ“Š Update analysis based on new feedback\n        \n        Args:\n            entry: New feedback entry\n        \"\"\"\n        feedback = entry[\"feedback\"]\n        analysis = self.feedback_data[\"analysis\"]\n        \n        # ğŸ“ˆ Update total count\n        analysis[\"total_entries\"] += 1\n        \n        # ğŸ¯ Track common patterns\n        if \"patterns\" in feedback:\n            for pattern in feedback[\"patterns\"]:\n                if pattern not in analysis[\"common_patterns\"]:\n                    analysis[\"common_patterns\"][pattern] = 0\n                analysis[\"common_patterns\"][pattern] += 1\n        \n        # ğŸ§  Track accessibility insights\n        if \"accessibility_needs\" in feedback:\n            for need in feedback[\"accessibility_needs\"]:\n                if need not in analysis[\"accessibility_insights\"]:\n                    analysis[\"accessibility_insights\"][need] = 0\n                analysis[\"accessibility_insights\"][need] += 1\n        \n        # ğŸ·ï¸ Track naming preferences\n        if \"naming_preferences\" in feedback:\n            for pref_type, preferences in feedback[\"naming_preferences\"].items():\n                if pref_type not in analysis[\"naming_preferences\"]:\n                    analysis[\"naming_preferences\"][pref_type] = {}\n                \n                for pref in preferences:\n                    if pref not in analysis[\"naming_preferences\"][pref_type]:\n                        analysis[\"naming_preferences\"][pref_type][pref] = 0\n                    analysis[\"naming_preferences\"][pref_type][pref] += 1\n        \n        # ğŸ“ Track formatting preferences\n        if \"formatting_preferences\" in feedback:\n            for fmt_type, preferences in feedback[\"formatting_preferences\"].items():\n                if fmt_type not in analysis[\"formatting_preferences\"]:\n                    analysis[\"formatting_preferences\"][fmt_type] = {}\n                \n                for pref in preferences:\n                    if pref not in analysis[\"formatting_preferences\"][fmt_type]:\n                        analysis[\"formatting_preferences\"][fmt_type][pref] = 0\n                    analysis[\"formatting_preferences\"][fmt_type][pref] += 1\n    \n    def analyze_feedback(self) -> Dict[str, Any]:\n        \"\"\"\n        ğŸ“Š Generate comprehensive analysis of all feedback\n        \n        Returns:\n            Dict containing analysis results\n        \"\"\"\n        analysis = {\n            \"summary\": {\n                \"total_entries\": len(self.feedback_data[\"feedback_entries\"]),\n                \"processed_entries\": sum(1 for e in self.feedback_data[\"feedback_entries\"] if e[\"processed\"]),\n                \"last_updated\": self.feedback_data.get(\"updated_at\", datetime.now().isoformat())\n            },\n            \"top_patterns\": self._get_top_items(self.feedback_data[\"analysis\"][\"common_patterns\"], 10),\n            \"top_accessibility_needs\": self._get_top_items(self.feedback_data[\"analysis\"][\"accessibility_insights\"], 10),\n            \"naming_consensus\": self._calculate_consensus(self.feedback_data[\"analysis\"][\"naming_preferences\"]),\n            \"formatting_consensus\": self._calculate_consensus(self.feedback_data[\"analysis\"][\"formatting_preferences\"]),\n            \"recommendations\": self._generate_recommendations()\n        }\n        \n        # ğŸ’¾ Save analysis\n        with open(self.analysis_file, 'w', encoding='utf-8') as f:\n            json.dump(analysis, f, indent=2, ensure_ascii=False)\n        \n        return analysis\n    \n    def _get_top_items(self, items: Dict[str, int], limit: int) -> List[Dict[str, Any]]:\n        \"\"\"\n        ğŸ“Š Get top items from a frequency dictionary\n        \n        Args:\n            items: Dictionary of item frequencies\n            limit: Maximum number of items to return\n            \n        Returns:\n            List of top items with counts and percentages\n        \"\"\"\n        total = sum(items.values())\n        sorted_items = sorted(items.items(), key=lambda x: x[1], reverse=True)\n        \n        result = []\n        for item, count in sorted_items[:limit]:\n            percentage = (count / total * 100) if total > 0 else 0\n            result.append({\n                \"item\": item,\n                \"count\": count,\n                \"percentage\": round(percentage, 1)\n            })\n        \n        return result\n    \n    def _calculate_consensus(self, preference_data: Dict[str, Dict[str, int]]) -> Dict[str, Any]:\n        \"\"\"\n        ğŸ“Š Calculate consensus for preference categories\n        \n        Args:\n            preference_data: Nested dictionary of preferences\n            \n        Returns:\n            Dictionary with consensus analysis\n        \"\"\"\n        consensus = {}\n        \n        for category, preferences in preference_data.items():\n            if not preferences:\n                continue\n            \n            total_votes = sum(preferences.values())\n            top_choice = max(preferences.items(), key=lambda x: x[1])\n            \n            consensus[category] = {\n                \"top_choice\": top_choice[0],\n                \"top_votes\": top_choice[1],\n                \"total_votes\": total_votes,\n                \"consensus_percentage\": round((top_choice[1] / total_votes * 100), 1) if total_votes > 0 else 0,\n                \"all_options\": preferences\n            }\n        \n        return consensus\n    \n    def _generate_recommendations(self) -> List[Dict[str, Any]]:\n        \"\"\"\n        ğŸ’¡ Generate style guide recommendations based on feedback\n        \n        Returns:\n            List of recommendations with rationale\n        \"\"\"\n        recommendations = []\n        analysis = self.feedback_data[\"analysis\"]\n        \n        # ğŸ§  Accessibility recommendations\n        if analysis[\"accessibility_insights\"]:\n            top_needs = self._get_top_items(analysis[\"accessibility_insights\"], 5)\n            for need in top_needs:\n                if need[\"percentage\"] >= 60:  # Strong consensus\n                    recommendations.append({\n                        \"category\": \"accessibility\",\n                        \"recommendation\": f\"Prioritize {need['item']} in style guide\",\n                        \"rationale\": f\"{need['percentage']}% of users identified this as important\",\n                        \"priority\": \"high\" if need[\"percentage\"] >= 80 else \"medium\"\n                    })\n        \n        # ğŸ·ï¸ Naming convention recommendations\n        if analysis[\"naming_preferences\"]:\n            for category, consensus in self._calculate_consensus(analysis[\"naming_preferences\"]).items():\n                if consensus[\"consensus_percentage\"] >= 70:\n                    recommendations.append({\n                        \"category\": \"naming\",\n                        \"recommendation\": f\"Use {consensus['top_choice']} for {category}\",\n                        \"rationale\": f\"{consensus['consensus_percentage']}% consensus\",\n                        \"priority\": \"high\" if consensus[\"consensus_percentage\"] >= 85 else \"medium\"\n                    })\n        \n        # ğŸ“ Formatting recommendations\n        if analysis[\"formatting_preferences\"]:\n            for category, consensus in self._calculate_consensus(analysis[\"formatting_preferences\"]).items():\n                if consensus[\"consensus_percentage\"] >= 70:\n                    recommendations.append({\n                        \"category\": \"formatting\",\n                        \"recommendation\": f\"Use {consensus['top_choice']} for {category}\",\n                        \"rationale\": f\"{consensus['consensus_percentage']}% consensus\",\n                        \"priority\": \"high\" if consensus[\"consensus_percentage\"] >= 85 else \"medium\"\n                    })\n        \n        # ğŸ¯ Pattern recommendations\n        if analysis[\"common_patterns\"]:\n            top_patterns = self._get_top_items(analysis[\"common_patterns\"], 3)\n            for pattern in top_patterns:\n                if pattern[\"percentage\"] >= 50:\n                    recommendations.append({\n                        \"category\": \"patterns\",\n                        \"recommendation\": f\"Standardize {pattern['item']} pattern\",\n                        \"rationale\": f\"{pattern['percentage']}% of users mentioned this pattern\",\n                        \"priority\": \"medium\"\n                    })\n        \n        return sorted(recommendations, key=lambda x: (x[\"priority\"] == \"high\", x[\"priority\"] == \"medium\"), reverse=True)\n    \n    def import_github_issues(self, github_token: str = None) -> int:\n        \"\"\"\n        ğŸ“¥ Import feedback from GitHub issues\n        \n        Args:\n            github_token: GitHub API token (optional)\n            \n        Returns:\n            Number of issues imported\n        \"\"\"\n        try:\n            # ğŸ™ This would integrate with GitHub API\n            # For now, return placeholder\n            print(\"ğŸ”§ GitHub integration not yet implemented\")\n            print(\"ğŸ“ Please manually create issues using the style_feedback.md template\")\n            return 0\n            \n        except Exception as e:\n            print(f\"âŒ Error importing GitHub issues: {e}\")\n            return 0\n    \n    def generate_report(self, output_file: str = None) -> str:\n        \"\"\"\n        ğŸ“Š Generate comprehensive feedback report\n        \n        Args:\n            output_file: Optional file to save report\n            \n        Returns:\n            Report content as string\n        \"\"\"\n        analysis = self.analyze_feedback()\n        \n        # ğŸ“ Generate report\n        report = f\"\"\"# ğŸ¨ HyperCode Style Guide Feedback Report\n\n**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n**Total Feedback Entries:** {analysis['summary']['total_entries']}\n\n## ğŸ“Š Summary\n\n- **Total Entries:** {analysis['summary']['total_entries']}\n- **Processed Entries:** {analysis['summary']['processed_entries']}\n- **Last Updated:** {analysis['summary']['last_updated']}\n\n## ğŸ§  Top Accessibility Needs\n\n\"\"\"\n        \n        for need in analysis['top_accessibility_needs'][:5]:\n            report += f\"- **{need['item']}**: {need['count']} mentions ({need['percentage']}%)\\n\"\n        \n        report += \"\\n## ğŸ·ï¸ Naming Convention Consensus\\n\\n\"\n        \n        for category, consensus in analysis['naming_consensus'].items():\n            report += f\"### {category.replace('_', ' ').title()}\\n\"\n            report += f\"- **Recommended:** {consensus['top_choice']}\\n\"\n            report += f\"- **Consensus:** {consensus['consensus_percentage']}%\\n\\n\"\n        \n        report += \"## ğŸ“ Formatting Consensus\\n\\n\"\n        \n        for category, consensus in analysis['formatting_consensus'].items():\n            report += f\"### {category.replace('_', ' ').title()}\\n\"\n            report += f\"- **Recommended:** {consensus['top_choice']}\\n\"\n            report += f\"- **Consensus:** {consensus['consensus_percentage']}%\\n\\n\"\n        \n        report += \"## ğŸ’¡ Recommendations\\n\\n\"\n        \n        for i, rec in enumerate(analysis['recommendations'], 1):\n            priority_emoji = \"ğŸ”´\" if rec['priority'] == 'high' else \"ğŸŸ¡\" if rec['priority'] == 'medium' else \"ğŸŸ¢\"\n            report += f\"{i}. {priority_emoji} **{rec['recommendation']}**\\n\"\n            report += f\"   - *Rationale:* {rec['rationale']}\\n\"\n            report += f\"   - *Priority:* {rec['priority']}\\n\\n\"\n        \n        # ğŸ’¾ Save report if requested\n        if output_file:\n            with open(output_file, 'w', encoding='utf-8') as f:\n                f.write(report)\n            print(f\"ğŸ“Š Report saved to {output_file}\")\n        \n        return report\n    \n    def interactive_feedback(self):\n        \"\"\"\n        ğŸ¯ Interactive feedback collection from command line\n        \"\"\"\n        print(\"ğŸ¨ HyperCode Style Guide Feedback Collector\")\n        print(\"=\" * 50)\n        print(\"ğŸ§  Help us create a better style guide for neurodivergent developers!\")\n        print()\n        \n        feedback = {}\n        \n        # ğŸ“‹ Feedback Type\n        print(\"ğŸ“‹ What type of feedback are you providing?\")\n        print(\"1. ğŸ§  Neurodivergent Accessibility\")\n        print(\"2. ğŸ“ Code Formatting\")\n        print(\"3. ğŸ·ï¸ Naming Conventions\")\n        print(\"4. ğŸ¯ Structure Patterns\")\n        print(\"5. ğŸ’¬ Comment Style\")\n        print(\"6. ğŸ”¤ Syntax Usage\")\n        print(\"7. ğŸ“Š Error Handling\")\n        print(\"8. ğŸ§ª Testing Style\")\n        \n        choice = input(\"\\nEnter your choice (1-8): \").strip()\n        feedback_types = {\n            \"1\": \"neurodivergent_accessibility\",\n            \"2\": \"code_formatting\", \n            \"3\": \"naming_conventions\",\n            \"4\": \"structure_patterns\",\n            \"5\": \"comment_style\",\n            \"6\": \"syntax_usage\",\n            \"7\": \"error_handling\",\n            \"8\": \"testing_style\"\n        }\n        \n        feedback[\"feedback_type\"] = feedback_types.get(choice, \"other\")\n        \n        # ğŸ“ Examples\n        print(\"\\nğŸ“ Share specific examples (good and bad):\")\n        print(\"âœ… What works well (leave empty if none):\")\n        good_example = input(\"> \").strip()\n        \n        print(\"âŒ What could be improved (leave empty if none):\")\n        bad_example = input(\"> \").strip()\n        \n        print(\"ğŸ’¡ Your suggestions (leave empty if none):\")\n        suggestions = input(\"> \").strip()\n        \n        feedback[\"examples\"] = {\n            \"good\": good_example,\n            \"bad\": bad_example,\n            \"suggestions\": suggestions\n        }\n        \n        # ğŸ§  Accessibility needs\n        print(\"\\nğŸ§  What accessibility needs are most important to you?\")\n        print(\"(comma-separated, e.g., visual clarity, reduced cognitive load, clear structure)\")\n        accessibility_needs = input(\"> \").strip()\n        if accessibility_needs:\n            feedback[\"accessibility_needs\"] = [need.strip() for need in accessibility_needs.split(\",\")]\n        \n        # ğŸ·ï¸ Naming preferences\n        print(\"\\nğŸ·ï¸ Variable naming preference:\")\n        print(\"1. snake_case (user_name)\")\n        print(\"2. camelCase (userName)\")\n        print(\"3. kebab-case (user-name)\")\n        print(\"4. Other\")\n        \n        var_choice = input(\"Enter choice (1-4): \").strip()\n        naming_prefs = {\"1\": \"snake_case\", \"2\": \"camelCase\", \"3\": \"kebab-case\"}\n        feedback[\"naming_preferences\"] = {\"variables\": [naming_prefs.get(var_choice, \"other\")]}\n        \n        # ğŸ“ Formatting preferences\n        print(\"\\nğŸ“ Indentation preference:\")\n        print(\"1. 2 spaces\")\n        print(\"2. 4 spaces\")\n        print(\"3. Tabs\")\n        \n        indent_choice = input(\"Enter choice (1-3): \").strip()\n        indent_prefs = {\"1\": \"2_spaces\", \"2\": \"4_spaces\", \"3\": \"tabs\"}\n        feedback[\"formatting_preferences\"] = {\"indentation\": [indent_prefs.get(indent_choice, \"other\")]}\n        \n        # ğŸ‘¤ User experience\n        print(\"\\nğŸ‘¤ About your experience (optional):\")\n        experience = input(\"How long have you used HyperCode? \").strip()\n        background = input(\"Programming background? \").strip()\n        \n        feedback[\"user_experience\"] = {\n            \"hypercode_experience\": experience,\n            \"programming_background\": background\n        }\n        \n        # â• Add feedback\n        if self.add_feedback(feedback):\n            print(\"\\nâœ… Thank you! Your feedback has been recorded.\")\n            print(\"ğŸ‰ You're helping make HyperCode better for everyone!\")\n        else:\n            print(\"\\nâŒ Sorry, there was an error saving your feedback.\")\n            print(\"ğŸ“§ Please try again or contact style@hypercode.dev\")\n\ndef main():\n    \"\"\"ğŸš€ Main entry point\"\"\"\n    parser = argparse.ArgumentParser(description=\"ğŸ¨ HyperCode Style Guide Feedback Collector\")\n    parser.add_argument(\"--repo-path\", default=\".\", help=\"Path to HyperCode repository\")\n    parser.add_argument(\"--interactive\", action=\"store_true\", help=\"Run interactive feedback collection\")\n    parser.add_argument(\"--report\", help=\"Generate feedback report to file\")\n    parser.add_argument(\"--analyze\", action=\"store_true\", help=\"Analyze existing feedback\")\n    parser.add_argument(\"--import-github\", help=\"Import feedback from GitHub (requires token)\")\n    \n    args = parser.parse_args()\n    \n    collector = StyleGuideCollector(args.repo_path)\n    \n    if args.interactive:\n        collector.interactive_feedback()\n    elif args.analyze:\n        analysis = collector.analyze_feedback()\n        print(\"ğŸ“Š Analysis complete!\")\n        print(f\"ğŸ“ Total entries: {analysis['summary']['total_entries']}\")\n        print(f\"ğŸ’¡ Recommendations generated: {len(analysis['recommendations'])}\")\n    elif args.report:\n        collector.generate_report(args.report)\n    elif args.import_github:\n        collector.import_github_issues(args.import_github)\n    else:\n        print(\"ğŸ¨ HyperCode Style Guide Feedback Collector\")\n        print(\"Use --help to see available options\")\n        print(\"\\nğŸš€ Quick start:\")\n        print(\"python style_guide_collector.py --interactive\")\n\nif __name__ == \"__main__\":\n    main()\n",
  "metadata": {},
  "relative_path": "style_guide_collector.py",
  "id": "725d516543803e88ddf9a0fb091d5de9"
}